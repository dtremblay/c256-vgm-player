
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass.exe --long-address -x --intel-hex -o vgm-player.hex --list vgm-player.lst vgm-player.asm
; Sat Sep 26 23:22:17 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: vgm-player.asm


;******  Processing file: macros_inc.asm


;******  Return to file: vgm-player.asm


;******  Processing file: bank_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				TMPPTR1          = $000000 ; 4 byte temporary pointer
=$000004				TMPPTR2          = $000004 ; 4 byte temporary pointer
=$000008				OPL2_ADDY_PTR_LO = $000008 ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000250				MONITOR_VARS     = $000250 ; Byte  MONITOR Variables. BASIC variables may overlap this space
=$000250				MCMDADDR         = $000250 ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000253				MCMP_TEXT        = $000253 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000256				MCMP_LEN         = $000256 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000258				MCMD             = $000258 ;3 Bytes Address of the current command/function string
=$00025b				MCMD_LEN         = $00025B ;2 Bytes Length of the current command/function string
=$00025d				MARG1            = $00025D ;4 Bytes First command argument. May be data or address, depending on command
=$000261				MARG2            = $000261 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000265				MARG3            = $000265 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000269				MARG4            = $000269 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$00026d				MARG5            = $00026D ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000271				MARG6            = $000271 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000275				MARG7            = $000275 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000279				MARG8            = $000279 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032c				BIOS_FLAGS       = $00032C      ; 1 byte - Flags for various BIOSy things:
=$00032d				BIOS_TIMER       = $00032D      ; 1 byte - the number of 1/60 ticks for a time out
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$38ff00				ISR_BEGIN        = $38FF00 ; Byte  Beginning of CPU vectors in Direct page
=$38ff00				HRESET           = $38FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$38ff10				HCOP             = $38FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$38ff20				HBRK             = $38FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$38ff30				HABORT           = $38FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$38ff40				HNMI             = $38FF40 ;32 Bytes Handle NMI
=$38ff60				HIRQ             = $38FF60 ;32 Bytes Handle IRQ
=$38ff80				Unused_FF80      = $38FF80 ;End of direct page Interrrupt handlers
=$38ffe0				VECTORS_BEGIN    = $38FFE0 ;0 Byte  Interrupt vectors
=$38ffe0				JMP_READY        = $38FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$38ffe4				VECTOR_COP       = $38FFE4 ;2 Bytes Native COP Interrupt vector
=$38ffe6				VECTOR_BRK       = $38FFE6 ;2 Bytes Native BRK Interrupt vector
=$38ffe8				VECTOR_ABORT     = $38FFE8 ;2 Bytes Native ABORT Interrupt vector
=$38ffea				VECTOR_NMI       = $38FFEA ;2 Bytes Native NMI Interrupt vector
=$38ffec				VECTOR_RESET     = $38FFEC ;2 Bytes Unused (Native RESET vector)
=$38ffee				VECTOR_IRQ       = $38FFEE ;2 Bytes Native IRQ Vector
=$38fff0				RETURN           = $38FFF0 ;4 Bytes RETURN key handler. Points to BASIC or MONITOR subroutine to execute when RETURN is pressed.
=$38fff4				VECTOR_ECOP      = $38FFF4 ;2 Bytes Emulation mode interrupt handler
=$38fff6				VECTOR_EBRK      = $38FFF6 ;2 Bytes Emulation mode interrupt handler
=$38fff8				VECTOR_EABORT    = $38FFF8 ;2 Bytes Emulation mode interrupt handler
=$38fffa				VECTOR_ENMI      = $38FFFA ;2 Bytes Emulation mode interrupt handler
=$38fffc				VECTOR_ERESET    = $38FFFC ;2 Bytes Emulation mode interrupt handler
=$38fffe				VECTOR_EIRQ      = $38FFFE ;2 Bytes Emulation mode interrupt handler
=$400000				VECTORS_END      = $400000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: vgm-player.asm


;******  Processing file: vicky_ii_def.asm

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				VKY_RESERVED_00         = $AF0002
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$af8800				FONT_MEMORY_BANK1       = $AF8800     ;$AF8800 - $AF8FFF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000
=$afe000				BTX_START               = $AFE000     ; BEATRIX Registers
=$afffff				BTX_END                 = $AFFFFF

;******  Return to file: vgm-player.asm


;******  Processing file: kernel_inc.asm

=$001000				BOOT             = $001000 ; Cold boot routine
=$001004				RESTORE          = $001004 ; Warm boot routine
=$001008				BREAK            = $001008 ; End program and return to command prompt
=$00100c				READY            = $00100C ; Print prompt and wait for keyboard input
=$001010				SCINIT           = $001010 ;
=$001014				IOINIT           = $001014 ;
=$001018				PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				PUTS             = $00101C ; Print a string to the currently selected channel
=$001020				PUTB             = $001020 ; Output a byte to the currently selected channel
=$001024				PUTBLOCK         = $001024 ; Ouput a binary block to the currently selected channel
=$001028				SETLFS           = $001028 ; Obsolete (done in OPEN)
=$00102c				SETNAM           = $00102C ; Obsolete (done in OPEN)
=$001030				OPEN             = $001030 ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
=$001034				CLOSE            = $001034 ; Close a channel
=$001038				SETIN            = $001038 ; Set the current input channel
=$00103c				SETOUT           = $00103C ; Set the current output channel
=$001040				GETB             = $001040 ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
=$001044				GETBLOCK         = $001044 ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
=$001048				GETCH            = $001048 ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
=$00104c				GETCHW           = $00104C ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001050				GETCHE           = $001050 ; Get a character from the input channel and echo to the screen. Wait if data is not ready.
=$001054				GETS             = $001054 ; Get a string from the input channel. NULL terminates
=$001058				GETLINE          = $001058 ; Get a line of text from input channel. CR or NULL terminates.
=$00105c				GETFIELD         = $00105C ; Get a field from the input channel. Value in A, CR, or NULL terminates
=$001060				TRIM             = $001060 ; Removes spaces at beginning and end of string.
=$001064				PRINTC           = $001064 ; Print character to screen. Handles terminal commands
=$001068				PRINTS           = $001068 ; Print string to screen. Handles terminal commands
=$00106c				PRINTCR          = $00106C ; Print Carriage Return
=$001070				PRINTF           = $001070 ; Print a float value
=$001074				PRINTI           = $001074 ; Prints integer value in TEMP
=$001078				PRINTH           = $001078 ; Print Hex value in DP variable
=$00107c				PRINTAI          = $00107C ; Prints integer value in A
=$001080				PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				LOCATE           = $001084 ;
=$001088				PUSHKEY          = $001088 ;
=$00108c				PUSHKEYS         = $00108C ;
=$001090				CSRRIGHT         = $001090 ;
=$001094				CSRLEFT          = $001094 ;
=$001098				CSRUP            = $001098 ;
=$00109c				CSRDOWN          = $00109C ;
=$0010a0				CSRHOME          = $0010A0 ;
=$0010a4				SCROLLUP         = $0010A4 ; Scroll the screen up one line. Creates an empty line at the bottom.
=$0010a8				CLRSCREEN        = $0010A8 ; Clear the screen
=$0010ac				INITCHLUT        = $0010AC ; Init character look-up table
=$0010b0				INITSUPERIO      = $0010B0 ; Init Super-IO chip
=$0010b4				INITKEYBOARD     = $0010B4 ; Init keyboard
=$0010bc				INITCURSOR       = $0010BC ; Init the Cursors registers
=$0010c0				INITFONTSET      = $0010C0 ; Init the Internal FONT Memory
=$0010c4				INITGAMMATABLE   = $0010C4 ; Init the RGB GAMMA Look Up Table
=$0010c8				INITALLLUT       = $0010C8 ; Init the Graphic Engine (Bitmap/Tile/Sprites) LUT
=$0010cc				INITVKYTXTMODE   = $0010CC ; Init the Text Mode @ Reset Time
=$0010d0				INITVKYGRPMODE   = $0010D0 ; Init the Basic Registers for the Graphic Mode
=$0010f0				F_OPEN           = $0010F0 ; open a file for reading/writing/creating
=$0010f4				F_CREATE         = $0010F4 ; create a new file
=$0010f8				F_CLOSE          = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				F_WRITE          = $0010FC ; write the current cluster to the file
=$001100				F_READ           = $001100 ; read the next cluster from the file
=$001104				F_DELETE         = $001104 ; delete a file / directory
=$001108				F_DIROPEN        = $001108 ; open a directory and seek the first directory entry
=$00110c				F_DIRNEXT        = $00110C ; seek to the next directory of an open directory
=$001110				F_DIRREAD        = $001110 ; Read the directory entry for the specified file
=$001114				F_DIRWRITE       = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				F_LOAD           = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				F_SAVE           = $00111C ; Save memory to a binary file
=$001120				CMDBLOCK         = $001120 ; Send a command to a block device
=$001124				F_RUN            = $001124 ; Load and run an executable binary file
=$001128				F_MOUNT          = $001128 ; Mount the designated block device
=$00112c				SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$001130				F_COPY           = $001130 ; Copy a file
=$001134				F_ALLOCFD        = $001134 ; Allocate a file descriptor
=$001138				F_FREEFD         = $001138 ; Free a file descriptor
=$38113c				TIMER0INTSUB     = $38113C ; Interrupt routine for Timer0
=$381140				TIMER1INTSUB     = $381140 ; Interrupt routine for Timer1
=$381144				TIMER2INTSUB     = $381144 ; Interrupt routine for Timer2

;******  Return to file: vgm-player.asm


;******  Processing file: timer_def.asm

=$000160				TIMER0_CTRL_REG   = $000160 ; (Write - Control, Read Status)
=$01					TMR0_EN     = $01
=$02					TMR0_SCLR   = $02
=$04					TMR0_SLOAD  = $04 ; Use SLOAD is
=$08					TMR0_UPDWN  = $08
=$000161				TIMER0_CHARGE_L   = $000161 ; Use if you want to Precharge and countdown
=$000162				TIMER0_CHARGE_M   = $000162 ;
=$000163				TIMER0_CHARGE_H   = $000163 ;
=$000164				TIMER0_CMP_REG    = $000164 ;
=$01					TMR0_CMP_RECLR     = $01 ; set to one for it to cycle when Counting up
=$02					TMR0_CMP_RELOAD    = $02 ; Set to one for it to reload when Counting Down
=$000165				TIMER0_CMP_L      = $000165 ; Load this Value for Countup
=$000166				TIMER0_CMP_M      = $000166 ;
=$000167				TIMER0_CMP_H      = $000167 ;
=$000168				TIMER1_CTRL_REG   = $000168 ;
=$01					TMR1_EN     = $01
=$02					TMR1_SCLR   = $02
=$04					TMR1_SLOAD  = $04
=$08					TMR1_UPDWN  = $08 ; 1 = Up, 0 = Down
=$000169				TIMER1_CHARGE_L   = $000169 ; Use if you want to Precharge and countdown
=$00016a				TIMER1_CHARGE_M   = $00016A ;
=$00016b				TIMER1_CHARGE_H   = $00016B ;
=$00016c				TIMER1_CMP_REG    = $00016C ;
=$01					TMR1_CMP_RECLR     = $01 ; set to one for it to cycle when Counting up
=$02					TMR1_CMP_RELOAD    = $02 ; Set to one for it to reload when Counting Down
=$00016d				TIMER1_CMP_L      = $00016D ;
=$00016e				TIMER1_CMP_M      = $00016E ;
=$00016f				TIMER1_CMP_H      = $00016F ;

;******  Return to file: vgm-player.asm


;******  Processing file: math_def.asm

=$000100				UNSIGNED_MULT_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				UNSIGNED_MULT_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				UNSIGNED_MULT_RESULT= $000104 ;4 Bytes Result of A x B
=$000108				SIGNED_MULT_A       = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				SIGNED_MULT_B       = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				SIGNED_MULT_RESULT  = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Signed divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  B/A
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in B/A
=$000114				D0_RESULT        = $000114 ;2 Bytes Signed quotient result of B/A ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Signed remainder of B/A ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Unsigned divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_A          = $000120 ; 4 bytes (32 bit) Accumulator A
=$000124				ADDER_B          = $000124 ; 4 bytes (32 bit) Accumulator B
=$000128				ADDER_R          = $000128 ; 4 bytes (32 bit) Result

;******  Return to file: vgm-player.asm


;******  Processing file: interrupt_def.asm

=$000140				INT_PENDING_REG0 = $000140 ;
=$000141				INT_PENDING_REG1 = $000141 ;
=$000142				INT_PENDING_REG2 = $000142 ;
=$000143				INT_PENDING_REG3 = $000143 ; FMX Model
=$000144				INT_POL_REG0     = $000144 ;
=$000145				INT_POL_REG1     = $000145 ;
=$000146				INT_POL_REG2     = $000146 ;
=$000147				INT_POL_REG3     = $000147 ; FMX Model
=$000148				INT_EDGE_REG0    = $000148 ;
=$000149				INT_EDGE_REG1    = $000149 ;
=$00014a				INT_EDGE_REG2    = $00014A ;
=$00014b				INT_EDGE_REG3    = $00014B ; FMX Model
=$00014c				INT_MASK_REG0    = $00014C ;
=$00014d				INT_MASK_REG1    = $00014D ;
=$00014e				INT_MASK_REG2    = $00014E ;
=$00014f				INT_MASK_REG3    = $00014F ; FMX Model
=$01					FNX0_INT00_SOF        = $01  ;Start of Frame @ 60FPS
=$02					FNX0_INT01_SOL        = $02  ;Start of Line (Programmable)
=$04					FNX0_INT02_TMR0       = $04  ;Timer 0 Interrupt
=$08					FNX0_INT03_TMR1       = $08  ;Timer 1 Interrupt
=$10					FNX0_INT04_TMR2       = $10  ;Timer 2 Interrupt
=$20					FNX0_INT05_RTC        = $20  ;Real-Time Clock Interrupt
=$40					FNX0_INT06_FDC        = $40  ;Floppy Disk Controller
=$80					FNX0_INT07_MOUSE      = $80  ; Mouse Interrupt (INT12 in SuperIO IOspace)
=$01					FNX1_INT00_KBD        = $01  ;Keyboard Interrupt
=$02					FNX1_INT01_SC0        = $02  ;VICKY_II (INT2) Sprite 2 Sprite Collision
=$04					FNX1_INT02_SC1        = $04  ;VICKY_II (INT3) Sprite 2 Tiles Collision
=$08					FNX1_INT03_COM2       = $08  ;Serial Port 2
=$10					FNX1_INT04_COM1       = $10  ;Serial Port 1
=$20					FNX1_INT05_MPU401     = $20  ;Midi Controller Interrupt
=$40					FNX1_INT06_LPT        = $40  ;Parallel Port
=$80					FNX1_INT07_SDCARD     = $80  ;SD Card Controller Interrupt (CH376S)
=$01					FNX2_INT00_OPL3       = $01  ;OPl3
=$02					FNX2_INT01_GABE_INT0  = $02  ;GABE (INT0) - TBD
=$04					FNX2_INT02_GABE_INT1  = $04  ;GABE (INT1) - TBD
=$08					FNX2_INT03_SDMA       = $08  ;VICKY_II (INT4)
=$10					FNX2_INT04_VDMA       = $10  ;VICKY_II (INT5)
=$20					FNX2_INT05_GABE_INT2  = $20  ;GABE (INT2) - TBD
=$40					FNX2_INT06_EXT        = $40  ;External Expansion
=$80					FNX2_INT07_SDCARD_INS = $80  ; SDCARD Insertion
=$01					FNX3_INT00_OPN2       = $01  ;OPN2
=$02					FNX3_INT01_OPM        = $02  ;OPM
=$04					FNX3_INT02_IDE        = $04  ;HDD IDE INTERRUPT
=$08					FNX3_INT03_TBD        = $08  ;TBD
=$10					FNX3_INT04_TBD        = $10  ;TBD
=$20					FNX3_INT05_TBD        = $20  ;GABE (INT2) - TBD
=$40					FNX3_INT06_TBD        = $40  ;External Expansion
=$80					FNX3_INT07_TBD        = $80  ;SDCARD Insertion

;******  Return to file: vgm-player.asm


;******  Processing file: sdos_inc.asm

.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					SIZE                .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
>001e					RESERVED            .word ?             ; Two reserved bytes to bring the descriptor up to 32 bytes
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$10					FD_STAT_ALLOC = $10                     ; The file descriptor has been allocated
=$38					FD_STAT_OPEN = $38                      ; The file is open
=$40					FD_STAT_ERROR = $40                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
=0					BIOS_DEV_FDC = 0                ; Floppy 0
=1					BIOS_DEV_FD1 = 1                ; Future support: Floppy 1 (not likely to be attached)
=2					BIOS_DEV_SD  = 2                ; SD card, partition 0
=3					BIOS_DEV_SD1 = 3                ; Future support: SD card, partition 1
=4					BIOS_DEV_SD2 = 4                ; Future support: SD card, partition 2
=5					BIOS_DEV_SD3 = 5                ; Future support: SD card, partition 3
=6					BIOS_DEV_HD0 = 6                ; Future support: IDE Drive 0, partition 0
=7					BIOS_DEV_HD1 = 7                ; Future support: IDE Drive 0, partition 1
=8					BIOS_DEV_HD2 = 8                ; Future support: IDE Drive 0, partition 2
=9					BIOS_DEV_HD3 = 9                ; Future support: IDE Drive 0, partition 3

;******  Return to file: vgm-player.asm

=$aff000				OPM_BASE_ADDRESS  = $AFF000
=$aff100				PSG_BASE_ADDRESS  = $AFF100
=$aff200				OPN2_BASE_ADDRESS = $AFF200
=$afe600				OPL3_BASE_ADRESS  = $AFE600
=$8					VGM_VERSION       = $8  ; 32-bits
=$c					SN_CLOCK          = $C  ; 32-bits
=$14					GD3_OFFSET        = $14 ; 32-bits
=$1c					LOOP_OFFSET       = $1C ; 32-bits
=$2c					YM_OFFSET         = $2C ; 32-bits
=$30					OPM_CLOCK         = $30 ; 32-bits
=$34					VGM_OFFSET        = $34 ; 32-bits
=$77					MIN_VERSION       = $77 ; 1 byte
=$78					DISPLAY_OFFSET    = $78 ; 2 bytes
=$7a					MSG_PTR           = $7A ; 3 bytes
=$7d					DATA_STREAM_CNT   = $7D ; 2 byte
=$7f					COMMAND           = $7F ; 1 byte
=$80					SONG_START        = $80 ; 4 bytes
=$84					CURRENT_POSITION  = $84 ; 4 bytes
=$88					WAIT_CNTR         = $88 ; 2 bytes
=$8a					PCM_OFFSET        = $8A ; 4 bytes
=$8e					GD3_POSITION      = $8E ; 4 bytes
=$92					AY_3_8910_A       = $92 ; 2 bytes
=$94					AY_3_8910_B       = $94 ; 2 bytes
=$96					AY_3_8910_C       = $96 ; 2 bytes
=$98					AY_3_8910_N       = $98 ; 2 bytes
=$9a					AY_BASE_AMPL      = $9A ; 1 byte
=$8000					DATA_STREAM_TBL   = $8000 ; each entry is 4 bytes
=$170000				VGM_FILE          = $170000  ; the address to store the VGM data.
.162200					VGM_START
.162200	e2 20		sep #$20	                SEP #$20        ; set A short
.162202	c2 10		rep #$10	                REP #$10        ; set X long
.162204	8b		phb		            PHB
.162205	0b		phd		            PHD
.162206	a9 00		lda #$00	            LDA #0
.162208	eb		xba		            XBA
.162209	a9 00		lda #$00	            LDA #0
.16220b	5b		tcd		            TCD  ; store 0 in the direct page register
.16220c	48		pha		            PHA
.16220d	ab		plb		            PLB  ; store 0 in the bank register
.16220e	85 7f		sta $7f		            STA COMMAND
.162210	a9 16		lda #$16	            LDA #`RESET_MSG
.162212	85 7c		sta $7c		            STA MSG_PTR+2
.162214	a6 17		ldx $17		            LDX $17
.162216	86 78		stx $78		            STX DISPLAY_OFFSET
.162218	20 d0 23	jsr $1623d0	            JSR LOAD_VGM_FILE
.16221b	a5 7f		lda $7f		            LDA COMMAND ; if the command is still 0, it's a vgm file
.16221d	d0 61		bne $162280	            BNE VGM_DONE
.16221f	a9 00		lda #$00	            LDA #0
.162221	8f 10 00 af	sta $af0010	            STA VKY_TXT_CURSOR_CTRL_REG
.162225	a2 00 00	ldx #$0000	            LDX #0
.162228	86 7d		stx $7d		            STX DATA_STREAM_CNT
.16222a	a9 17		lda #$17	            LDA #`VGM_FILE
.16222c	85 86		sta $86		            STA CURRENT_POSITION + 2
.16222e	85 82		sta $82		            STA SONG_START + 2
.162230	a2 00 00	ldx #$0000	            LDX #<>VGM_FILE
.162233	86 80		stx $80		            STX SONG_START
.162235	a9 00		lda #$00	            LDA #0
.162237	85 7f		sta $7f		            STA COMMAND
.162239	20 ab 23	jsr $1623ab	            JSR CHECK_VGM_FILE
.16223c	a5 7f		lda $7f		            LDA COMMAND ; if the command is still 0, it's a vgm file
.16223e	d0 34		bne $162274	            BNE INVALID_FILE
.162240	20 36 2a	jsr $162a36	            JSR VGM_SET_SONG_POINTERS
.162243	20 c3 2b	jsr $162bc3	            JSR VGM_DISPLAY_GD3
.162246	20 fb 2a	jsr $162afb	            JSR VGM_INIT_TIMER0
.162249	a9 ff		lda #$ff	            LDA #$FF
.16224b	8f 48 01 00	sta $000148	            STA @lINT_EDGE_REG0
.16224f	8f 49 01 00	sta $000149	            STA @lINT_EDGE_REG1
.162253	8f 4a 01 00	sta $00014a	            STA @lINT_EDGE_REG2
.162257	8f 4b 01 00	sta $00014b	            STA @lINT_EDGE_REG3
.16225b	a9 fb		lda #$fb	            LDA #~( FNX0_INT02_TMR0 ) ; | FNX0_INT00_SOF) ; uncomment this to debug in the IDE
.16225d	8f 4c 01 00	sta $00014c	            STA @lINT_MASK_REG0
.162261	a9 ff		lda #$ff	            LDA #$FF
.162263	8f 4d 01 00	sta $00014d	            STA @lINT_MASK_REG1
.162267	8f 4e 01 00	sta $00014e	            STA @lINT_MASK_REG2
.16226b	8f 4f 01 00	sta $00014f	            STA @lINT_MASK_REG3
.16226f	20 dd 24	jsr $1624dd	            JSR VGM_WRITE_REGISTER  ; the initial load of register should set the timerA
.162272	58		cli		            CLI
.162273	6b		rtl		            RTL
.162274					        INVALID_FILE
.162274	c2 20		rep #$20	                REP #$20        ; set A long
.162276	a9 b6 22	lda #$22b6	            LDA #<>INVALID_FILE_MSG
.162279	85 7a		sta $7a		            STA MSG_PTR
.16227b	e2 20		sep #$20	                SEP #$20        ; set A short
.16227d	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.162280					        VGM_DONE
.162280	2b		pld		            PLD
.162281	ab		plb		            PLB
.162282	6b		rtl		            RTL
>162283	52 65 73 74 61 72 74 69		RESET_MSG               .text 'Restarting song:',0
>16228b	6e 67 20 73 6f 6e 67 3a 00
>162294	4c 6f 6f 70 69 6e 67 20		LOOPING_MSG             .text 'Looping song:',0
>16229c	73 6f 6e 67 3a 00
>1622a2	52 65 61 64 69 6e 67 20		DATA_BLOCK_MSG          .text 'Reading Data Block:',0
>1622aa	44 61 74 61 20 42 6c 6f 63 6b 3a 00
>1622b6	49 6e 76 61 6c 69 64 20		INVALID_FILE_MSG        .text 'Invalid file type:', 0
>1622be	66 69 6c 65 20 74 79 70 65 3a 00
>1622c9	55 6e 6b 6e 6f 77 6e 20		UNK_CMD1_MSG            .text 'Unknown 1-Byte Command:',0
>1622d1	31 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>1622e1	55 6e 6b 6e 6f 77 6e 20		UNK_CMD2_MSG            .text 'Unknown 2-Byte Command:',0
>1622e9	32 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>1622f9	55 6e 6b 6e 6f 77 6e 20		UNK_CMD3_MSG            .text 'Unknown 3-Byte Command:',0
>162301	33 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>162311	55 6e 6b 6e 6f 77 6e 20		UNK_CMD4_MSG            .text 'Unknown 4-Byte Command:',0
>162319	34 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>162329	30 31 32 33 34 35 36 37		HEX_VALUES              .text '0123456789ABCDEF'
>162331	38 39 41 42 43 44 45 46
>162339	43 6f 75 6c 64 6e 27 74		GD3_ERR_MSG             .text 'Couldn''t read Gd3 Info', 0
>162341	20 72 65 61 64 20 47 64 33 20 49 6e 66 6f 00
>162350	56 47 4d 20 50 6c 61 79		LOADING_VGM_FILE_MSG    .text 'VGM Player loading file', 0
>162358	65 72 20 6c 6f 61 64 69 6e 67 20 66 69 6c 65 00
>162368	42 52 55 4e 20 64 6f 65		BRUN_CMD_ERROR_MSG      .text 'BRUN does not have a file to load.', 0
>162370	73 20 6e 6f 74 20 68 61 76 65 20 61 20 66 69 6c
>162380	65 20 74 6f 20 6c 6f 61 64 2e 00
.16238b					DOS_REC_PTR
>16238b					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>16238c					DEV                 .byte ?             ; The ID of the device holding the file
>16238d					PATH                .dword ?            ; Pointer to a NULL terminated path string
>162391					CLUSTER             .dword ?            ; The current cluster of the file.
>162395					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>162399					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>16239d					SIZE                .dword ?            ; The size of the file
>1623a1					CREATE_DATE         .word ?             ; The creation date of the file
>1623a3					CREATE_TIME         .word ?             ; The creation time of the file
>1623a5					MODIFIED_DATE       .word ?             ; The modification date of the file
>1623a7					MODIFIED_TIME       .word ?             ; The modification time of the file
>1623a9					RESERVED            .word ?             ; Two reserved bytes to bring the descriptor up to 32 bytes
.1623ab					CHECK_VGM_FILE
.1623ab	a0 00 00	ldy #$0000	            LDY #0
.1623ae	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623b0	c8		iny		            INY
.1623b1	c9 56		cmp #$56	            CMP #'V'
.1623b3	d0 16		bne $1623cb	            BNE CHECK_FAILED
.1623b5	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623b7	c8		iny		            INY
.1623b8	c9 67		cmp #$67	            CMP #'g'
.1623ba	d0 0f		bne $1623cb	            BNE CHECK_FAILED
.1623bc	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623be	c8		iny		            INY
.1623bf	c9 6d		cmp #$6d	            CMP #'m'
.1623c1	d0 08		bne $1623cb	            BNE CHECK_FAILED
.1623c3	a0 08 00	ldy #$0008	            LDY #8
.1623c6	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623c8	85 77		sta $77		            STA MIN_VERSION
.1623ca	60		rts		            RTS
.1623cb					    CHECK_FAILED
.1623cb	a9 01		lda #$01	            LDA #1
.1623cd	85 7f		sta $7f		            STA COMMAND
.1623cf	60		rts		            RTS
.1623d0					LOAD_VGM_FILE
.1623d0	48		pha		                PHA             ; begin setdp macro
.1623d1	08		php		                PHP
.1623d2	c2 20		rep #$20	                REP #$20        ; set A long
.1623d4	a9 60 03	lda #$0360	                LDA #<>DOS_RUN_PARAM         ; set DP to page 0
.1623d7	5b		tcd		                TCD
.1623d8	28		plp		                PLP
.1623d9	68		pla		                PLA             ; end setdp macro
.1623da	a0 00 00	ldy #$0000	            LDY #0
.1623dd					    FS_LOOP
.1623dd	b7 00		lda [$0360],y	            LDA [DOS_RUN_PARAM],Y
.1623df	c8		iny		            INY
.1623e0	c0 20 00	cpy #$0020	            CPY #$20 ; expect the vgm command to be less than 32 characters
.1623e3	b0 1c		bcs $162401	            BGE LF_ERROR
.1623e5	c9 20		cmp #$20	            CMP #' '  ; seek the space character in the BRUN command
.1623e7	d0 f4		bne $1623dd	            BNE FS_LOOP
.1623e9	5a		phy		            PHY
.1623ea	0b		phd		            PHD
.1623eb	48		pha		                PHA             ; begin setdp macro
.1623ec	08		php		                PHP
.1623ed	c2 20		rep #$20	                REP #$20        ; set A long
.1623ef	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.1623f2	5b		tcd		                TCD
.1623f3	28		plp		                PLP
.1623f4	68		pla		                PLA             ; end setdp macro
.1623f5	a0 50 23	ldy #$2350	            LDY #<>LOADING_VGM_FILE_MSG
.1623f8	84 7a		sty $7a		            STY MSG_PTR
.1623fa	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.1623fd	2b		pld		            PLD
.1623fe	7a		ply		            PLY
.1623ff	80 17		bra $162418	            BRA LF_GOOD
.162401					    LF_ERROR
.162401	48		pha		                PHA             ; begin setdp macro
.162402	08		php		                PHP
.162403	c2 20		rep #$20	                REP #$20        ; set A long
.162405	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.162408	5b		tcd		                TCD
.162409	28		plp		                PLP
.16240a	68		pla		                PLA             ; end setdp macro
.16240b	a0 68 23	ldy #$2368	            LDY #<>BRUN_CMD_ERROR_MSG
.16240e	84 7a		sty $7a		            STY MSG_PTR
.162410	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.162413	a9 01		lda #$01	            LDA #1
.162415	85 7f		sta $7f		            STA COMMAND
.162417	60		rts		            RTS
.162418					    LF_GOOD
.162418	c2 20		rep #$20	                REP #$20        ; set A long
.16241a	98		tya		            TYA
.16241b	18		clc		            CLC
.16241c	6d 60 03	adc $0360	            ADC DOS_RUN_PARAM
.16241f	8f 8d 23 16	sta $16238d	            STA DOS_REC_PTR.PATH
.162423	ad 62 03	lda $0362	            LDA DOS_RUN_PARAM + 2
.162426	8f 8f 23 16	sta $16238f	            STA DOS_REC_PTR.PATH + 2
.16242a	a9 00 00	lda #$0000	            LDA #<>VGM_FILE
.16242d	8d 54 03	sta $0354	            STA DOS_DST_PTR
.162430	a9 17 00	lda #$0017	            LDA #`VGM_FILE
.162433	8d 56 03	sta $0356	            STA DOS_DST_PTR + 2
.162436	a9 8b 23	lda #$238b	            LDA #<>DOS_REC_PTR
.162439	8d 40 03	sta $0340	            STA DOS_FD_PTR
.16243c	a9 16 00	lda #$0016	            LDA #`DOS_REC_PTR
.16243f	8d 42 03	sta $0342	            STA DOS_FD_PTR + 2
.162442	a9 00 20	lda #$2000	            LDA #<>VGM_START - 512
.162445	8f 99 23 16	sta $162399	            STA DOS_REC_PTR.BUFFER
.162449	a9 16 00	lda #$0016	            LDA #`(VGM_START - 512)
.16244c	8f 9b 23 16	sta $16239b	            STA DOS_REC_PTR.BUFFER + 2
.162450	e2 20		sep #$20	                SEP #$20        ; set A short
.162452	a9 00		lda #$00	            LDA #0
.162454	8f 8b 23 16	sta $16238b	            STA DOS_REC_PTR.STATUS
.162458	a9 02		lda #$02	            LDA #BIOS_DEV_SD
.16245a	8f 8c 23 16	sta $16238c	            STA DOS_REC_PTR.DEV
.16245e	22 18 11 00	jsl $001118	            JSL F_LOAD
.162462	48		pha		                PHA             ; begin setdp macro
.162463	08		php		                PHP
.162464	c2 20		rep #$20	                REP #$20        ; set A long
.162466	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.162469	5b		tcd		                TCD
.16246a	28		plp		                PLP
.16246b	68		pla		                PLA             ; end setdp macro
.16246c	60		rts		            RTS
.16246d					DISPLAY_MSG
.16246d	5a		phy		            PHY
.16246e	a6 78		ldx $78		            LDX DISPLAY_OFFSET
.162470	a0 00 00	ldy #$0000	            LDY #0
.162473	a9 00		lda #$00	            LDA #0
.162475	eb		xba		            XBA
.162476					    DISPLAY_NEXT
.162476	a9 2d		lda #$2d	            LDA #$2D   ; Text color
.162478	9f 00 20 af	sta $af2000,x	            STA $AF2000,X  ; offset to Text LUT $AF:C000
.16247c	b7 7a		lda [$7a],y	            LDA [MSG_PTR],Y
.16247e	9f 00 00 af	sta $af0000,x	            STA $AF0000,X  ; offset to Text $AF:A000
.162482	e8		inx		            INX
.162483	c8		iny		            INY
.162484	c9 00		cmp #$00	            CMP #0
.162486	d0 ee		bne $162476	            BNE DISPLAY_NEXT
.162488	a9 2d		lda #$2d	            LDA #$2D
.16248a	9f 00 20 af	sta $af2000,x	            STA $AF2000,X
.16248e	a5 7f		lda $7f		            LDA COMMAND
.162490	29 f0		and #$f0	            AND #$F0
.162492	4a		lsr a		            LSR A
.162493	4a		lsr a		            LSR A
.162494	4a		lsr a		            LSR A
.162495	4a		lsr a		            LSR A
.162496	9b		txy		            TXY
.162497	aa		tax		            TAX
.162498	bf 29 23 16	lda $162329,x	            LDA HEX_VALUES,X
.16249c	bb		tyx		            TYX
.16249d	9f 00 00 af	sta $af0000,x	            STA $AF0000,X
.1624a1	e8		inx		            INX
.1624a2	a9 2d		lda #$2d	            LDA #$2D
.1624a4	9f 00 20 af	sta $af2000,x	            STA $AF2000,X
.1624a8	a5 7f		lda $7f		            LDA COMMAND
.1624aa	29 0f		and #$0f	            AND #$F
.1624ac	9b		txy		            TXY
.1624ad	aa		tax		            TAX
.1624ae	bf 29 23 16	lda $162329,x	            LDA HEX_VALUES,X
.1624b2	bb		tyx		            TYX
.1624b3	9f 00 00 af	sta $af0000,x	            STA $AF0000,X
.1624b7	c2 20		rep #$20	                REP #$20        ; set A long
.1624b9	a5 78		lda $78		            LDA DISPLAY_OFFSET
.1624bb	18		clc		            CLC
.1624bc	69 50 00	adc #$0050	            ADC #80 ; 80 columns in 640x480 mode
.1624bf	85 78		sta $78		            STA DISPLAY_OFFSET
.1624c1	e2 20		sep #$20	                SEP #$20        ; set A short
.1624c3	eb		xba		            XBA
.1624c4	c9 b1		cmp #$b1	            CMP #$B1 ; 80 COLS * 56 ROWS = $1180  - SO $11 + A0 = $B1
.1624c6	90 13		bcc $1624db	            BLT DISPLAY_DONE
.1624c8	eb		xba		            XBA
.1624c9	d0 07		bne $1624d2	            BNE FIRST_COL
.1624cb	a2 28 a0	ldx #$a028	            LDX #$A000 + 40 ; create a second column
.1624ce	86 78		stx $78		            STX DISPLAY_OFFSET
.1624d0	80 09		bra $1624db	            BRA DISPLAY_DONE
.1624d2					        FIRST_COL
.1624d2	a2 00 a0	ldx #$a000	            LDX #$A000
.1624d5	86 78		stx $78		            STX DISPLAY_OFFSET
.1624d7	22 a8 10 00	jsl $0010a8	            JSL CLRSCREEN
.1624db					    DISPLAY_DONE
.1624db	7a		ply		            PLY
.1624dc	60		rts		            RTS
.1624dd					VGM_WRITE_REGISTER
.1624dd	a6 88		ldx $88		            LDX WAIT_CNTR
.1624df	e0 00 00	cpx #$0000	            CPX #0
.1624e2	f0 04		beq $1624e8	            BEQ READ_COMMAND
.1624e4	ca		dex		            DEX
.1624e5	86 88		stx $88		            STX WAIT_CNTR
.1624e7	60		rts		            RTS
.1624e8					    READ_COMMAND
.1624e8	a9 00		lda #$00	            LDA #0
.1624ea	eb		xba		            XBA
.1624eb	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1624ed	85 7f		sta $7f		            STA COMMAND
.1624ef	c2 20		rep #$20	                REP #$20        ; set A long
.1624f1	e6 84		inc $84		            INC CURRENT_POSITION
.1624f3	d0 02		bne $1624f7	            BNE increment_done
.1624f5	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1624f7					    increment_done
.1624f7	e2 20		sep #$20	                SEP #$20        ; set A short
.1624f9	29 f0		and #$f0	            AND #$F0
.1624fb	4a		lsr a		            LSR A
.1624fc	4a		lsr a		            LSR A
.1624fd	4a		lsr a		            LSR A
.1624fe	aa		tax		            TAX
.1624ff	7c 03 25	jmp ($162503,x)	            JMP (VGM_COMMAND_TABLE,X)
.162502					    VGM_LOOP_DONE
.162502	60		rts		            RTS
.162503					VGM_COMMAND_TABLE
>162503	23 25				            .word <>INVALID_COMMAND ;0
>162505	23 25				            .word <>INVALID_COMMAND ;1
>162507	23 25				            .word <>INVALID_COMMAND ;2
>162509	26 25				            .word <>SKIP_BYTE_CMD   ;3 - reserved - not implemented
>16250b	26 25				            .word <>SKIP_BYTE_CMD   ;4 - not implemented
>16250d	b9 27				            .word <>WRITE_YM_CMD    ;5 - YM*
>16250f	b0 29				            .word <>WAIT_COMMANDS   ;6
>162511	02 2a				            .word <>WAIT_N_1        ;7
>162513	10 2a				            .word <>YM2612_SAMPLE   ;8
>162515	33 2a				            .word <>DAC_STREAM      ;9
>162517	07 26				            .word <>AY8910          ;A - AY8910
>162519	3f 25				            .word <>SKIP_TWO_BYTES  ;B - not implemented
>16251b	5e 25				            .word <>SKIP_THREE_BYTES;C - not implemented
>16251d	5e 25				            .word <>SKIP_THREE_BYTES;D - not implemented
>16251f	83 25				            .word <>SEEK_OFFSET     ;E - not implemented
>162521	dc 25				            .word <>SKIP_FOUR_BYTES ;F - not implemented
.162523					INVALID_COMMAND
.162523	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162526					SKIP_BYTE_CMD
.162526	c2 20		rep #$20	                REP #$20        ; set A long
.162528	a9 c9 22	lda #$22c9	            LDA #<>UNK_CMD1_MSG
.16252b	85 7a		sta $7a		            STA MSG_PTR
.16252d	e2 20		sep #$20	                SEP #$20        ; set A short
.16252f	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.162532	c2 20		rep #$20	                REP #$20        ; set A long
.162534	e6 84		inc $84		            INC CURRENT_POSITION
.162536	d0 02		bne $16253a	            BNE increment_done
.162538	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16253a					    increment_done
.16253a	e2 20		sep #$20	                SEP #$20        ; set A short
.16253c	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.16253f					SKIP_TWO_BYTES
.16253f	c2 20		rep #$20	                REP #$20        ; set A long
.162541	a9 e1 22	lda #$22e1	            LDA #<>UNK_CMD2_MSG
.162544	85 7a		sta $7a		            STA MSG_PTR
.162546	e2 20		sep #$20	                SEP #$20        ; set A short
.162548	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.16254b	c2 20		rep #$20	                REP #$20        ; set A long
.16254d	e6 84		inc $84		            INC CURRENT_POSITION
.16254f	d0 02		bne $162553	            BNE s2_1
.162551	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162553					    s2_1
.162553	e6 84		inc $84		            INC CURRENT_POSITION
.162555	d0 02		bne $162559	            BNE s2_2
.162557	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162559					    s2_2
.162559	e2 20		sep #$20	                SEP #$20        ; set A short
.16255b	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.16255e					SKIP_THREE_BYTES
.16255e	c2 20		rep #$20	                REP #$20        ; set A long
.162560	a9 f9 22	lda #$22f9	            LDA #<>UNK_CMD3_MSG
.162563	85 7a		sta $7a		            STA MSG_PTR
.162565	e2 20		sep #$20	                SEP #$20        ; set A short
.162567	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.16256a	c2 20		rep #$20	                REP #$20        ; set A long
.16256c	e6 84		inc $84		            INC CURRENT_POSITION
.16256e	d0 02		bne $162572	            BNE s3_1
.162570	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162572					    s3_1
.162572	e6 84		inc $84		            INC CURRENT_POSITION
.162574	d0 02		bne $162578	            BNE s3_2
.162576	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162578					    s3_2
.162578	e6 84		inc $84		            INC CURRENT_POSITION
.16257a	d0 02		bne $16257e	            BNE s3_3
.16257c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16257e					    s3_3
.16257e	e2 20		sep #$20	                SEP #$20        ; set A short
.162580	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162583					SEEK_OFFSET
.162583	a5 7f		lda $7f		            LDA COMMAND
.162585	c9 e0		cmp #$e0	            CMP #$E0
.162587	d0 53		bne $1625dc	            BNE SKIP_FOUR_BYTES
.162589	c2 20		rep #$20	                REP #$20        ; set A long
.16258b	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16258d	8d 20 01	sta $0120	            STA ADDER_A
.162590	c2 20		rep #$20	                REP #$20        ; set A long
.162592	e6 84		inc $84		            INC CURRENT_POSITION
.162594	d0 02		bne $162598	            BNE increment_done
.162596	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162598					    increment_done
.162598	e2 20		sep #$20	                SEP #$20        ; set A short
.16259a	c2 20		rep #$20	                REP #$20        ; set A long
.16259c	e6 84		inc $84		            INC CURRENT_POSITION
.16259e	d0 02		bne $1625a2	            BNE increment_done
.1625a0	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625a2					    increment_done
.1625a2	e2 20		sep #$20	                SEP #$20        ; set A short
.1625a4	c2 20		rep #$20	                REP #$20        ; set A long
.1625a6	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1625a8	8d 22 01	sta $0122	            STA ADDER_A + 2
.1625ab	c2 20		rep #$20	                REP #$20        ; set A long
.1625ad	e6 84		inc $84		            INC CURRENT_POSITION
.1625af	d0 02		bne $1625b3	            BNE increment_done
.1625b1	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625b3					    increment_done
.1625b3	e2 20		sep #$20	                SEP #$20        ; set A short
.1625b5	c2 20		rep #$20	                REP #$20        ; set A long
.1625b7	e6 84		inc $84		            INC CURRENT_POSITION
.1625b9	d0 02		bne $1625bd	            BNE increment_done
.1625bb	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625bd					    increment_done
.1625bd	e2 20		sep #$20	                SEP #$20        ; set A short
.1625bf	c2 20		rep #$20	                REP #$20        ; set A long
.1625c1	ad 00 80	lda $8000	            LDA DATA_STREAM_TBL
.1625c4	8d 24 01	sta $0124	            STA ADDER_B
.1625c7	ad 02 80	lda $8002	            LDA DATA_STREAM_TBL + 2
.1625ca	8d 26 01	sta $0126	            STA ADDER_B + 2
.1625cd	ad 28 01	lda $0128	            LDA ADDER_R
.1625d0	85 8a		sta $8a		            STA PCM_OFFSET
.1625d2	ad 2a 01	lda $012a	            LDA ADDER_R + 2
.1625d5	85 8c		sta $8c		            STA PCM_OFFSET + 2
.1625d7	e2 20		sep #$20	                SEP #$20        ; set A short
.1625d9	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE
.1625dc					SKIP_FOUR_BYTES
.1625dc	c2 20		rep #$20	                REP #$20        ; set A long
.1625de	a9 11 23	lda #$2311	            LDA #<>UNK_CMD4_MSG
.1625e1	85 7a		sta $7a		            STA MSG_PTR
.1625e3	e2 20		sep #$20	                SEP #$20        ; set A short
.1625e5	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.1625e8	c2 20		rep #$20	                REP #$20        ; set A long
.1625ea	e6 84		inc $84		            INC CURRENT_POSITION
.1625ec	d0 02		bne $1625f0	            BNE s4_1
.1625ee	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625f0					    s4_1
.1625f0	e6 84		inc $84		            INC CURRENT_POSITION
.1625f2	d0 02		bne $1625f6	            BNE s4_2
.1625f4	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625f6					    s4_2
.1625f6	e6 84		inc $84		            INC CURRENT_POSITION
.1625f8	d0 02		bne $1625fc	            BNE s4_3
.1625fa	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625fc					    s4_3
.1625fc	e6 84		inc $84		            INC CURRENT_POSITION
.1625fe	d0 02		bne $162602	            BNE s4_4
.162600	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162602					    s4_4
.162602	e2 20		sep #$20	                SEP #$20        ; set A short
.162604	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162607					AY8910
.162607	a9 0f		lda #$0f	            LDA #$F
.162609	85 9a		sta $9a		            STA AY_BASE_AMPL
.16260b	a5 7f		lda $7f		            LDA COMMAND
.16260d	c9 a0		cmp #$a0	            CMP #$A0
.16260f	f0 03		beq $162614	            BEQ AY_COMMAND
.162611	4c 3f 25	jmp $16253f	            JMP SKIP_TWO_BYTES ; when mixing with the YM2612, the SN76489 is just too load.
.162614					    AY_COMMAND
.162614	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162616	c2 20		rep #$20	                REP #$20        ; set A long
.162618	e6 84		inc $84		            INC CURRENT_POSITION
.16261a	d0 02		bne $16261e	            BNE increment_done
.16261c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16261e					    increment_done
.16261e	e2 20		sep #$20	                SEP #$20        ; set A short
.162620	c9 00		cmp #$00	            CMP #0 ; Register 0 fine
.162622	d0 4c		bne $162670	            BNE AY_R1
.162624	a5 92		lda $92		            LDA AY_3_8910_A
.162626	c9 08		cmp #$08	            CMP #8
.162628	90 19		bcc $162643	            BLT R0_FINE
.16262a	a9 87		lda #$87	            LDA #$87
.16262c	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162630	a9 3f		lda #$3f	            LDA #$3F
.162632	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162636	c2 20		rep #$20	                REP #$20        ; set A long
.162638	e6 84		inc $84		            INC CURRENT_POSITION
.16263a	d0 02		bne $16263e	            BNE increment_done
.16263c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16263e					    increment_done
.16263e	e2 20		sep #$20	                SEP #$20        ; set A short
.162640	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162643					        R0_FINE
.162643	eb		xba		            XBA
.162644	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162646	c2 20		rep #$20	                REP #$20        ; set A long
.162648	e6 84		inc $84		            INC CURRENT_POSITION
.16264a	d0 02		bne $16264e	            BNE increment_done
.16264c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16264e					    increment_done
.16264e	e2 20		sep #$20	                SEP #$20        ; set A short
.162650	c2 20		rep #$20	                REP #$20        ; set A long
.162652	4a		lsr a		            LSR A ; drop the LSB
.162653	e2 20		sep #$20	                SEP #$20        ; set A short
.162655	48		pha		            PHA
.162656	29 0f		and #$0f	            AND #$F
.162658	09 80		ora #$80	            ORA #$80
.16265a	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16265e	68		pla		            PLA
.16265f	c2 20		rep #$20	                REP #$20        ; set A long
.162661	4a		lsr a		            LSR A
.162662	4a		lsr a		            LSR A
.162663	4a		lsr a		            LSR A
.162664	4a		lsr a		            LSR A
.162665	e2 20		sep #$20	                SEP #$20        ; set A short
.162667	29 3f		and #$3f	            AND #$3F ; 6 bits
.162669	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16266d	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162670	c9 01		cmp #$01	    AY_R1   CMP #1
.162672	d0 13		bne $162687	            BNE AY_R2
.162674	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162676	c2 20		rep #$20	                REP #$20        ; set A long
.162678	e6 84		inc $84		            INC CURRENT_POSITION
.16267a	d0 02		bne $16267e	            BNE increment_done
.16267c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16267e					    increment_done
.16267e	e2 20		sep #$20	                SEP #$20        ; set A short
.162680	29 0f		and #$0f	            AND #$F
.162682	85 92		sta $92		            STA AY_3_8910_A
.162684	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162687	c9 02		cmp #$02	    AY_R2   CMP #2
.162689	d0 4c		bne $1626d7	            BNE AY_R3
.16268b	a5 94		lda $94		            LDA AY_3_8910_B
.16268d	c9 08		cmp #$08	            CMP #8
.16268f	90 19		bcc $1626aa	            BLT R1_FINE
.162691	a9 a7		lda #$a7	            LDA #$A7
.162693	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162697	a9 3f		lda #$3f	            LDA #$3F
.162699	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16269d	c2 20		rep #$20	                REP #$20        ; set A long
.16269f	e6 84		inc $84		            INC CURRENT_POSITION
.1626a1	d0 02		bne $1626a5	            BNE increment_done
.1626a3	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1626a5					    increment_done
.1626a5	e2 20		sep #$20	                SEP #$20        ; set A short
.1626a7	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.1626aa					        R1_FINE
.1626aa	eb		xba		            XBA
.1626ab	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1626ad	c2 20		rep #$20	                REP #$20        ; set A long
.1626af	e6 84		inc $84		            INC CURRENT_POSITION
.1626b1	d0 02		bne $1626b5	            BNE increment_done
.1626b3	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1626b5					    increment_done
.1626b5	e2 20		sep #$20	                SEP #$20        ; set A short
.1626b7	c2 20		rep #$20	                REP #$20        ; set A long
.1626b9	4a		lsr a		            LSR A ; drop the LSB
.1626ba	e2 20		sep #$20	                SEP #$20        ; set A short
.1626bc	48		pha		            PHA
.1626bd	29 0f		and #$0f	            AND #$F
.1626bf	09 a0		ora #$a0	            ORA #$A0
.1626c1	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626c5	68		pla		            PLA
.1626c6	c2 20		rep #$20	                REP #$20        ; set A long
.1626c8	4a		lsr a		            LSR A
.1626c9	4a		lsr a		            LSR A
.1626ca	4a		lsr a		            LSR A
.1626cb	4a		lsr a		            LSR A
.1626cc	e2 20		sep #$20	                SEP #$20        ; set A short
.1626ce	29 3f		and #$3f	            AND #$3F ; 6 bits
.1626d0	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626d4	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.1626d7	c9 03		cmp #$03	    AY_R3   CMP #3
.1626d9	d0 13		bne $1626ee	            BNE AY_R4
.1626db	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1626dd	c2 20		rep #$20	                REP #$20        ; set A long
.1626df	e6 84		inc $84		            INC CURRENT_POSITION
.1626e1	d0 02		bne $1626e5	            BNE increment_done
.1626e3	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1626e5					    increment_done
.1626e5	e2 20		sep #$20	                SEP #$20        ; set A short
.1626e7	29 0f		and #$0f	            AND #$F
.1626e9	85 94		sta $94		            STA AY_3_8910_B
.1626eb	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.1626ee	c9 04		cmp #$04	    AY_R4   CMP #4
.1626f0	d0 4c		bne $16273e	            BNE AY_R5
.1626f2	a5 96		lda $96		            LDA AY_3_8910_C
.1626f4	c9 08		cmp #$08	            CMP #8
.1626f6	90 19		bcc $162711	            BLT R2_FINE
.1626f8	a9 c7		lda #$c7	            LDA #$C7
.1626fa	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626fe	a9 3f		lda #$3f	            LDA #$3F
.162700	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162704	c2 20		rep #$20	                REP #$20        ; set A long
.162706	e6 84		inc $84		            INC CURRENT_POSITION
.162708	d0 02		bne $16270c	            BNE increment_done
.16270a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16270c					    increment_done
.16270c	e2 20		sep #$20	                SEP #$20        ; set A short
.16270e	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162711					        R2_FINE
.162711	eb		xba		            XBA
.162712	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162714	c2 20		rep #$20	                REP #$20        ; set A long
.162716	e6 84		inc $84		            INC CURRENT_POSITION
.162718	d0 02		bne $16271c	            BNE increment_done
.16271a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16271c					    increment_done
.16271c	e2 20		sep #$20	                SEP #$20        ; set A short
.16271e	c2 20		rep #$20	                REP #$20        ; set A long
.162720	4a		lsr a		            LSR A ; drop the LSB
.162721	e2 20		sep #$20	                SEP #$20        ; set A short
.162723	48		pha		            PHA
.162724	29 0f		and #$0f	            AND #$F
.162726	09 c0		ora #$c0	            ORA #$C0
.162728	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16272c	68		pla		            PLA
.16272d	c2 20		rep #$20	                REP #$20        ; set A long
.16272f	4a		lsr a		            LSR A
.162730	4a		lsr a		            LSR A
.162731	4a		lsr a		            LSR A
.162732	4a		lsr a		            LSR A
.162733	e2 20		sep #$20	                SEP #$20        ; set A short
.162735	29 3f		and #$3f	            AND #$3F ; 6 bits
.162737	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16273b	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.16273e	c9 05		cmp #$05	    AY_R5   CMP #5
.162740	d0 13		bne $162755	            BNE AY_R10
.162742	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162744	c2 20		rep #$20	                REP #$20        ; set A long
.162746	e6 84		inc $84		            INC CURRENT_POSITION
.162748	d0 02		bne $16274c	            BNE increment_done
.16274a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16274c					    increment_done
.16274c	e2 20		sep #$20	                SEP #$20        ; set A short
.16274e	29 0f		and #$0f	            AND #$F
.162750	85 96		sta $96		            STA AY_3_8910_C
.162752	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162755					    AY_R10
.162755	c9 08		cmp #$08	            CMP #8
.162757	d0 19		bne $162772	            BNE AY_R11
.162759	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16275b	c2 20		rep #$20	                REP #$20        ; set A long
.16275d	e6 84		inc $84		            INC CURRENT_POSITION
.16275f	d0 02		bne $162763	            BNE increment_done
.162761	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162763					    increment_done
.162763	e2 20		sep #$20	                SEP #$20        ; set A short
.162765	45 9a		eor $9a		            EOR AY_BASE_AMPL
.162767	29 0f		and #$0f	            AND #$F
.162769	09 90		ora #$90	            ORA #$90
.16276b	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16276f	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162772					    AY_R11
.162772	c9 09		cmp #$09	            CMP #9
.162774	d0 19		bne $16278f	            BNE AY_R12
.162776	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162778	c2 20		rep #$20	                REP #$20        ; set A long
.16277a	e6 84		inc $84		            INC CURRENT_POSITION
.16277c	d0 02		bne $162780	            BNE increment_done
.16277e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162780					    increment_done
.162780	e2 20		sep #$20	                SEP #$20        ; set A short
.162782	45 9a		eor $9a		            EOR AY_BASE_AMPL
.162784	29 0f		and #$0f	            AND #$F
.162786	09 b0		ora #$b0	            ORA #$B0
.162788	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16278c	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.16278f					    AY_R12
.16278f	c9 0a		cmp #$0a	            CMP #10
.162791	d0 19		bne $1627ac	            BNE AY_R15
.162793	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162795	c2 20		rep #$20	                REP #$20        ; set A long
.162797	e6 84		inc $84		            INC CURRENT_POSITION
.162799	d0 02		bne $16279d	            BNE increment_done
.16279b	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16279d					    increment_done
.16279d	e2 20		sep #$20	                SEP #$20        ; set A short
.16279f	45 9a		eor $9a		            EOR AY_BASE_AMPL
.1627a1	29 0f		and #$0f	            AND #$F
.1627a3	09 d0		ora #$d0	            ORA #$D0
.1627a5	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1627a9	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.1627ac					    AY_R15
.1627ac	c2 20		rep #$20	                REP #$20        ; set A long
.1627ae	e6 84		inc $84		            INC CURRENT_POSITION
.1627b0	d0 02		bne $1627b4	            BNE increment_done
.1627b2	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627b4					    increment_done
.1627b4	e2 20		sep #$20	                SEP #$20        ; set A short
.1627b6	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.1627b9					WRITE_YM_CMD
.1627b9	a5 7f		lda $7f		            LDA COMMAND
.1627bb	c9 50		cmp #$50	            CMP #$50
.1627bd	d0 13		bne $1627d2	            BNE CHK_YM2413
.1627bf	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627c1	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1627c5	c2 20		rep #$20	                REP #$20        ; set A long
.1627c7	e6 84		inc $84		            INC CURRENT_POSITION
.1627c9	d0 02		bne $1627cd	            BNE increment_done
.1627cb	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627cd					    increment_done
.1627cd	e2 20		sep #$20	                SEP #$20        ; set A short
.1627cf	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE ; for some reason, this chip needs more time between writes
.1627d2					        CHK_YM2413
.1627d2	c9 51		cmp #$51	            CMP #$51
.1627d4	d0 23		bne $1627f9	            BNE CHK_YM2612_P0
.1627d6	a9 00		lda #$00	            LDA #0
.1627d8	eb		xba		            XBA
.1627d9	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627db	aa		tax		            TAX
.1627dc	c2 20		rep #$20	                REP #$20        ; set A long
.1627de	e6 84		inc $84		            INC CURRENT_POSITION
.1627e0	d0 02		bne $1627e4	            BNE increment_done
.1627e2	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627e4					    increment_done
.1627e4	e2 20		sep #$20	                SEP #$20        ; set A short
.1627e6	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627e8	9f 00 e6 af	sta $afe600,x	            STA @lOPL3_BASE_ADRESS,X
.1627ec	c2 20		rep #$20	                REP #$20        ; set A long
.1627ee	e6 84		inc $84		            INC CURRENT_POSITION
.1627f0	d0 02		bne $1627f4	            BNE increment_done
.1627f2	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627f4					    increment_done
.1627f4	e2 20		sep #$20	                SEP #$20        ; set A short
.1627f6	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.1627f9					        CHK_YM2612_P0
.1627f9	c9 52		cmp #$52	            CMP #$52
.1627fb	d0 23		bne $162820	            BNE CHK_YM2612_P1
.1627fd	a9 00		lda #$00	            LDA #0
.1627ff	eb		xba		            XBA
.162800	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162802	aa		tax		            TAX
.162803	c2 20		rep #$20	                REP #$20        ; set A long
.162805	e6 84		inc $84		            INC CURRENT_POSITION
.162807	d0 02		bne $16280b	            BNE increment_done
.162809	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16280b					    increment_done
.16280b	e2 20		sep #$20	                SEP #$20        ; set A short
.16280d	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16280f	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.162813	c2 20		rep #$20	                REP #$20        ; set A long
.162815	e6 84		inc $84		            INC CURRENT_POSITION
.162817	d0 02		bne $16281b	            BNE increment_done
.162819	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16281b					    increment_done
.16281b	e2 20		sep #$20	                SEP #$20        ; set A short
.16281d	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE ; for some reason, this chip needs more time between writes
.162820					        CHK_YM2612_P1
.162820	c9 53		cmp #$53	            CMP #$53
.162822	d0 23		bne $162847	            BNE CHK_YM2151
.162824	a9 00		lda #$00	            LDA #0
.162826	eb		xba		            XBA
.162827	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162829	aa		tax		            TAX
.16282a	c2 20		rep #$20	                REP #$20        ; set A long
.16282c	e6 84		inc $84		            INC CURRENT_POSITION
.16282e	d0 02		bne $162832	            BNE increment_done
.162830	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162832					    increment_done
.162832	e2 20		sep #$20	                SEP #$20        ; set A short
.162834	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162836	9f 00 f3 af	sta $aff300,x	            STA @lOPN2_BASE_ADDRESS + $100,X
.16283a	c2 20		rep #$20	                REP #$20        ; set A long
.16283c	e6 84		inc $84		            INC CURRENT_POSITION
.16283e	d0 02		bne $162842	            BNE increment_done
.162840	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162842					    increment_done
.162842	e2 20		sep #$20	                SEP #$20        ; set A short
.162844	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE ; for some reason, this chip needs more time between writes
.162847					        CHK_YM2151
.162847	c9 54		cmp #$54	            CMP #$54
.162849	d0 23		bne $16286e	            BNE CHK_YM2203
.16284b	a9 00		lda #$00	            LDA #0
.16284d	eb		xba		            XBA
.16284e	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162850	aa		tax		            TAX
.162851	c2 20		rep #$20	                REP #$20        ; set A long
.162853	e6 84		inc $84		            INC CURRENT_POSITION
.162855	d0 02		bne $162859	            BNE increment_done
.162857	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162859					    increment_done
.162859	e2 20		sep #$20	                SEP #$20        ; set A short
.16285b	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16285d	9f 00 f0 af	sta $aff000,x	            STA @lOPM_BASE_ADDRESS,X
.162861	c2 20		rep #$20	                REP #$20        ; set A long
.162863	e6 84		inc $84		            INC CURRENT_POSITION
.162865	d0 02		bne $162869	            BNE increment_done
.162867	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162869					    increment_done
.162869	e2 20		sep #$20	                SEP #$20        ; set A short
.16286b	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.16286e					        CHK_YM2203
.16286e	c9 55		cmp #$55	            CMP #$55
.162870	d0 1f		bne $162891	            BNE CHK_YM2608_P0
.162872	a9 00		lda #$00	            LDA #0
.162874	eb		xba		            XBA
.162875	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162877	aa		tax		            TAX
.162878	c2 20		rep #$20	                REP #$20        ; set A long
.16287a	e6 84		inc $84		            INC CURRENT_POSITION
.16287c	d0 02		bne $162880	            BNE increment_done
.16287e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162880					    increment_done
.162880	e2 20		sep #$20	                SEP #$20        ; set A short
.162882	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162884	c2 20		rep #$20	                REP #$20        ; set A long
.162886	e6 84		inc $84		            INC CURRENT_POSITION
.162888	d0 02		bne $16288c	            BNE increment_done
.16288a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16288c					    increment_done
.16288c	e2 20		sep #$20	                SEP #$20        ; set A short
.16288e	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162891					        CHK_YM2608_P0
.162891	c9 56		cmp #$56	            CMP #$56
.162893	d0 2a		bne $1628bf	            BNE CHK_YM2608_P1
.162895	a9 00		lda #$00	            LDA #0
.162897	eb		xba		            XBA
.162898	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16289a	c9 10		cmp #$10	            CMP #$10  ; if the register is 0 to $1F, process as SSG
.16289c	b0 03		bcs $1628a1	            BGE YM2608_FM
.16289e	4c 07 26	jmp $162607	            JMP AY8910
.1628a1					        YM2608_FM
.1628a1	aa		tax		            TAX
.1628a2	c2 20		rep #$20	                REP #$20        ; set A long
.1628a4	e6 84		inc $84		            INC CURRENT_POSITION
.1628a6	d0 02		bne $1628aa	            BNE increment_done
.1628a8	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628aa					    increment_done
.1628aa	e2 20		sep #$20	                SEP #$20        ; set A short
.1628ac	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628ae	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.1628b2	c2 20		rep #$20	                REP #$20        ; set A long
.1628b4	e6 84		inc $84		            INC CURRENT_POSITION
.1628b6	d0 02		bne $1628ba	            BNE increment_done
.1628b8	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628ba					    increment_done
.1628ba	e2 20		sep #$20	                SEP #$20        ; set A short
.1628bc	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.1628bf					        CHK_YM2608_P1
.1628bf	c9 57		cmp #$57	            CMP #$57
.1628c1	d0 23		bne $1628e6	            BNE CHK_YM2610_P0
.1628c3	a9 00		lda #$00	            LDA #0
.1628c5	eb		xba		            XBA
.1628c6	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628c8	aa		tax		            TAX
.1628c9	c2 20		rep #$20	                REP #$20        ; set A long
.1628cb	e6 84		inc $84		            INC CURRENT_POSITION
.1628cd	d0 02		bne $1628d1	            BNE increment_done
.1628cf	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628d1					    increment_done
.1628d1	e2 20		sep #$20	                SEP #$20        ; set A short
.1628d3	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628d5	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.1628d9	c2 20		rep #$20	                REP #$20        ; set A long
.1628db	e6 84		inc $84		            INC CURRENT_POSITION
.1628dd	d0 02		bne $1628e1	            BNE increment_done
.1628df	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628e1					    increment_done
.1628e1	e2 20		sep #$20	                SEP #$20        ; set A short
.1628e3	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.1628e6					        CHK_YM2610_P0
.1628e6	c9 58		cmp #$58	            CMP #$58
.1628e8	d0 2a		bne $162914	            BNE CHK_YM2610_P1
.1628ea	a9 00		lda #$00	            LDA #0
.1628ec	eb		xba		            XBA
.1628ed	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628ef	c9 10		cmp #$10	            CMP #$10  ; if the register is 0 to $1F, process as SSG
.1628f1	b0 03		bcs $1628f6	            BGE YM2610_FM
.1628f3	4c 07 26	jmp $162607	            JMP AY8910
.1628f6					        YM2610_FM
.1628f6	aa		tax		            TAX
.1628f7	c2 20		rep #$20	                REP #$20        ; set A long
.1628f9	e6 84		inc $84		            INC CURRENT_POSITION
.1628fb	d0 02		bne $1628ff	            BNE increment_done
.1628fd	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628ff					    increment_done
.1628ff	e2 20		sep #$20	                SEP #$20        ; set A short
.162901	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162903	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.162907	c2 20		rep #$20	                REP #$20        ; set A long
.162909	e6 84		inc $84		            INC CURRENT_POSITION
.16290b	d0 02		bne $16290f	            BNE increment_done
.16290d	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16290f					    increment_done
.16290f	e2 20		sep #$20	                SEP #$20        ; set A short
.162911	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162914					        CHK_YM2610_P1
.162914	c9 59		cmp #$59	            CMP #$59
.162916	d0 23		bne $16293b	            BNE CHK_YM3812
.162918	a9 00		lda #$00	            LDA #0
.16291a	eb		xba		            XBA
.16291b	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16291d	aa		tax		            TAX
.16291e	c2 20		rep #$20	                REP #$20        ; set A long
.162920	e6 84		inc $84		            INC CURRENT_POSITION
.162922	d0 02		bne $162926	            BNE increment_done
.162924	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162926					    increment_done
.162926	e2 20		sep #$20	                SEP #$20        ; set A short
.162928	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16292a	9f 00 f3 af	sta $aff300,x	            STA @lOPN2_BASE_ADDRESS + $100,X
.16292e	c2 20		rep #$20	                REP #$20        ; set A long
.162930	e6 84		inc $84		            INC CURRENT_POSITION
.162932	d0 02		bne $162936	            BNE increment_done
.162934	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162936					    increment_done
.162936	e2 20		sep #$20	                SEP #$20        ; set A short
.162938	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.16293b					        CHK_YM3812
.16293b	c9 5a		cmp #$5a	            CMP #$5A
.16293d	d0 23		bne $162962	            BNE CHK_YM262_P0
.16293f	a9 00		lda #$00	            LDA #0
.162941	eb		xba		            XBA
.162942	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162944	aa		tax		            TAX
.162945	c2 20		rep #$20	                REP #$20        ; set A long
.162947	e6 84		inc $84		            INC CURRENT_POSITION
.162949	d0 02		bne $16294d	            BNE increment_done
.16294b	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16294d					    increment_done
.16294d	e2 20		sep #$20	                SEP #$20        ; set A short
.16294f	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162951	9f 00 e6 af	sta $afe600,x	            STA @lOPL3_BASE_ADRESS,X
.162955	c2 20		rep #$20	                REP #$20        ; set A long
.162957	e6 84		inc $84		            INC CURRENT_POSITION
.162959	d0 02		bne $16295d	            BNE increment_done
.16295b	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16295d					    increment_done
.16295d	e2 20		sep #$20	                SEP #$20        ; set A short
.16295f	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162962					        CHK_YM262_P0
.162962	c9 5e		cmp #$5e	            CMP #$5E
.162964	d0 23		bne $162989	            BNE CHK_YM262_P1
.162966	a9 00		lda #$00	            LDA #0
.162968	eb		xba		            XBA
.162969	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16296b	aa		tax		            TAX
.16296c	c2 20		rep #$20	                REP #$20        ; set A long
.16296e	e6 84		inc $84		            INC CURRENT_POSITION
.162970	d0 02		bne $162974	            BNE increment_done
.162972	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162974					    increment_done
.162974	e2 20		sep #$20	                SEP #$20        ; set A short
.162976	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162978	9f 00 e6 af	sta $afe600,x	            STA @lOPL3_BASE_ADRESS,X
.16297c	c2 20		rep #$20	                REP #$20        ; set A long
.16297e	e6 84		inc $84		            INC CURRENT_POSITION
.162980	d0 02		bne $162984	            BNE increment_done
.162982	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162984					    increment_done
.162984	e2 20		sep #$20	                SEP #$20        ; set A short
.162986	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162989					        CHK_YM262_P1
.162989	c9 5f		cmp #$5f	            CMP #$5F
.16298b	d0 20		bne $1629ad	            BNE YM_DONE
.16298d	a9 00		lda #$00	            LDA #0
.16298f	eb		xba		            XBA
.162990	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162992	aa		tax		            TAX
.162993	c2 20		rep #$20	                REP #$20        ; set A long
.162995	e6 84		inc $84		            INC CURRENT_POSITION
.162997	d0 02		bne $16299b	            BNE increment_done
.162999	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16299b					    increment_done
.16299b	e2 20		sep #$20	                SEP #$20        ; set A short
.16299d	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16299f	9f 00 e7 af	sta $afe700,x	            STA @lOPL3_BASE_ADRESS+ $100,X
.1629a3	c2 20		rep #$20	                REP #$20        ; set A long
.1629a5	e6 84		inc $84		            INC CURRENT_POSITION
.1629a7	d0 02		bne $1629ab	            BNE increment_done
.1629a9	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629ab					    increment_done
.1629ab	e2 20		sep #$20	                SEP #$20        ; set A short
.1629ad					    YM_DONE
.1629ad	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.1629b0					WAIT_COMMANDS
.1629b0	a5 7f		lda $7f		            LDA COMMAND
.1629b2	c9 61		cmp #$61	            CMP #$61
.1629b4	d0 20		bne $1629d6	            BNE CHK_WAIT_60th
.1629b6	c2 20		rep #$20	                REP #$20        ; set A long
.1629b8	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1629ba	aa		tax		            TAX
.1629bb	86 88		stx $88		            STX WAIT_CNTR
.1629bd	e2 20		sep #$20	                SEP #$20        ; set A short
.1629bf	c2 20		rep #$20	                REP #$20        ; set A long
.1629c1	e6 84		inc $84		            INC CURRENT_POSITION
.1629c3	d0 02		bne $1629c7	            BNE increment_done
.1629c5	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629c7					    increment_done
.1629c7	e2 20		sep #$20	                SEP #$20        ; set A short
.1629c9	c2 20		rep #$20	                REP #$20        ; set A long
.1629cb	e6 84		inc $84		            INC CURRENT_POSITION
.1629cd	d0 02		bne $1629d1	            BNE increment_done
.1629cf	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629d1					    increment_done
.1629d1	e2 20		sep #$20	                SEP #$20        ; set A short
.1629d3	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE
.1629d6					        CHK_WAIT_60th
.1629d6	c9 62		cmp #$62	            CMP #$62
.1629d8	d0 08		bne $1629e2	            BNE CHK_WAIT_50th
.1629da	a2 df 02	ldx #$02df	            LDX #$2df
.1629dd	86 88		stx $88		            STX WAIT_CNTR
.1629df	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE
.1629e2					        CHK_WAIT_50th
.1629e2	c9 63		cmp #$63	            CMP #$63
.1629e4	d0 08		bne $1629ee	            BNE CHK_END_SONG
.1629e6	a2 72 03	ldx #$0372	            LDX #$372
.1629e9	86 88		stx $88		            STX WAIT_CNTR
.1629eb	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE
.1629ee					        CHK_END_SONG
.1629ee	c9 66		cmp #$66	            CMP #$66 ; end of song
.1629f0	d0 06		bne $1629f8	            BNE CHK_DATA_BLOCK
.1629f2	20 91 2a	jsr $162a91	            JSR VGM_SET_LOOP_POINTERS
.1629f5	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE
.1629f8					        CHK_DATA_BLOCK
.1629f8	c9 67		cmp #$67	            CMP #$67
.1629fa	d0 03		bne $1629ff	            BNE DONE_WAIT
.1629fc	20 31 2b	jsr $162b31	            JSR READ_DATA_BLOCK
.1629ff					    DONE_WAIT
.1629ff	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE
.162a02					WAIT_N_1
.162a02	a9 00		lda #$00	            LDA #0
.162a04	eb		xba		            XBA
.162a05	a5 7f		lda $7f		            LDA COMMAND
.162a07	29 0f		and #$0f	            AND #$F
.162a09	aa		tax		            TAX
.162a0a	e8		inx		            INX ; $7n where we wait n+1
.162a0b	86 88		stx $88		            STX WAIT_CNTR
.162a0d	4c 02 25	jmp $162502	            JMP VGM_LOOP_DONE
.162a10					YM2612_SAMPLE
.162a10	a7 8a		lda [$8a]	            LDA [PCM_OFFSET]
.162a12	8f 2a f2 af	sta $aff22a	            STA OPN2_BASE_ADDRESS + $2A
.162a16	c2 20		rep #$20	                REP #$20        ; set A long
.162a18	a5 8a		lda $8a		            LDA PCM_OFFSET
.162a1a	1a		inc a		            INC A
.162a1b	85 8a		sta $8a		            STA PCM_OFFSET
.162a1d	90 05		bcc $162a24	            BCC YMS_WAIT
.162a1f	a5 8c		lda $8c		            LDA PCM_OFFSET + 2
.162a21	1a		inc a		            INC A
.162a22	85 8c		sta $8c		            STA PCM_OFFSET + 2
.162a24					    YMS_WAIT
.162a24	e2 20		sep #$20	                SEP #$20        ; set A short
.162a26	a9 00		lda #$00	            LDA #0
.162a28	eb		xba		            XBA
.162a29	a5 7f		lda $7f		            LDA COMMAND
.162a2b	29 0f		and #$0f	            AND #$F
.162a2d	aa		tax		            TAX
.162a2e	86 88		stx $88		            STX WAIT_CNTR
.162a30					    YMS_NOT_ZERO
.162a30	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162a33					DAC_STREAM
.162a33	4c dd 24	jmp $1624dd	            JMP VGM_WRITE_REGISTER
.162a36					VGM_SET_SONG_POINTERS
.162a36	c2 20		rep #$20	                REP #$20        ; set A long
.162a38	a9 83 22	lda #$2283	            LDA #<>RESET_MSG
.162a3b	85 7a		sta $7a		            STA MSG_PTR
.162a3d	e2 20		sep #$20	                SEP #$20        ; set A short
.162a3f	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.162a42	c2 20		rep #$20	                REP #$20        ; set A long
.162a44	a9 00 00	lda #$0000	            LDA #0
.162a47	85 88		sta $88		            STA WAIT_CNTR
.162a49	a5 82		lda $82		            LDA SONG_START + 2
.162a4b	85 86		sta $86		            STA CURRENT_POSITION + 2
.162a4d	e2 20		sep #$20	                SEP #$20        ; set A short
.162a4f	a5 77		lda $77		            LDA MIN_VERSION
.162a51	c9 50		cmp #$50	            CMP #$50
.162a53	90 2b		bcc $162a80	            BLT OLD_VERSION
.162a55	c2 20		rep #$20	                REP #$20        ; set A long
.162a57	18		clc		            CLC
.162a58	a0 34 00	ldy #$0034	            LDY #VGM_OFFSET
.162a5b	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162a5d	69 34 00	adc #$0034	            ADC #VGM_OFFSET
.162a60	65 80		adc $80		            ADC SONG_START
.162a62	85 84		sta $84		            STA CURRENT_POSITION
.162a64	90 02		bcc $162a68	            BCC VSP_DONE
.162a66	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162a68					    VSP_DONE
.162a68	18		clc		            CLC
.162a69	a0 14 00	ldy #$0014	            LDY #GD3_OFFSET
.162a6c	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162a6e	69 14 00	adc #$0014	            ADC #GD3_OFFSET
.162a71	65 80		adc $80		            ADC SONG_START
.162a73	85 8e		sta $8e		            STA GD3_POSITION
.162a75	c8		iny		            INY
.162a76	c8		iny		            INY
.162a77	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162a79	65 82		adc $82		            ADC SONG_START + 2
.162a7b	85 90		sta $90		            STA GD3_POSITION + 2
.162a7d	e2 20		sep #$20	                SEP #$20        ; set A short
.162a7f	60		rts		            RTS
.162a80					    OLD_VERSION
.162a80	c2 20		rep #$20	                REP #$20        ; set A long
.162a82	18		clc		            CLC
.162a83	a9 40 00	lda #$0040	            LDA #$40
.162a86	65 80		adc $80		            ADC SONG_START
.162a88	85 84		sta $84		            STA CURRENT_POSITION
.162a8a	90 02		bcc $162a8e	            BCC VSP_OLD_DONE
.162a8c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162a8e					    VSP_OLD_DONE
.162a8e	e2 20		sep #$20	                SEP #$20        ; set A short
.162a90	60		rts		            RTS
.162a91					VGM_SET_LOOP_POINTERS
.162a91	0b		phd		            PHD
.162a92	8b		phb		            PHB
.162a93	a9 00		lda #$00	            LDA #0
.162a95	48		pha		            PHA
.162a96	ab		plb		            PLB
.162a97	c2 20		rep #$20	                REP #$20        ; set A long
.162a99	a9 00 00	lda #$0000	            LDA #0
.162a9c	5b		tcd		            TCD  ; reset the direct page.
.162a9d	85 88		sta $88		            STA WAIT_CNTR
.162a9f	18		clc		            CLC
.162aa0	a0 1c 00	ldy #$001c	            LDY #LOOP_OFFSET
.162aa3	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162aa5	f0 2f		beq $162ad6	            BEQ NO_LOOP_INFO ; if this is zero, assume that the upper word is also 0
.162aa7	69 1c 00	adc #$001c	            ADC #LOOP_OFFSET ; add the current position
.162aaa	8d 20 01	sta $0120	            STA ADDER_A
.162aad	c8		iny		            INY
.162aae	c8		iny		            INY
.162aaf	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162ab1	8d 22 01	sta $0122	            STA ADDER_A + 2
.162ab4	a9 94 22	lda #$2294	            LDA #<>LOOPING_MSG
.162ab7	85 7a		sta $7a		            STA MSG_PTR
.162ab9	e2 20		sep #$20	                SEP #$20        ; set A short
.162abb	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.162abe	c2 20		rep #$20	                REP #$20        ; set A long
.162ac0	a5 80		lda $80		            LDA SONG_START
.162ac2	8d 24 01	sta $0124	            STA ADDER_B
.162ac5	a5 82		lda $82		            LDA SONG_START + 2
.162ac7	8d 26 01	sta $0126	            STA ADDER_B + 2
.162aca	ad 28 01	lda $0128	            LDA ADDER_R
.162acd	85 84		sta $84		            STA CURRENT_POSITION
.162acf	ad 2a 01	lda $012a	            LDA ADDER_R + 2
.162ad2	85 86		sta $86		            STA CURRENT_POSITION + 2
.162ad4	80 20		bra $162af6	            BRA VSL_DONE
.162ad6					    NO_LOOP_INFO
.162ad6	a9 83 22	lda #$2283	            LDA #<>RESET_MSG
.162ad9	85 7a		sta $7a		            STA MSG_PTR
.162adb	e2 20		sep #$20	                SEP #$20        ; set A short
.162add	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.162ae0	c2 20		rep #$20	                REP #$20        ; set A long
.162ae2	a0 34 00	ldy #$0034	            LDY #VGM_OFFSET
.162ae5	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162ae7	69 34 00	adc #$0034	            ADC #VGM_OFFSET
.162aea	65 80		adc $80		            ADC SONG_START
.162aec	85 84		sta $84		            STA CURRENT_POSITION
.162aee	a5 82		lda $82		            LDA SONG_START + 2
.162af0	85 86		sta $86		            STA CURRENT_POSITION + 2
.162af2	90 02		bcc $162af6	            BCC VSL_DONE
.162af4	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162af6					    VSL_DONE
.162af6	e2 20		sep #$20	                SEP #$20        ; set A short
.162af8	ab		plb		            PLB
.162af9	2b		pld		            PLD
.162afa	60		rts		            RTS
.162afb					VGM_INIT_TIMER0
.162afb	c2 20		rep #$20	                REP #$20        ; set A long
.162afd	a9 dd 24	lda #$24dd	            LDA #<>VGM_WRITE_REGISTER
.162b00	8f 3d 11 38	sta $38113d	            STA TIMER0INTSUB + 1
.162b04	e2 20		sep #$20	                SEP #$20        ; set A short
.162b06	a9 16		lda #$16	            LDA #`VGM_WRITE_REGISTER
.162b08	8f 3f 11 38	sta $38113f	            STA TIMER0INTSUB + 3
.162b0c	a9 30		lda #$30	            LDA #$30
.162b0e	8d 65 01	sta $0165	            STA TIMER0_CMP_L
.162b11	a9 01		lda #$01	            LDA #1
.162b13	8d 66 01	sta $0166	            STA TIMER0_CMP_M
.162b16	a9 00		lda #$00	            LDA #0
.162b18	8d 67 01	sta $0167	            STA TIMER0_CMP_H
.162b1b	a9 00		lda #$00	            LDA #0    ; set timer0 charge to 0
.162b1d	8d 61 01	sta $0161	            STA TIMER0_CHARGE_L
.162b20	8d 62 01	sta $0162	            STA TIMER0_CHARGE_M
.162b23	8d 63 01	sta $0163	            STA TIMER0_CHARGE_H
.162b26	a9 01		lda #$01	            LDA #TMR0_CMP_RECLR  ; count up from "CHARGE" value to TIMER_CMP
.162b28	8d 64 01	sta $0164	            STA TIMER0_CMP_REG
.162b2b	a9 0b		lda #$0b	            LDA #(TMR0_EN | TMR0_UPDWN | TMR0_SCLR)
.162b2d	8d 60 01	sta $0160	            STA TIMER0_CTRL_REG
.162b30	60		rts		            RTS
.162b31					READ_DATA_BLOCK
.162b31	c2 20		rep #$20	                REP #$20        ; set A long
.162b33	a9 a2 22	lda #$22a2	            LDA #<>DATA_BLOCK_MSG
.162b36	85 7a		sta $7a		            STA MSG_PTR
.162b38	e2 20		sep #$20	                SEP #$20        ; set A short
.162b3a	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.162b3d	a7 84		lda [$84]	            LDA [CURRENT_POSITION] ; should be 66
.162b3f	c2 20		rep #$20	                REP #$20        ; set A long
.162b41	e6 84		inc $84		            INC CURRENT_POSITION
.162b43	d0 02		bne $162b47	            BNE increment_done
.162b45	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b47					    increment_done
.162b47	e2 20		sep #$20	                SEP #$20        ; set A short
.162b49	a7 84		lda [$84]	            LDA  [CURRENT_POSITION] ; should be the type - I expect $C0
.162b4b	48		pha		            PHA
.162b4c	c2 20		rep #$20	                REP #$20        ; set A long
.162b4e	e6 84		inc $84		            INC CURRENT_POSITION
.162b50	d0 02		bne $162b54	            BNE increment_done
.162b52	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b54					    increment_done
.162b54	e2 20		sep #$20	                SEP #$20        ; set A short
.162b56	c2 20		rep #$20	                REP #$20        ; set A long
.162b58	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162b5a	8d 20 01	sta $0120	            STA ADDER_A
.162b5d	c2 20		rep #$20	                REP #$20        ; set A long
.162b5f	e6 84		inc $84		            INC CURRENT_POSITION
.162b61	d0 02		bne $162b65	            BNE increment_done
.162b63	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b65					    increment_done
.162b65	e2 20		sep #$20	                SEP #$20        ; set A short
.162b67	c2 20		rep #$20	                REP #$20        ; set A long
.162b69	e6 84		inc $84		            INC CURRENT_POSITION
.162b6b	d0 02		bne $162b6f	            BNE increment_done
.162b6d	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b6f					    increment_done
.162b6f	e2 20		sep #$20	                SEP #$20        ; set A short
.162b71	c2 20		rep #$20	                REP #$20        ; set A long
.162b73	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162b75	8d 22 01	sta $0122	            STA ADDER_A + 2
.162b78	c2 20		rep #$20	                REP #$20        ; set A long
.162b7a	e6 84		inc $84		            INC CURRENT_POSITION
.162b7c	d0 02		bne $162b80	            BNE increment_done
.162b7e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b80					    increment_done
.162b80	e2 20		sep #$20	                SEP #$20        ; set A short
.162b82	c2 20		rep #$20	                REP #$20        ; set A long
.162b84	e6 84		inc $84		            INC CURRENT_POSITION
.162b86	d0 02		bne $162b8a	            BNE increment_done
.162b88	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b8a					    increment_done
.162b8a	e2 20		sep #$20	                SEP #$20        ; set A short
.162b8c	c2 20		rep #$20	                REP #$20        ; set A long
.162b8e	a5 84		lda $84		            LDA CURRENT_POSITION
.162b90	8d 24 01	sta $0124	            STA ADDER_B
.162b93	a5 86		lda $86		            LDA CURRENT_POSITION + 2
.162b95	8d 26 01	sta $0126	            STA ADDER_B + 2
.162b98	ad 28 01	lda $0128	            LDA ADDER_R
.162b9b	85 84		sta $84		            STA CURRENT_POSITION
.162b9d	ad 2a 01	lda $012a	            LDA ADDER_R + 2
.162ba0	85 86		sta $86		            STA CURRENT_POSITION + 2
.162ba2	e2 20		sep #$20	                SEP #$20        ; set A short
.162ba4	68		pla		            PLA
.162ba5	f0 04		beq $162bab	            BEQ UNCOMPRESSED
.162ba7	c9 c0		cmp #$c0	            CMP #$C0
.162ba9	d0 17		bne $162bc2	            BNE UNKNOWN_DATA_BLOCK
.162bab					    UNCOMPRESSED
.162bab	c2 20		rep #$20	                REP #$20        ; set A long
.162bad	a5 7d		lda $7d		            LDA DATA_STREAM_CNT ; multiply by 4
.162baf	0a		asl a		            ASL A
.162bb0	0a		asl a		            ASL A
.162bb1	aa		tax		            TAX
.162bb2	ad 24 01	lda $0124	            LDA ADDER_B
.162bb5	9d 00 80	sta $8000,x	            STA DATA_STREAM_TBL,X
.162bb8	ad 26 01	lda $0126	            LDA ADDER_B + 2
.162bbb	9d 02 80	sta $8002,x	            STA DATA_STREAM_TBL,X + 2
.162bbe	e6 7d		inc $7d		            INC DATA_STREAM_CNT
.162bc0	e2 20		sep #$20	                SEP #$20        ; set A short
.162bc2					    UNKNOWN_DATA_BLOCK
.162bc2	60		rts		            RTS
.162bc3					VGM_DISPLAY_GD3
.162bc3	a0 00 00	ldy #$0000	            LDY #0
.162bc6	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bc8	c9 47		cmp #$47	            CMP #'G'
.162bca	d0 43		bne $162c0f	            BNE GD3_ERROR
.162bcc	c8		iny		            INY
.162bcd	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bcf	c9 64		cmp #$64	            CMP #'d'
.162bd1	d0 3c		bne $162c0f	            BNE GD3_ERROR
.162bd3	c8		iny		            INY
.162bd4	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bd6	c9 33		cmp #$33	            CMP #'3'
.162bd8	d0 35		bne $162c0f	            BNE GD3_ERROR
.162bda	c8		iny		            INY
.162bdb	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bdd	c9 20		cmp #$20	            CMP #' '
.162bdf	d0 2e		bne $162c0f	            BNE GD3_ERROR
.162be1	c8		iny		            INY
.162be2	c2 20		rep #$20	                REP #$20        ; set A long
.162be4	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162be6	c9 00 01	cmp #$0100	            CMP #$100
.162be9	d0 24		bne $162c0f	            BNE GD3_ERROR
.162beb	c8		iny		            INY
.162bec	c8		iny		            INY
.162bed	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bef	d0 1e		bne $162c0f	            BNE GD3_ERROR
.162bf1	e2 20		sep #$20	                SEP #$20        ; set A short
.162bf3	c8		iny		            INY
.162bf4	c8		iny		            INY
.162bf5	c8		iny		            INY  ; skip the length
.162bf6	c8		iny		            INY
.162bf7	c8		iny		            INY
.162bf8	c8		iny		            INY
.162bf9	20 1a 2c	jsr $162c1a	            JSR DISPLAY_MSG_16  ; display the track name in English
.162bfc	20 43 2c	jsr $162c43	            JSR DISCARD_16      ; discard the track name in Japanese
.162bff	20 43 2c	jsr $162c43	            JSR DISCARD_16      ; discard the game name in English
.162c02	20 43 2c	jsr $162c43	            JSR DISCARD_16      ; discard the game name in Japanese
.162c05	20 43 2c	jsr $162c43	            JSR DISCARD_16      ; discard the system name in English
.162c08	20 43 2c	jsr $162c43	            JSR DISCARD_16      ; discard the system name in Japanese
.162c0b	20 1a 2c	jsr $162c1a	            JSR DISPLAY_MSG_16  ; display the author's name in English
.162c0e	60		rts		            RTS
.162c0f					GD3_ERROR
.162c0f	e2 20		sep #$20	                SEP #$20        ; set A short
.162c11	a2 39 23	ldx #$2339	            LDX #<>GD3_ERR_MSG
.162c14	86 7a		stx $7a		            STX MSG_PTR
.162c16	20 6d 24	jsr $16246d	            JSR DISPLAY_MSG
.162c19	60		rts		            RTS
.162c1a					DISPLAY_MSG_16
.162c1a	a6 78		ldx $78		            LDX DISPLAY_OFFSET
.162c1c					    DM16_LOOP
.162c1c	e2 20		sep #$20	                SEP #$20        ; set A short
.162c1e	a9 2d		lda #$2d	            LDA #$2D   ; Text color
.162c20	9f 00 20 af	sta $af2000,x	            STA $AF2000,X  ; offset to Text LUT $AF:C000
.162c24	c2 20		rep #$20	                REP #$20        ; set A long
.162c26	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c28	e2 20		sep #$20	                SEP #$20        ; set A short
.162c2a	9f 00 00 af	sta $af0000,x	            STA $AF0000,X  ; offset to Text LUT $AF:C000
.162c2e	c8		iny		            INY
.162c2f	c8		iny		            INY
.162c30	e8		inx		            INX
.162c31	c2 20		rep #$20	                REP #$20        ; set A long
.162c33	c9 00 00	cmp #$0000	            CMP #0
.162c36	d0 e4		bne $162c1c	            BNE DM16_LOOP
.162c38	a5 78		lda $78		            LDA DISPLAY_OFFSET
.162c3a	18		clc		            CLC
.162c3b	69 50 00	adc #$0050	            ADC #80 ; 80 columns in 640x480 mode
.162c3e	85 78		sta $78		            STA DISPLAY_OFFSET
.162c40	e2 20		sep #$20	                SEP #$20        ; set A short
.162c42	60		rts		            RTS
.162c43					DISCARD_16
.162c43	c2 20		rep #$20	                REP #$20        ; set A long
.162c45					    DIS_LOOP
.162c45	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c47	c8		iny		            INY
.162c48	c8		iny		            INY
.162c49	c9 00 00	cmp #$0000	            CMP #0
.162c4c	d0 f7		bne $162c45	            BNE DIS_LOOP
.162c4e	e2 20		sep #$20	                SEP #$20        ; set A short
.162c50	60		rts		            RTS

;******  End of listing
