
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass.exe --long-address -x --intel-hex -o vgm-player.hex --list vgm-player.lst vgm-player.asm
; Sat Jan 01 14:31:18 2022

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: vgm-player.asm


;******  Processing file: macros_inc.asm


;******  Return to file: vgm-player.asm


;******  Processing file: bank_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				TMPPTR1          = $000000 ; 4 byte temporary pointer
=$000004				TMPPTR2          = $000004 ; 4 byte temporary pointer
=$000008				OPL2_ADDY_PTR_LO = $000008 ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000250				MONITOR_VARS     = $000250 ; Byte  MONITOR Variables. BASIC variables may overlap this space
=$000250				MCMDADDR         = $000250 ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000253				MCMP_TEXT        = $000253 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000256				MCMP_LEN         = $000256 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000258				MCMD             = $000258 ;3 Bytes Address of the current command/function string
=$00025b				MCMD_LEN         = $00025B ;2 Bytes Length of the current command/function string
=$00025d				MARG1            = $00025D ;4 Bytes First command argument. May be data or address, depending on command
=$000261				MARG2            = $000261 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000265				MARG3            = $000265 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000269				MARG4            = $000269 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$00026d				MARG5            = $00026D ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000271				MARG6            = $000271 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000275				MARG7            = $000275 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000279				MARG8            = $000279 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032c				BIOS_FLAGS       = $00032C      ; 1 byte - Flags for various BIOSy things:
=$00032d				BIOS_TIMER       = $00032D      ; 1 byte - the number of 1/60 ticks for a time out
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$38ff00				ISR_BEGIN        = $38FF00 ; Byte  Beginning of CPU vectors in Direct page
=$38ff00				HRESET           = $38FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$38ff10				HCOP             = $38FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$38ff20				HBRK             = $38FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$38ff30				HABORT           = $38FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$38ff40				HNMI             = $38FF40 ;32 Bytes Handle NMI
=$38ff60				HIRQ             = $38FF60 ;32 Bytes Handle IRQ
=$38ff80				Unused_FF80      = $38FF80 ;End of direct page Interrrupt handlers
=$38ffe0				VECTORS_BEGIN    = $38FFE0 ;0 Byte  Interrupt vectors
=$38ffe0				JMP_READY        = $38FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$38ffe4				VECTOR_COP       = $38FFE4 ;2 Bytes Native COP Interrupt vector
=$38ffe6				VECTOR_BRK       = $38FFE6 ;2 Bytes Native BRK Interrupt vector
=$38ffe8				VECTOR_ABORT     = $38FFE8 ;2 Bytes Native ABORT Interrupt vector
=$38ffea				VECTOR_NMI       = $38FFEA ;2 Bytes Native NMI Interrupt vector
=$38ffec				VECTOR_RESET     = $38FFEC ;2 Bytes Unused (Native RESET vector)
=$38ffee				VECTOR_IRQ       = $38FFEE ;2 Bytes Native IRQ Vector
=$38fff0				RETURN           = $38FFF0 ;4 Bytes RETURN key handler. Points to BASIC or MONITOR subroutine to execute when RETURN is pressed.
=$38fff4				VECTOR_ECOP      = $38FFF4 ;2 Bytes Emulation mode interrupt handler
=$38fff6				VECTOR_EBRK      = $38FFF6 ;2 Bytes Emulation mode interrupt handler
=$38fff8				VECTOR_EABORT    = $38FFF8 ;2 Bytes Emulation mode interrupt handler
=$38fffa				VECTOR_ENMI      = $38FFFA ;2 Bytes Emulation mode interrupt handler
=$38fffc				VECTOR_ERESET    = $38FFFC ;2 Bytes Emulation mode interrupt handler
=$38fffe				VECTOR_EIRQ      = $38FFFE ;2 Bytes Emulation mode interrupt handler
=$400000				VECTORS_END      = $400000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: vgm-player.asm


;******  Processing file: vicky_ii_def.asm

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				VKY_RESERVED_00         = $AF0002
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$af8800				FONT_MEMORY_BANK1       = $AF8800     ;$AF8800 - $AF8FFF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000
=$afe000				BTX_START               = $AFE000     ; BEATRIX Registers
=$afffff				BTX_END                 = $AFFFFF

;******  Return to file: vgm-player.asm


;******  Processing file: kernel_inc.asm

=$001000				BOOT             = $001000 ; Cold boot routine
=$001004				RESTORE          = $001004 ; Warm boot routine
=$001008				BREAK            = $001008 ; End program and return to command prompt
=$00100c				READY            = $00100C ; Print prompt and wait for keyboard input
=$001010				SCINIT           = $001010 ;
=$001014				IOINIT           = $001014 ;
=$001018				PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				PUTS             = $00101C ; Print a string to the currently selected channel
=$001020				PUTB             = $001020 ; Output a byte to the currently selected channel
=$001024				PUTBLOCK         = $001024 ; Ouput a binary block to the currently selected channel
=$001028				GETSCANCODE      = $001028 ; Get the next scancode from the keyboard (A = scancode, 0 if none available)
=$00102c				GETLOCKS         = $00102C ; Get the state of the lock keys on the keyboard (A[2] = CAPS, A[1] = NUM, A[0] = SCROLL)
=$001030				OPEN             = $001030 ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
=$001034				CLOSE            = $001034 ; Close a channel
=$001038				SETIN            = $001038 ; Set the current input channel
=$00103c				SETOUT           = $00103C ; Set the current output channel
=$001040				GETB             = $001040 ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
=$001044				GETBLOCK         = $001044 ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
=$001048				GETCH            = $001048 ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
=$00104c				GETCHW           = $00104C ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001050				GETCHE           = $001050 ; Get a character from the input channel and echo to the screen. Wait if data is not ready.
=$001054				GETS             = $001054 ; Get a string from the input channel. NULL terminates
=$001058				GETLINE          = $001058 ; Get a line of text from input channel. CR or NULL terminates.
=$00105c				GETFIELD         = $00105C ; Get a field from the input channel. Value in A, CR, or NULL terminates
=$001060				TRIM             = $001060 ; Removes spaces at beginning and end of string.
=$001064				PRINTC           = $001064 ; Print character to screen. Handles terminal commands
=$001068				PRINTS           = $001068 ; Print string to screen. Handles terminal commands
=$00106c				PRINTCR          = $00106C ; Print Carriage Return
=$001070				PRINTF           = $001070 ; Print a float value
=$001074				PRINTI           = $001074 ; Prints integer value in TEMP
=$001078				PRINTH           = $001078 ; Print Hex value in DP variable
=$00107c				PRINTAI          = $00107C ; Prints integer value in A
=$001080				PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				LOCATE           = $001084 ;
=$001088				PUSHKEY          = $001088 ;
=$00108c				PUSHKEYS         = $00108C ;
=$001090				CSRRIGHT         = $001090 ;
=$001094				CSRLEFT          = $001094 ;
=$001098				CSRUP            = $001098 ;
=$00109c				CSRDOWN          = $00109C ;
=$0010a0				CSRHOME          = $0010A0 ;
=$0010a4				SCROLLUP         = $0010A4 ; Scroll the screen up one line. Creates an empty line at the bottom.
=$0010a8				CLRSCREEN        = $0010A8 ; Clear the screen
=$0010ac				INITCHLUT        = $0010AC ; Init character look-up table
=$0010b0				INITSUPERIO      = $0010B0 ; Init Super-IO chip
=$0010b4				INITKEYBOARD     = $0010B4 ; Init keyboard
=$0010bc				INITCURSOR       = $0010BC ; Init the Cursors registers
=$0010c0				INITFONTSET      = $0010C0 ; Init the Internal FONT Memory
=$0010c4				INITGAMMATABLE   = $0010C4 ; Init the RGB GAMMA Look Up Table
=$0010c8				INITALLLUT       = $0010C8 ; Init the Graphic Engine (Bitmap/Tile/Sprites) LUT
=$0010cc				INITVKYTXTMODE   = $0010CC ; Init the Text Mode @ Reset Time
=$0010d0				INITVKYGRPMODE   = $0010D0 ; Init the Basic Registers for the Graphic Mode
=$00112c				SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$0010f0				F_OPEN           = $0010F0 ; open a file for reading/writing/creating
=$0010f4				F_CREATE         = $0010F4 ; create a new file
=$0010f8				F_CLOSE          = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				F_WRITE          = $0010FC ; write the current cluster to the file
=$001100				F_READ           = $001100 ; read the next cluster from the file
=$001104				F_DELETE         = $001104 ; delete a file / directory
=$001108				F_DIROPEN        = $001108 ; open a directory and seek the first directory entry
=$00110c				F_DIRNEXT        = $00110C ; seek to the next directory of an open directory
=$001110				F_DIRREAD        = $001110 ; Read the directory entry for the specified file
=$001114				F_DIRWRITE       = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				F_LOAD           = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				F_SAVE           = $00111C ; Save memory to a binary file
=$001120				CMDBLOCK         = $001120 ; Send a command to a block device
=$001124				F_RUN            = $001124 ; Load and run an executable binary file
=$001128				F_MOUNT          = $001128 ; Mount the designated block device
=$001130				F_COPY           = $001130 ; Copy a file
=$001134				F_ALLOCFD        = $001134 ; Allocate a file descriptor
=$001138				F_FREEFD         = $001138 ; Free a file descriptor
=$00113c				TESTBREAK        = $00113C ; Check if BREAK was pressed recently by the user (C is set if true, clear if false)
=$001140				SETTABLE         = $001140 ; Set the keyboard scan code -> character translation tables (B:X points to the new tables)
=$001144				READVRAM         = $001144 ; Read a byte from video RAM at B:X
=$001148				SETHANDLER       = $001148 ; Set the handler for the interrupt # in A to the FAR routine at Y:X
=$00114c				DELAY            = $00114C ; Wait at least Y:X ticks of the system clock.
=$001700				VEC_INT00_SOF       = $001700 ; IRQ 0, 0 --- Start Of Frame interrupt
=$001704				VEC_INT01_SOL       = $001704 ; IRQ 0, 1 --- Start Of Line interrupt
=$001708				VEC_INT02_TMR0      = $001708 ; IRQ 0, 2 --- Timer 0 interrupt
=$00170c				VEC_INT03_TMR1      = $00170C ; IRQ 0, 3 --- Timer 1 interrupt
=$001710				VEC_INT04_TMR2      = $001710 ; IRQ 0, 4 --- Timer 2 interrupt
=$001714				VEC_INT05_RTC       = $001714 ; IRQ 0, 5 --- Real Time Clock interrupt
=$001718				VEC_INT06_FDC       = $001718 ; IRQ 0, 6 --- Floppy Drive Controller interrupt
=$00171c				VEC_INT07_MOUSE     = $00171C ; IRQ 0, 7 --- Mouse interrupt
=$001720				VEC_INT10_KBD       = $001720 ; IRQ 1, 0 --- Keyboard interrupt
=$001724				VEC_INT11_COL0      = $001724 ; IRQ 1, 1 --- VICKY_II (INT2) Sprite Collision
=$001728				VEC_INT12_COL1      = $001728 ; IRQ 1, 2 --- VICKY_II (INT3) Bitmap Collision
=$00172c				VEC_INT13_COM2      = $00172C ; IRQ 1, 3 --- Serial port #2 interrupt
=$001730				VEC_INT14_COM1      = $001730 ; IRQ 1, 4 --- Serial port #1 interrupt
=$001734				VEC_INT15_MIDI      = $001734 ; IRQ 1, 5 --- MIDI controller interrupt
=$001738				VEC_INT16_LPT       = $001738 ; IRQ 1, 6 --- Parallel port interrupt
=$00173c				VEC_INT17_SDC       = $00173C ; IRQ 1, 7 --- SD Card Controller interrupt (CH376S???)
=$001740				VEC_INT20_OPL       = $001740 ; IRQ 2, 0 --- OPL3
=$001744				VEC_INT21_GABE0     = $001744 ; IRQ 2, 1 --- GABE (INT0) - TBD
=$001748				VEC_INT22_GABE1     = $001748 ; IRQ 2, 2 --- GABE (INT1) - TBD
=$00174c				VEC_INT23_VDMA      = $00174C ; IRQ 2, 3 --- VICKY_II (INT4) - VDMA Interrupt
=$001750				VEC_INT24_COL2      = $001750 ; IRQ 2, 4 --- VICKY_II (INT5) Tile Collision
=$001754				VEC_INT25_GABE2     = $001754 ; IRQ 2, 5 --- GABE (INT2) - TBD
=$001758				VEC_INT26_EXT       = $001758 ; IRQ 2, 6 --- External Expansion
=$00175c				VEC_INT17_SDINS     = $00175C ; IRQ 2, 7 --- SDCARD Insertion
=$001760				VEC_INT30_OPN2      = $001760 ; IRQ 3, 0 --- OPN2
=$001764				VEC_INT31_OPM       = $001764 ; IRQ 3, 1 --- OPM
=$001768				VEC_INT32_IDE       = $001768 ; IRQ 3, 2 --- HDD IDE Interrupt

;******  Return to file: vgm-player.asm


;******  Processing file: timer_def.asm

=$000160				TIMER0_CTRL_REG   = $000160 ; (Write - Control, Read Status)
=$01					TMR0_EN     = $01
=$02					TMR0_SCLR   = $02
=$04					TMR0_SLOAD  = $04 ; Use SLOAD is
=$08					TMR0_UPDWN  = $08
=$000161				TIMER0_CHARGE_L   = $000161 ; Use if you want to Precharge and countdown
=$000162				TIMER0_CHARGE_M   = $000162 ;
=$000163				TIMER0_CHARGE_H   = $000163 ;
=$000164				TIMER0_CMP_REG    = $000164 ;
=$01					TMR0_CMP_RECLR     = $01 ; set to one for it to cycle when Counting up
=$02					TMR0_CMP_RELOAD    = $02 ; Set to one for it to reload when Counting Down
=$000165				TIMER0_CMP_L      = $000165 ; Load this Value for Countup
=$000166				TIMER0_CMP_M      = $000166 ;
=$000167				TIMER0_CMP_H      = $000167 ;
=$000168				TIMER1_CTRL_REG   = $000168 ;
=$01					TMR1_EN     = $01
=$02					TMR1_SCLR   = $02
=$04					TMR1_SLOAD  = $04
=$08					TMR1_UPDWN  = $08 ; 1 = Up, 0 = Down
=$000169				TIMER1_CHARGE_L   = $000169 ; Use if you want to Precharge and countdown
=$00016a				TIMER1_CHARGE_M   = $00016A ;
=$00016b				TIMER1_CHARGE_H   = $00016B ;
=$00016c				TIMER1_CMP_REG    = $00016C ;
=$01					TMR1_CMP_RECLR     = $01 ; set to one for it to cycle when Counting up
=$02					TMR1_CMP_RELOAD    = $02 ; Set to one for it to reload when Counting Down
=$00016d				TIMER1_CMP_L      = $00016D ;
=$00016e				TIMER1_CMP_M      = $00016E ;
=$00016f				TIMER1_CMP_H      = $00016F ;

;******  Return to file: vgm-player.asm


;******  Processing file: math_def.asm

=$000100				UNSIGNED_MULT_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				UNSIGNED_MULT_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				UNSIGNED_MULT_RESULT= $000104 ;4 Bytes Result of A x B
=$000108				SIGNED_MULT_A       = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				SIGNED_MULT_B       = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				SIGNED_MULT_RESULT  = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Signed divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  B/A
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in B/A
=$000114				D0_RESULT        = $000114 ;2 Bytes Signed quotient result of B/A ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Signed remainder of B/A ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Unsigned divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_A          = $000120 ; 4 bytes (32 bit) Accumulator A
=$000124				ADDER_B          = $000124 ; 4 bytes (32 bit) Accumulator B
=$000128				ADDER_R          = $000128 ; 4 bytes (32 bit) Result

;******  Return to file: vgm-player.asm


;******  Processing file: interrupt_def.asm

=$000140				INT_PENDING_REG0 = $000140 ;
=$000141				INT_PENDING_REG1 = $000141 ;
=$000142				INT_PENDING_REG2 = $000142 ;
=$000143				INT_PENDING_REG3 = $000143 ; FMX Model
=$000144				INT_POL_REG0     = $000144 ;
=$000145				INT_POL_REG1     = $000145 ;
=$000146				INT_POL_REG2     = $000146 ;
=$000147				INT_POL_REG3     = $000147 ; FMX Model
=$000148				INT_EDGE_REG0    = $000148 ;
=$000149				INT_EDGE_REG1    = $000149 ;
=$00014a				INT_EDGE_REG2    = $00014A ;
=$00014b				INT_EDGE_REG3    = $00014B ; FMX Model
=$00014c				INT_MASK_REG0    = $00014C ;
=$00014d				INT_MASK_REG1    = $00014D ;
=$00014e				INT_MASK_REG2    = $00014E ;
=$00014f				INT_MASK_REG3    = $00014F ; FMX Model
=$01					FNX0_INT00_SOF        = $01  ;Start of Frame @ 60FPS
=$02					FNX0_INT01_SOL        = $02  ;Start of Line (Programmable)
=$04					FNX0_INT02_TMR0       = $04  ;Timer 0 Interrupt
=$08					FNX0_INT03_TMR1       = $08  ;Timer 1 Interrupt
=$10					FNX0_INT04_TMR2       = $10  ;Timer 2 Interrupt
=$20					FNX0_INT05_RTC        = $20  ;Real-Time Clock Interrupt
=$40					FNX0_INT06_FDC        = $40  ;Floppy Disk Controller
=$80					FNX0_INT07_MOUSE      = $80  ; Mouse Interrupt (INT12 in SuperIO IOspace)
=$01					FNX1_INT00_KBD        = $01  ;Keyboard Interrupt
=$02					FNX1_INT01_SC0        = $02  ;VICKY_II (INT2) Sprite 2 Sprite Collision
=$04					FNX1_INT02_SC1        = $04  ;VICKY_II (INT3) Sprite 2 Tiles Collision
=$08					FNX1_INT03_COM2       = $08  ;Serial Port 2
=$10					FNX1_INT04_COM1       = $10  ;Serial Port 1
=$20					FNX1_INT05_MPU401     = $20  ;Midi Controller Interrupt
=$40					FNX1_INT06_LPT        = $40  ;Parallel Port
=$80					FNX1_INT07_SDCARD     = $80  ;SD Card Controller Interrupt (CH376S)
=$01					FNX2_INT00_OPL3       = $01  ;OPl3
=$02					FNX2_INT01_GABE_INT0  = $02  ;GABE (INT0) - TBD
=$04					FNX2_INT02_GABE_INT1  = $04  ;GABE (INT1) - TBD
=$08					FNX2_INT03_SDMA       = $08  ;VICKY_II (INT4)
=$10					FNX2_INT04_VDMA       = $10  ;VICKY_II (INT5)
=$20					FNX2_INT05_GABE_INT2  = $20  ;GABE (INT2) - TBD
=$40					FNX2_INT06_EXT        = $40  ;External Expansion
=$80					FNX2_INT07_SDCARD_INS = $80  ; SDCARD Insertion
=$01					FNX3_INT00_OPN2       = $01  ;OPN2
=$02					FNX3_INT01_OPM        = $02  ;OPM
=$04					FNX3_INT02_IDE        = $04  ;HDD IDE INTERRUPT
=$08					FNX3_INT03_TBD        = $08  ;TBD
=$10					FNX3_INT04_TBD        = $10  ;TBD
=$20					FNX3_INT05_TBD        = $20  ;GABE (INT2) - TBD
=$40					FNX3_INT06_TBD        = $40  ;External Expansion
=$80					FNX3_INT07_TBD        = $80  ;SDCARD Insertion

;******  Return to file: vgm-player.asm


;******  Processing file: sdos_inc.asm

.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					SIZE                .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
>001e					RESERVED            .word ?             ; Two reserved bytes to bring the descriptor up to 32 bytes
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$10					FD_STAT_ALLOC = $10                     ; The file descriptor has been allocated
=$38					FD_STAT_OPEN = $38                      ; The file is open
=$40					FD_STAT_ERROR = $40                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
=0					BIOS_DEV_FDC = 0                ; Floppy 0
=1					BIOS_DEV_FD1 = 1                ; Future support: Floppy 1 (not likely to be attached)
=2					BIOS_DEV_SD  = 2                ; SD card, partition 0
=3					BIOS_DEV_SD1 = 3                ; Future support: SD card, partition 1
=4					BIOS_DEV_SD2 = 4                ; Future support: SD card, partition 2
=5					BIOS_DEV_SD3 = 5                ; Future support: SD card, partition 3
=6					BIOS_DEV_HD0 = 6                ; Future support: IDE Drive 0, partition 0
=7					BIOS_DEV_HD1 = 7                ; Future support: IDE Drive 0, partition 1
=8					BIOS_DEV_HD2 = 8                ; Future support: IDE Drive 0, partition 2
=9					BIOS_DEV_HD3 = 9                ; Future support: IDE Drive 0, partition 3

;******  Return to file: vgm-player.asm

=$aff000				OPM_BASE_ADDRESS  = $AFF000
=$aff100				PSG_BASE_ADDRESS  = $AFF100
=$aff200				OPN2_BASE_ADDRESS = $AFF200
=$afe600				OPL3_BASE_ADRESS  = $AFE600
=$8					VGM_VERSION       = $8  ; 32-bits
=$c					SN_CLOCK          = $C  ; 32-bits
=$14					GD3_OFFSET        = $14 ; 32-bits
=$1c					LOOP_OFFSET       = $1C ; 32-bits
=$2c					YM_OFFSET         = $2C ; 32-bits
=$30					OPM_CLOCK         = $30 ; 32-bits
=$34					VGM_OFFSET        = $34 ; 32-bits
=$77					MIN_VERSION       = $77 ; 1 byte
=$78					DISPLAY_OFFSET    = $78 ; 2 bytes
=$7a					MSG_PTR           = $7A ; 3 bytes
=$7d					DATA_STREAM_CNT   = $7D ; 2 byte
=$7f					COMMAND           = $7F ; 1 byte
=$80					SONG_START        = $80 ; 4 bytes
=$84					CURRENT_POSITION  = $84 ; 4 bytes
=$88					WAIT_CNTR         = $88 ; 2 bytes
=$8a					PCM_OFFSET        = $8A ; 4 bytes
=$8e					GD3_POSITION      = $8E ; 4 bytes
=$92					AY_3_8910_A       = $92 ; 2 bytes
=$94					AY_3_8910_B       = $94 ; 2 bytes
=$96					AY_3_8910_C       = $96 ; 2 bytes
=$98					AY_3_8910_N       = $98 ; 2 bytes
=$9a					AY_BASE_AMPL      = $9A ; 1 byte
=$8000					DATA_STREAM_TBL   = $8000 ; each entry is 4 bytes
=$170000				VGM_FILE          = $170000  ; the address to store the VGM data.
.162200					VGM_START
.162200	08		php		            PHP
.162201	e2 20		sep #$20	                SEP #$20        ; set A short
.162203	c2 10		rep #$10	                REP #$10        ; set X long
.162205	8b		phb		            PHB
.162206	0b		phd		            PHD
.162207	78		sei		            SEI
.162208	c2 20		rep #$20	                REP #$20        ; set A long
.16220a	a9 00 00	lda #$0000	            LDA #0
.16220d	85 88		sta $88		            STA WAIT_CNTR
.16220f	e2 20		sep #$20	                SEP #$20        ; set A short
.162211	5b		tcd		            TCD  ; store 0 in the direct page register
.162212	48		pha		            PHA
.162213	ab		plb		            PLB  ; store 0 in the bank register
.162214	85 7f		sta $7f		            STA COMMAND
.162216	a9 16		lda #$16	            LDA #`RESET_MSG
.162218	85 7c		sta $7c		            STA MSG_PTR+2
.16221a	a6 17		ldx $17		            LDX $17
.16221c	86 78		stx $78		            STX DISPLAY_OFFSET
.16221e	20 df 23	jsr $1623df	            JSR LOAD_VGM_FILE
.162221	a5 7f		lda $7f		            LDA COMMAND ; if the command is still 0, it's a vgm file
.162223	d0 45		bne $16226a	            BNE VGM_DONE
.162225	a9 00		lda #$00	            LDA #0
.162227	8f 10 00 af	sta $af0010	            STA VKY_TXT_CURSOR_CTRL_REG
.16222b	a2 00 00	ldx #$0000	            LDX #0
.16222e	86 7d		stx $7d		            STX DATA_STREAM_CNT
.162230	a9 17		lda #$17	            LDA #`VGM_FILE
.162232	85 86		sta $86		            STA CURRENT_POSITION + 2
.162234	85 82		sta $82		            STA SONG_START + 2
.162236	a2 00 00	ldx #$0000	            LDX #<>VGM_FILE
.162239	86 80		stx $80		            STX SONG_START
.16223b	a9 00		lda #$00	            LDA #0
.16223d	85 7f		sta $7f		            STA COMMAND
.16223f	20 ba 23	jsr $1623ba	            JSR CHECK_VGM_FILE
.162242	a5 7f		lda $7f		            LDA COMMAND ; if the command is still 0, it's a vgm file
.162244	d0 18		bne $16225e	            BNE INVALID_FILE
.162246	20 54 2a	jsr $162a54	            JSR VGM_SET_SONG_POINTERS
.162249	20 eb 2b	jsr $162beb	            JSR VGM_DISPLAY_GD3
.16224c	20 19 2b	jsr $162b19	            JSR VGM_INIT_TIMER0
.16224f	ad 4c 01	lda $014c	            LDA INT_MASK_REG0
.162252	29 fb		and #$fb	            AND #~( FNX0_INT02_TMR0 ) ;
.162254	8d 4c 01	sta $014c	            STA INT_MASK_REG0
.162257	22 ee 24 16	jsl $1624ee	            JSL VGM_WRITE_REGISTER  ; the initial load of register should set the timerA
.16225b	58		cli		            CLI
.16225c	80 0c		bra $16226a	            BRA VGM_DONE
.16225e					        INVALID_FILE
.16225e	c2 20		rep #$20	                REP #$20        ; set A long
.162260	a9 a9 22	lda #$22a9	            LDA #<>INVALID_FILE_MSG
.162263	85 7a		sta $7a		            STA MSG_PTR
.162265	e2 20		sep #$20	                SEP #$20        ; set A short
.162267	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.16226a					        VGM_DONE
.16226a	a0 7e 23	ldy #$237e	            LDY #<>KERNEL_RETURN_MSG
.16226d	84 7a		sty $7a		            STY MSG_PTR
.16226f	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162272	2b		pld		            PLD
.162273	ab		plb		            PLB
.162274	28		plp		            PLP
.162275	6b		rtl		            RTL
>162276	52 65 73 74 61 72 74 69		RESET_MSG               .text 'Restarting song:',0
>16227e	6e 67 20 73 6f 6e 67 3a 00
>162287	4c 6f 6f 70 69 6e 67 20		LOOPING_MSG             .text 'Looping song:',0
>16228f	73 6f 6e 67 3a 00
>162295	52 65 61 64 69 6e 67 20		DATA_BLOCK_MSG          .text 'Reading Data Block:',0
>16229d	44 61 74 61 20 42 6c 6f 63 6b 3a 00
>1622a9	49 6e 76 61 6c 69 64 20		INVALID_FILE_MSG        .text 'Invalid file type:', 0
>1622b1	66 69 6c 65 20 74 79 70 65 3a 00
>1622bc	55 6e 6b 6e 6f 77 6e 20		UNK_CMD1_MSG            .text 'Unknown 1-Byte Command:',0
>1622c4	31 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>1622d4	55 6e 6b 6e 6f 77 6e 20		UNK_CMD2_MSG            .text 'Unknown 2-Byte Command:',0
>1622dc	32 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>1622ec	55 6e 6b 6e 6f 77 6e 20		UNK_CMD3_MSG            .text 'Unknown 3-Byte Command:',0
>1622f4	33 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>162304	55 6e 6b 6e 6f 77 6e 20		UNK_CMD4_MSG            .text 'Unknown 4-Byte Command:',0
>16230c	34 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>16231c	30 31 32 33 34 35 36 37		HEX_VALUES              .text '0123456789ABCDEF'
>162324	38 39 41 42 43 44 45 46
>16232c	43 6f 75 6c 64 6e 27 74		GD3_ERR_MSG             .text 'Couldn''t read Gd3 Info', 0
>162334	20 72 65 61 64 20 47 64 33 20 49 6e 66 6f 00
>162343	56 47 4d 20 50 6c 61 79		LOADING_VGM_FILE_MSG    .text 'VGM Player loading file', 0
>16234b	65 72 20 6c 6f 61 64 69 6e 67 20 66 69 6c 65 00
>16235b	42 52 55 4e 20 64 6f 65		BRUN_CMD_ERROR_MSG      .text 'BRUN does not have a file to load.', 0
>162363	73 20 6e 6f 74 20 68 61 76 65 20 61 20 66 69 6c
>162373	65 20 74 6f 20 6c 6f 61 64 2e 00
>16237e	52 65 74 75 72 6e 69 6e		KERNEL_RETURN_MSG       .text 'Returning control to kernel', 0
>162386	67 20 63 6f 6e 74 72 6f 6c 20 74 6f 20 6b 65 72
>162396	6e 65 6c 00
.16239a					DOS_REC_PTR
>16239a					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>16239b					DEV                 .byte ?             ; The ID of the device holding the file
>16239c					PATH                .dword ?            ; Pointer to a NULL terminated path string
>1623a0					CLUSTER             .dword ?            ; The current cluster of the file.
>1623a4					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>1623a8					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>1623ac					SIZE                .dword ?            ; The size of the file
>1623b0					CREATE_DATE         .word ?             ; The creation date of the file
>1623b2					CREATE_TIME         .word ?             ; The creation time of the file
>1623b4					MODIFIED_DATE       .word ?             ; The modification date of the file
>1623b6					MODIFIED_TIME       .word ?             ; The modification time of the file
>1623b8					RESERVED            .word ?             ; Two reserved bytes to bring the descriptor up to 32 bytes
.1623ba					CHECK_VGM_FILE
.1623ba	a0 00 00	ldy #$0000	            LDY #0
.1623bd	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623bf	c8		iny		            INY
.1623c0	c9 56		cmp #$56	            CMP #'V'
.1623c2	d0 16		bne $1623da	            BNE CHECK_FAILED
.1623c4	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623c6	c8		iny		            INY
.1623c7	c9 67		cmp #$67	            CMP #'g'
.1623c9	d0 0f		bne $1623da	            BNE CHECK_FAILED
.1623cb	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623cd	c8		iny		            INY
.1623ce	c9 6d		cmp #$6d	            CMP #'m'
.1623d0	d0 08		bne $1623da	            BNE CHECK_FAILED
.1623d2	a0 08 00	ldy #$0008	            LDY #8
.1623d5	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623d7	85 77		sta $77		            STA MIN_VERSION
.1623d9	60		rts		            RTS
.1623da					    CHECK_FAILED
.1623da	a9 01		lda #$01	            LDA #1
.1623dc	85 7f		sta $7f		            STA COMMAND
.1623de	60		rts		            RTS
.1623df					LOAD_VGM_FILE
.1623df	48		pha		                PHA             ; begin setdp macro
.1623e0	08		php		                PHP
.1623e1	c2 20		rep #$20	                REP #$20        ; set A long
.1623e3	a9 60 03	lda #$0360	                LDA #<>DOS_RUN_PARAM         ; set DP to page 0
.1623e6	5b		tcd		                TCD
.1623e7	28		plp		                PLP
.1623e8	68		pla		                PLA             ; end setdp macro
.1623e9	a0 00 00	ldy #$0000	            LDY #0
.1623ec					    FS_LOOP
.1623ec	b7 00		lda [$0360],y	            LDA [DOS_RUN_PARAM],Y
.1623ee	c8		iny		            INY
.1623ef	c0 20 00	cpy #$0020	            CPY #$20 ; expect the vgm command to be less than 32 characters
.1623f2	b0 1c		bcs $162410	            BGE LF_ERROR
.1623f4	c9 20		cmp #$20	            CMP #' '  ; seek the space character in the BRUN command
.1623f6	d0 f4		bne $1623ec	            BNE FS_LOOP
.1623f8	5a		phy		            PHY
.1623f9	0b		phd		            PHD
.1623fa	48		pha		                PHA             ; begin setdp macro
.1623fb	08		php		                PHP
.1623fc	c2 20		rep #$20	                REP #$20        ; set A long
.1623fe	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.162401	5b		tcd		                TCD
.162402	28		plp		                PLP
.162403	68		pla		                PLA             ; end setdp macro
.162404	a0 43 23	ldy #$2343	            LDY #<>LOADING_VGM_FILE_MSG
.162407	84 7a		sty $7a		            STY MSG_PTR
.162409	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.16240c	2b		pld		            PLD
.16240d	7a		ply		            PLY
.16240e	80 17		bra $162427	            BRA LF_GOOD
.162410					    LF_ERROR
.162410	48		pha		                PHA             ; begin setdp macro
.162411	08		php		                PHP
.162412	c2 20		rep #$20	                REP #$20        ; set A long
.162414	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.162417	5b		tcd		                TCD
.162418	28		plp		                PLP
.162419	68		pla		                PLA             ; end setdp macro
.16241a	a0 5b 23	ldy #$235b	            LDY #<>BRUN_CMD_ERROR_MSG
.16241d	84 7a		sty $7a		            STY MSG_PTR
.16241f	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162422	a9 01		lda #$01	            LDA #1
.162424	85 7f		sta $7f		            STA COMMAND
.162426	60		rts		            RTS
.162427					    LF_GOOD
.162427	c2 20		rep #$20	                REP #$20        ; set A long
.162429	98		tya		            TYA
.16242a	18		clc		            CLC
.16242b	6d 60 03	adc $0360	            ADC DOS_RUN_PARAM
.16242e	8f 9c 23 16	sta $16239c	            STA DOS_REC_PTR.PATH
.162432	ad 62 03	lda $0362	            LDA DOS_RUN_PARAM + 2
.162435	8f 9e 23 16	sta $16239e	            STA DOS_REC_PTR.PATH + 2
.162439	a9 00 00	lda #$0000	            LDA #<>VGM_FILE
.16243c	8d 54 03	sta $0354	            STA DOS_DST_PTR
.16243f	a9 17 00	lda #$0017	            LDA #`VGM_FILE
.162442	8d 56 03	sta $0356	            STA DOS_DST_PTR + 2
.162445	a9 9a 23	lda #$239a	            LDA #<>DOS_REC_PTR
.162448	8d 40 03	sta $0340	            STA DOS_FD_PTR
.16244b	a9 16 00	lda #$0016	            LDA #`DOS_REC_PTR
.16244e	8d 42 03	sta $0342	            STA DOS_FD_PTR + 2
.162451	a9 00 20	lda #$2000	            LDA #<>VGM_START - 512
.162454	8f a8 23 16	sta $1623a8	            STA DOS_REC_PTR.BUFFER
.162458	a9 16 00	lda #$0016	            LDA #`(VGM_START - 512)
.16245b	8f aa 23 16	sta $1623aa	            STA DOS_REC_PTR.BUFFER + 2
.16245f	e2 20		sep #$20	                SEP #$20        ; set A short
.162461	a9 00		lda #$00	            LDA #0
.162463	8f 9a 23 16	sta $16239a	            STA DOS_REC_PTR.STATUS
.162467	a9 02		lda #$02	            LDA #BIOS_DEV_SD
.162469	8f 9b 23 16	sta $16239b	            STA DOS_REC_PTR.DEV
.16246d	22 18 11 00	jsl $001118	            JSL F_LOAD
.162471	90 9d		bcc $162410	            BCC LF_ERROR
.162473	48		pha		                PHA             ; begin setdp macro
.162474	08		php		                PHP
.162475	c2 20		rep #$20	                REP #$20        ; set A long
.162477	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.16247a	5b		tcd		                TCD
.16247b	28		plp		                PLP
.16247c	68		pla		                PLA             ; end setdp macro
.16247d	60		rts		            RTS
.16247e					DISPLAY_MSG
.16247e	5a		phy		            PHY
.16247f	a6 78		ldx $78		            LDX DISPLAY_OFFSET
.162481	a0 00 00	ldy #$0000	            LDY #0
.162484	a9 00		lda #$00	            LDA #0
.162486	eb		xba		            XBA
.162487					    DISPLAY_NEXT
.162487	a9 2d		lda #$2d	            LDA #$2D   ; Text color
.162489	9f 00 20 af	sta $af2000,x	            STA $AF2000,X  ; offset to Text LUT $AF:C000
.16248d	b7 7a		lda [$7a],y	            LDA [MSG_PTR],Y
.16248f	9f 00 00 af	sta $af0000,x	            STA $AF0000,X  ; offset to Text $AF:A000
.162493	e8		inx		            INX
.162494	c8		iny		            INY
.162495	c9 00		cmp #$00	            CMP #0
.162497	d0 ee		bne $162487	            BNE DISPLAY_NEXT
.162499	a9 2d		lda #$2d	            LDA #$2D
.16249b	9f 00 20 af	sta $af2000,x	            STA $AF2000,X
.16249f	a5 7f		lda $7f		            LDA COMMAND
.1624a1	29 f0		and #$f0	            AND #$F0
.1624a3	4a		lsr a		            LSR A
.1624a4	4a		lsr a		            LSR A
.1624a5	4a		lsr a		            LSR A
.1624a6	4a		lsr a		            LSR A
.1624a7	9b		txy		            TXY
.1624a8	aa		tax		            TAX
.1624a9	bf 1c 23 16	lda $16231c,x	            LDA HEX_VALUES,X
.1624ad	bb		tyx		            TYX
.1624ae	9f 00 00 af	sta $af0000,x	            STA $AF0000,X
.1624b2	e8		inx		            INX
.1624b3	a9 2d		lda #$2d	            LDA #$2D
.1624b5	9f 00 20 af	sta $af2000,x	            STA $AF2000,X
.1624b9	a5 7f		lda $7f		            LDA COMMAND
.1624bb	29 0f		and #$0f	            AND #$F
.1624bd	9b		txy		            TXY
.1624be	aa		tax		            TAX
.1624bf	bf 1c 23 16	lda $16231c,x	            LDA HEX_VALUES,X
.1624c3	bb		tyx		            TYX
.1624c4	9f 00 00 af	sta $af0000,x	            STA $AF0000,X
.1624c8	c2 20		rep #$20	                REP #$20        ; set A long
.1624ca	a5 78		lda $78		            LDA DISPLAY_OFFSET
.1624cc	18		clc		            CLC
.1624cd	69 50 00	adc #$0050	            ADC #80 ; 80 columns in 640x480 mode
.1624d0	85 78		sta $78		            STA DISPLAY_OFFSET
.1624d2	e2 20		sep #$20	                SEP #$20        ; set A short
.1624d4	eb		xba		            XBA
.1624d5	c9 b1		cmp #$b1	            CMP #$B1 ; 80 COLS * 56 ROWS = $1180  - SO $11 + A0 = $B1
.1624d7	90 13		bcc $1624ec	            BLT DISPLAY_DONE
.1624d9	eb		xba		            XBA
.1624da	d0 07		bne $1624e3	            BNE FIRST_COL
.1624dc	a2 28 a0	ldx #$a028	            LDX #$A000 + 40 ; create a second column
.1624df	86 78		stx $78		            STX DISPLAY_OFFSET
.1624e1	80 09		bra $1624ec	            BRA DISPLAY_DONE
.1624e3					        FIRST_COL
.1624e3	a2 00 a0	ldx #$a000	            LDX #$A000
.1624e6	86 78		stx $78		            STX DISPLAY_OFFSET
.1624e8	22 a8 10 00	jsl $0010a8	            JSL CLRSCREEN
.1624ec					    DISPLAY_DONE
.1624ec	7a		ply		            PLY
.1624ed	60		rts		            RTS
.1624ee					VGM_WRITE_REGISTER
.1624ee	0b		phd		            PHD
.1624ef	48		pha		                PHA             ; begin setdp macro
.1624f0	08		php		                PHP
.1624f1	c2 20		rep #$20	                REP #$20        ; set A long
.1624f3	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.1624f6	5b		tcd		                TCD
.1624f7	28		plp		                PLP
.1624f8	68		pla		                PLA             ; end setdp macro
.1624f9	a6 88		ldx $88		            LDX WAIT_CNTR
.1624fb	e0 00 00	cpx #$0000	            CPX #0
.1624fe	f0 05		beq $162505	            BEQ READ_COMMAND
.162500	ca		dex		            DEX
.162501	86 88		stx $88		            STX WAIT_CNTR
.162503	2b		pld		            PLD
.162504	6b		rtl		            RTL
.162505					    READ_COMMAND
.162505	a9 00		lda #$00	            LDA #0
.162507	eb		xba		            XBA
.162508	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16250a	85 7f		sta $7f		            STA COMMAND
.16250c	c2 20		rep #$20	                REP #$20        ; set A long
.16250e	e6 84		inc $84		            INC CURRENT_POSITION
.162510	d0 02		bne $162514	            BNE increment_done
.162512	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162514					    increment_done
.162514	e2 20		sep #$20	                SEP #$20        ; set A short
.162516	29 f0		and #$f0	            AND #$F0
.162518	4a		lsr a		            LSR A
.162519	4a		lsr a		            LSR A
.16251a	4a		lsr a		            LSR A
.16251b	aa		tax		            TAX
.16251c	7c 21 25	jmp ($162521,x)	            JMP (VGM_COMMAND_TABLE,X)
.16251f					    VGM_LOOP_DONE
.16251f	2b		pld		            PLD
.162520	6b		rtl		            RTL
.162521					VGM_COMMAND_TABLE
>162521	41 25				            .word <>INVALID_COMMAND ;0
>162523	41 25				            .word <>INVALID_COMMAND ;1
>162525	41 25				            .word <>INVALID_COMMAND ;2
>162527	44 25				            .word <>SKIP_BYTE_CMD   ;3 - reserved - not implemented
>162529	44 25				            .word <>SKIP_BYTE_CMD   ;4 - not implemented
>16252b	d7 27				            .word <>WRITE_YM_CMD    ;5 - YM*
>16252d	ce 29				            .word <>WAIT_COMMANDS   ;6
>16252f	20 2a				            .word <>WAIT_N_1        ;7
>162531	2e 2a				            .word <>YM2612_SAMPLE   ;8
>162533	51 2a				            .word <>DAC_STREAM      ;9
>162535	25 26				            .word <>AY8910          ;A - AY8910
>162537	5d 25				            .word <>SKIP_TWO_BYTES  ;B - not implemented
>162539	7c 25				            .word <>SKIP_THREE_BYTES;C - not implemented
>16253b	7c 25				            .word <>SKIP_THREE_BYTES;D - not implemented
>16253d	a1 25				            .word <>SEEK_OFFSET     ;E - not implemented
>16253f	fa 25				            .word <>SKIP_FOUR_BYTES ;F - not implemented
.162541					INVALID_COMMAND
.162541	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162544					SKIP_BYTE_CMD
.162544	c2 20		rep #$20	                REP #$20        ; set A long
.162546	a9 bc 22	lda #$22bc	            LDA #<>UNK_CMD1_MSG
.162549	85 7a		sta $7a		            STA MSG_PTR
.16254b	e2 20		sep #$20	                SEP #$20        ; set A short
.16254d	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162550	c2 20		rep #$20	                REP #$20        ; set A long
.162552	e6 84		inc $84		            INC CURRENT_POSITION
.162554	d0 02		bne $162558	            BNE increment_done
.162556	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162558					    increment_done
.162558	e2 20		sep #$20	                SEP #$20        ; set A short
.16255a	4c 05 25	jmp $162505	            JMP READ_COMMAND
.16255d					SKIP_TWO_BYTES
.16255d	c2 20		rep #$20	                REP #$20        ; set A long
.16255f	a9 d4 22	lda #$22d4	            LDA #<>UNK_CMD2_MSG
.162562	85 7a		sta $7a		            STA MSG_PTR
.162564	e2 20		sep #$20	                SEP #$20        ; set A short
.162566	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162569	c2 20		rep #$20	                REP #$20        ; set A long
.16256b	e6 84		inc $84		            INC CURRENT_POSITION
.16256d	d0 02		bne $162571	            BNE s2_1
.16256f	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162571					    s2_1
.162571	e6 84		inc $84		            INC CURRENT_POSITION
.162573	d0 02		bne $162577	            BNE s2_2
.162575	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162577					    s2_2
.162577	e2 20		sep #$20	                SEP #$20        ; set A short
.162579	4c 05 25	jmp $162505	            JMP READ_COMMAND
.16257c					SKIP_THREE_BYTES
.16257c	c2 20		rep #$20	                REP #$20        ; set A long
.16257e	a9 ec 22	lda #$22ec	            LDA #<>UNK_CMD3_MSG
.162581	85 7a		sta $7a		            STA MSG_PTR
.162583	e2 20		sep #$20	                SEP #$20        ; set A short
.162585	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162588	c2 20		rep #$20	                REP #$20        ; set A long
.16258a	e6 84		inc $84		            INC CURRENT_POSITION
.16258c	d0 02		bne $162590	            BNE s3_1
.16258e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162590					    s3_1
.162590	e6 84		inc $84		            INC CURRENT_POSITION
.162592	d0 02		bne $162596	            BNE s3_2
.162594	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162596					    s3_2
.162596	e6 84		inc $84		            INC CURRENT_POSITION
.162598	d0 02		bne $16259c	            BNE s3_3
.16259a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16259c					    s3_3
.16259c	e2 20		sep #$20	                SEP #$20        ; set A short
.16259e	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1625a1					SEEK_OFFSET
.1625a1	a5 7f		lda $7f		            LDA COMMAND
.1625a3	c9 e0		cmp #$e0	            CMP #$E0
.1625a5	d0 53		bne $1625fa	            BNE SKIP_FOUR_BYTES
.1625a7	c2 20		rep #$20	                REP #$20        ; set A long
.1625a9	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1625ab	8d 20 01	sta $0120	            STA ADDER_A
.1625ae	c2 20		rep #$20	                REP #$20        ; set A long
.1625b0	e6 84		inc $84		            INC CURRENT_POSITION
.1625b2	d0 02		bne $1625b6	            BNE increment_done
.1625b4	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625b6					    increment_done
.1625b6	e2 20		sep #$20	                SEP #$20        ; set A short
.1625b8	c2 20		rep #$20	                REP #$20        ; set A long
.1625ba	e6 84		inc $84		            INC CURRENT_POSITION
.1625bc	d0 02		bne $1625c0	            BNE increment_done
.1625be	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625c0					    increment_done
.1625c0	e2 20		sep #$20	                SEP #$20        ; set A short
.1625c2	c2 20		rep #$20	                REP #$20        ; set A long
.1625c4	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1625c6	8d 22 01	sta $0122	            STA ADDER_A + 2
.1625c9	c2 20		rep #$20	                REP #$20        ; set A long
.1625cb	e6 84		inc $84		            INC CURRENT_POSITION
.1625cd	d0 02		bne $1625d1	            BNE increment_done
.1625cf	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625d1					    increment_done
.1625d1	e2 20		sep #$20	                SEP #$20        ; set A short
.1625d3	c2 20		rep #$20	                REP #$20        ; set A long
.1625d5	e6 84		inc $84		            INC CURRENT_POSITION
.1625d7	d0 02		bne $1625db	            BNE increment_done
.1625d9	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625db					    increment_done
.1625db	e2 20		sep #$20	                SEP #$20        ; set A short
.1625dd	c2 20		rep #$20	                REP #$20        ; set A long
.1625df	ad 00 80	lda $8000	            LDA DATA_STREAM_TBL
.1625e2	8d 24 01	sta $0124	            STA ADDER_B
.1625e5	ad 02 80	lda $8002	            LDA DATA_STREAM_TBL + 2
.1625e8	8d 26 01	sta $0126	            STA ADDER_B + 2
.1625eb	ad 28 01	lda $0128	            LDA ADDER_R
.1625ee	85 8a		sta $8a		            STA PCM_OFFSET
.1625f0	ad 2a 01	lda $012a	            LDA ADDER_R + 2
.1625f3	85 8c		sta $8c		            STA PCM_OFFSET + 2
.1625f5	e2 20		sep #$20	                SEP #$20        ; set A short
.1625f7	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE
.1625fa					SKIP_FOUR_BYTES
.1625fa	c2 20		rep #$20	                REP #$20        ; set A long
.1625fc	a9 04 23	lda #$2304	            LDA #<>UNK_CMD4_MSG
.1625ff	85 7a		sta $7a		            STA MSG_PTR
.162601	e2 20		sep #$20	                SEP #$20        ; set A short
.162603	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162606	c2 20		rep #$20	                REP #$20        ; set A long
.162608	e6 84		inc $84		            INC CURRENT_POSITION
.16260a	d0 02		bne $16260e	            BNE s4_1
.16260c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16260e					    s4_1
.16260e	e6 84		inc $84		            INC CURRENT_POSITION
.162610	d0 02		bne $162614	            BNE s4_2
.162612	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162614					    s4_2
.162614	e6 84		inc $84		            INC CURRENT_POSITION
.162616	d0 02		bne $16261a	            BNE s4_3
.162618	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16261a					    s4_3
.16261a	e6 84		inc $84		            INC CURRENT_POSITION
.16261c	d0 02		bne $162620	            BNE s4_4
.16261e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162620					    s4_4
.162620	e2 20		sep #$20	                SEP #$20        ; set A short
.162622	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162625					AY8910
.162625	a9 0f		lda #$0f	            LDA #$F
.162627	85 9a		sta $9a		            STA AY_BASE_AMPL
.162629	a5 7f		lda $7f		            LDA COMMAND
.16262b	c9 a0		cmp #$a0	            CMP #$A0
.16262d	f0 03		beq $162632	            BEQ AY_COMMAND
.16262f	4c 5d 25	jmp $16255d	            JMP SKIP_TWO_BYTES ; when mixing with the YM2612, the SN76489 is just too load.
.162632					    AY_COMMAND
.162632	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162634	c2 20		rep #$20	                REP #$20        ; set A long
.162636	e6 84		inc $84		            INC CURRENT_POSITION
.162638	d0 02		bne $16263c	            BNE increment_done
.16263a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16263c					    increment_done
.16263c	e2 20		sep #$20	                SEP #$20        ; set A short
.16263e	c9 00		cmp #$00	            CMP #0 ; Register 0 fine
.162640	d0 4c		bne $16268e	            BNE AY_R1
.162642	a5 92		lda $92		            LDA AY_3_8910_A
.162644	c9 08		cmp #$08	            CMP #8
.162646	90 19		bcc $162661	            BLT R0_FINE
.162648	a9 87		lda #$87	            LDA #$87
.16264a	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16264e	a9 3f		lda #$3f	            LDA #$3F
.162650	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162654	c2 20		rep #$20	                REP #$20        ; set A long
.162656	e6 84		inc $84		            INC CURRENT_POSITION
.162658	d0 02		bne $16265c	            BNE increment_done
.16265a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16265c					    increment_done
.16265c	e2 20		sep #$20	                SEP #$20        ; set A short
.16265e	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162661					        R0_FINE
.162661	eb		xba		            XBA
.162662	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162664	c2 20		rep #$20	                REP #$20        ; set A long
.162666	e6 84		inc $84		            INC CURRENT_POSITION
.162668	d0 02		bne $16266c	            BNE increment_done
.16266a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16266c					    increment_done
.16266c	e2 20		sep #$20	                SEP #$20        ; set A short
.16266e	c2 20		rep #$20	                REP #$20        ; set A long
.162670	4a		lsr a		            LSR A ; drop the LSB
.162671	e2 20		sep #$20	                SEP #$20        ; set A short
.162673	48		pha		            PHA
.162674	29 0f		and #$0f	            AND #$F
.162676	09 80		ora #$80	            ORA #$80
.162678	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16267c	68		pla		            PLA
.16267d	c2 20		rep #$20	                REP #$20        ; set A long
.16267f	4a		lsr a		            LSR A
.162680	4a		lsr a		            LSR A
.162681	4a		lsr a		            LSR A
.162682	4a		lsr a		            LSR A
.162683	e2 20		sep #$20	                SEP #$20        ; set A short
.162685	29 3f		and #$3f	            AND #$3F ; 6 bits
.162687	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16268b	4c 05 25	jmp $162505	            JMP READ_COMMAND
.16268e	c9 01		cmp #$01	    AY_R1   CMP #1
.162690	d0 13		bne $1626a5	            BNE AY_R2
.162692	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162694	c2 20		rep #$20	                REP #$20        ; set A long
.162696	e6 84		inc $84		            INC CURRENT_POSITION
.162698	d0 02		bne $16269c	            BNE increment_done
.16269a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16269c					    increment_done
.16269c	e2 20		sep #$20	                SEP #$20        ; set A short
.16269e	29 0f		and #$0f	            AND #$F
.1626a0	85 92		sta $92		            STA AY_3_8910_A
.1626a2	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1626a5	c9 02		cmp #$02	    AY_R2   CMP #2
.1626a7	d0 4c		bne $1626f5	            BNE AY_R3
.1626a9	a5 94		lda $94		            LDA AY_3_8910_B
.1626ab	c9 08		cmp #$08	            CMP #8
.1626ad	90 19		bcc $1626c8	            BLT R1_FINE
.1626af	a9 a7		lda #$a7	            LDA #$A7
.1626b1	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626b5	a9 3f		lda #$3f	            LDA #$3F
.1626b7	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626bb	c2 20		rep #$20	                REP #$20        ; set A long
.1626bd	e6 84		inc $84		            INC CURRENT_POSITION
.1626bf	d0 02		bne $1626c3	            BNE increment_done
.1626c1	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1626c3					    increment_done
.1626c3	e2 20		sep #$20	                SEP #$20        ; set A short
.1626c5	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1626c8					        R1_FINE
.1626c8	eb		xba		            XBA
.1626c9	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1626cb	c2 20		rep #$20	                REP #$20        ; set A long
.1626cd	e6 84		inc $84		            INC CURRENT_POSITION
.1626cf	d0 02		bne $1626d3	            BNE increment_done
.1626d1	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1626d3					    increment_done
.1626d3	e2 20		sep #$20	                SEP #$20        ; set A short
.1626d5	c2 20		rep #$20	                REP #$20        ; set A long
.1626d7	4a		lsr a		            LSR A ; drop the LSB
.1626d8	e2 20		sep #$20	                SEP #$20        ; set A short
.1626da	48		pha		            PHA
.1626db	29 0f		and #$0f	            AND #$F
.1626dd	09 a0		ora #$a0	            ORA #$A0
.1626df	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626e3	68		pla		            PLA
.1626e4	c2 20		rep #$20	                REP #$20        ; set A long
.1626e6	4a		lsr a		            LSR A
.1626e7	4a		lsr a		            LSR A
.1626e8	4a		lsr a		            LSR A
.1626e9	4a		lsr a		            LSR A
.1626ea	e2 20		sep #$20	                SEP #$20        ; set A short
.1626ec	29 3f		and #$3f	            AND #$3F ; 6 bits
.1626ee	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626f2	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1626f5	c9 03		cmp #$03	    AY_R3   CMP #3
.1626f7	d0 13		bne $16270c	            BNE AY_R4
.1626f9	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1626fb	c2 20		rep #$20	                REP #$20        ; set A long
.1626fd	e6 84		inc $84		            INC CURRENT_POSITION
.1626ff	d0 02		bne $162703	            BNE increment_done
.162701	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162703					    increment_done
.162703	e2 20		sep #$20	                SEP #$20        ; set A short
.162705	29 0f		and #$0f	            AND #$F
.162707	85 94		sta $94		            STA AY_3_8910_B
.162709	4c 05 25	jmp $162505	            JMP READ_COMMAND
.16270c	c9 04		cmp #$04	    AY_R4   CMP #4
.16270e	d0 4c		bne $16275c	            BNE AY_R5
.162710	a5 96		lda $96		            LDA AY_3_8910_C
.162712	c9 08		cmp #$08	            CMP #8
.162714	90 19		bcc $16272f	            BLT R2_FINE
.162716	a9 c7		lda #$c7	            LDA #$C7
.162718	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16271c	a9 3f		lda #$3f	            LDA #$3F
.16271e	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162722	c2 20		rep #$20	                REP #$20        ; set A long
.162724	e6 84		inc $84		            INC CURRENT_POSITION
.162726	d0 02		bne $16272a	            BNE increment_done
.162728	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16272a					    increment_done
.16272a	e2 20		sep #$20	                SEP #$20        ; set A short
.16272c	4c 05 25	jmp $162505	            JMP READ_COMMAND
.16272f					        R2_FINE
.16272f	eb		xba		            XBA
.162730	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162732	c2 20		rep #$20	                REP #$20        ; set A long
.162734	e6 84		inc $84		            INC CURRENT_POSITION
.162736	d0 02		bne $16273a	            BNE increment_done
.162738	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16273a					    increment_done
.16273a	e2 20		sep #$20	                SEP #$20        ; set A short
.16273c	c2 20		rep #$20	                REP #$20        ; set A long
.16273e	4a		lsr a		            LSR A ; drop the LSB
.16273f	e2 20		sep #$20	                SEP #$20        ; set A short
.162741	48		pha		            PHA
.162742	29 0f		and #$0f	            AND #$F
.162744	09 c0		ora #$c0	            ORA #$C0
.162746	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16274a	68		pla		            PLA
.16274b	c2 20		rep #$20	                REP #$20        ; set A long
.16274d	4a		lsr a		            LSR A
.16274e	4a		lsr a		            LSR A
.16274f	4a		lsr a		            LSR A
.162750	4a		lsr a		            LSR A
.162751	e2 20		sep #$20	                SEP #$20        ; set A short
.162753	29 3f		and #$3f	            AND #$3F ; 6 bits
.162755	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162759	4c 05 25	jmp $162505	            JMP READ_COMMAND
.16275c	c9 05		cmp #$05	    AY_R5   CMP #5
.16275e	d0 13		bne $162773	            BNE AY_R10
.162760	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162762	c2 20		rep #$20	                REP #$20        ; set A long
.162764	e6 84		inc $84		            INC CURRENT_POSITION
.162766	d0 02		bne $16276a	            BNE increment_done
.162768	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16276a					    increment_done
.16276a	e2 20		sep #$20	                SEP #$20        ; set A short
.16276c	29 0f		and #$0f	            AND #$F
.16276e	85 96		sta $96		            STA AY_3_8910_C
.162770	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162773					    AY_R10
.162773	c9 08		cmp #$08	            CMP #8
.162775	d0 19		bne $162790	            BNE AY_R11
.162777	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162779	c2 20		rep #$20	                REP #$20        ; set A long
.16277b	e6 84		inc $84		            INC CURRENT_POSITION
.16277d	d0 02		bne $162781	            BNE increment_done
.16277f	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162781					    increment_done
.162781	e2 20		sep #$20	                SEP #$20        ; set A short
.162783	45 9a		eor $9a		            EOR AY_BASE_AMPL
.162785	29 0f		and #$0f	            AND #$F
.162787	09 90		ora #$90	            ORA #$90
.162789	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16278d	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162790					    AY_R11
.162790	c9 09		cmp #$09	            CMP #9
.162792	d0 19		bne $1627ad	            BNE AY_R12
.162794	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162796	c2 20		rep #$20	                REP #$20        ; set A long
.162798	e6 84		inc $84		            INC CURRENT_POSITION
.16279a	d0 02		bne $16279e	            BNE increment_done
.16279c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16279e					    increment_done
.16279e	e2 20		sep #$20	                SEP #$20        ; set A short
.1627a0	45 9a		eor $9a		            EOR AY_BASE_AMPL
.1627a2	29 0f		and #$0f	            AND #$F
.1627a4	09 b0		ora #$b0	            ORA #$B0
.1627a6	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1627aa	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1627ad					    AY_R12
.1627ad	c9 0a		cmp #$0a	            CMP #10
.1627af	d0 19		bne $1627ca	            BNE AY_R15
.1627b1	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627b3	c2 20		rep #$20	                REP #$20        ; set A long
.1627b5	e6 84		inc $84		            INC CURRENT_POSITION
.1627b7	d0 02		bne $1627bb	            BNE increment_done
.1627b9	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627bb					    increment_done
.1627bb	e2 20		sep #$20	                SEP #$20        ; set A short
.1627bd	45 9a		eor $9a		            EOR AY_BASE_AMPL
.1627bf	29 0f		and #$0f	            AND #$F
.1627c1	09 d0		ora #$d0	            ORA #$D0
.1627c3	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1627c7	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1627ca					    AY_R15
.1627ca	c2 20		rep #$20	                REP #$20        ; set A long
.1627cc	e6 84		inc $84		            INC CURRENT_POSITION
.1627ce	d0 02		bne $1627d2	            BNE increment_done
.1627d0	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627d2					    increment_done
.1627d2	e2 20		sep #$20	                SEP #$20        ; set A short
.1627d4	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1627d7					WRITE_YM_CMD
.1627d7	a5 7f		lda $7f		            LDA COMMAND
.1627d9	c9 50		cmp #$50	            CMP #$50
.1627db	d0 13		bne $1627f0	            BNE CHK_YM2413
.1627dd	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627df	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1627e3	c2 20		rep #$20	                REP #$20        ; set A long
.1627e5	e6 84		inc $84		            INC CURRENT_POSITION
.1627e7	d0 02		bne $1627eb	            BNE increment_done
.1627e9	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627eb					    increment_done
.1627eb	e2 20		sep #$20	                SEP #$20        ; set A short
.1627ed	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE ; for some reason, this chip needs more time between writes
.1627f0					        CHK_YM2413
.1627f0	c9 51		cmp #$51	            CMP #$51
.1627f2	d0 23		bne $162817	            BNE CHK_YM2612_P0
.1627f4	a9 00		lda #$00	            LDA #0
.1627f6	eb		xba		            XBA
.1627f7	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627f9	aa		tax		            TAX
.1627fa	c2 20		rep #$20	                REP #$20        ; set A long
.1627fc	e6 84		inc $84		            INC CURRENT_POSITION
.1627fe	d0 02		bne $162802	            BNE increment_done
.162800	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162802					    increment_done
.162802	e2 20		sep #$20	                SEP #$20        ; set A short
.162804	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162806	9f 00 e6 af	sta $afe600,x	            STA @lOPL3_BASE_ADRESS,X
.16280a	c2 20		rep #$20	                REP #$20        ; set A long
.16280c	e6 84		inc $84		            INC CURRENT_POSITION
.16280e	d0 02		bne $162812	            BNE increment_done
.162810	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162812					    increment_done
.162812	e2 20		sep #$20	                SEP #$20        ; set A short
.162814	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162817					        CHK_YM2612_P0
.162817	c9 52		cmp #$52	            CMP #$52
.162819	d0 23		bne $16283e	            BNE CHK_YM2612_P1
.16281b	a9 00		lda #$00	            LDA #0
.16281d	eb		xba		            XBA
.16281e	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162820	aa		tax		            TAX
.162821	c2 20		rep #$20	                REP #$20        ; set A long
.162823	e6 84		inc $84		            INC CURRENT_POSITION
.162825	d0 02		bne $162829	            BNE increment_done
.162827	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162829					    increment_done
.162829	e2 20		sep #$20	                SEP #$20        ; set A short
.16282b	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16282d	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.162831	c2 20		rep #$20	                REP #$20        ; set A long
.162833	e6 84		inc $84		            INC CURRENT_POSITION
.162835	d0 02		bne $162839	            BNE increment_done
.162837	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162839					    increment_done
.162839	e2 20		sep #$20	                SEP #$20        ; set A short
.16283b	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE ; for some reason, this chip needs more time between writes
.16283e					        CHK_YM2612_P1
.16283e	c9 53		cmp #$53	            CMP #$53
.162840	d0 23		bne $162865	            BNE CHK_YM2151
.162842	a9 00		lda #$00	            LDA #0
.162844	eb		xba		            XBA
.162845	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162847	aa		tax		            TAX
.162848	c2 20		rep #$20	                REP #$20        ; set A long
.16284a	e6 84		inc $84		            INC CURRENT_POSITION
.16284c	d0 02		bne $162850	            BNE increment_done
.16284e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162850					    increment_done
.162850	e2 20		sep #$20	                SEP #$20        ; set A short
.162852	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162854	9f 00 f3 af	sta $aff300,x	            STA @lOPN2_BASE_ADDRESS + $100,X
.162858	c2 20		rep #$20	                REP #$20        ; set A long
.16285a	e6 84		inc $84		            INC CURRENT_POSITION
.16285c	d0 02		bne $162860	            BNE increment_done
.16285e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162860					    increment_done
.162860	e2 20		sep #$20	                SEP #$20        ; set A short
.162862	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE ; for some reason, this chip needs more time between writes
.162865					        CHK_YM2151
.162865	c9 54		cmp #$54	            CMP #$54
.162867	d0 23		bne $16288c	            BNE CHK_YM2203
.162869	a9 00		lda #$00	            LDA #0
.16286b	eb		xba		            XBA
.16286c	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16286e	aa		tax		            TAX
.16286f	c2 20		rep #$20	                REP #$20        ; set A long
.162871	e6 84		inc $84		            INC CURRENT_POSITION
.162873	d0 02		bne $162877	            BNE increment_done
.162875	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162877					    increment_done
.162877	e2 20		sep #$20	                SEP #$20        ; set A short
.162879	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16287b	9f 00 f0 af	sta $aff000,x	            STA @lOPM_BASE_ADDRESS,X
.16287f	c2 20		rep #$20	                REP #$20        ; set A long
.162881	e6 84		inc $84		            INC CURRENT_POSITION
.162883	d0 02		bne $162887	            BNE increment_done
.162885	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162887					    increment_done
.162887	e2 20		sep #$20	                SEP #$20        ; set A short
.162889	4c 05 25	jmp $162505	            JMP READ_COMMAND
.16288c					        CHK_YM2203
.16288c	c9 55		cmp #$55	            CMP #$55
.16288e	d0 1f		bne $1628af	            BNE CHK_YM2608_P0
.162890	a9 00		lda #$00	            LDA #0
.162892	eb		xba		            XBA
.162893	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162895	aa		tax		            TAX
.162896	c2 20		rep #$20	                REP #$20        ; set A long
.162898	e6 84		inc $84		            INC CURRENT_POSITION
.16289a	d0 02		bne $16289e	            BNE increment_done
.16289c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16289e					    increment_done
.16289e	e2 20		sep #$20	                SEP #$20        ; set A short
.1628a0	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628a2	c2 20		rep #$20	                REP #$20        ; set A long
.1628a4	e6 84		inc $84		            INC CURRENT_POSITION
.1628a6	d0 02		bne $1628aa	            BNE increment_done
.1628a8	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628aa					    increment_done
.1628aa	e2 20		sep #$20	                SEP #$20        ; set A short
.1628ac	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1628af					        CHK_YM2608_P0
.1628af	c9 56		cmp #$56	            CMP #$56
.1628b1	d0 2a		bne $1628dd	            BNE CHK_YM2608_P1
.1628b3	a9 00		lda #$00	            LDA #0
.1628b5	eb		xba		            XBA
.1628b6	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628b8	c9 10		cmp #$10	            CMP #$10  ; if the register is 0 to $1F, process as SSG
.1628ba	b0 03		bcs $1628bf	            BGE YM2608_FM
.1628bc	4c 25 26	jmp $162625	            JMP AY8910
.1628bf					        YM2608_FM
.1628bf	aa		tax		            TAX
.1628c0	c2 20		rep #$20	                REP #$20        ; set A long
.1628c2	e6 84		inc $84		            INC CURRENT_POSITION
.1628c4	d0 02		bne $1628c8	            BNE increment_done
.1628c6	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628c8					    increment_done
.1628c8	e2 20		sep #$20	                SEP #$20        ; set A short
.1628ca	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628cc	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.1628d0	c2 20		rep #$20	                REP #$20        ; set A long
.1628d2	e6 84		inc $84		            INC CURRENT_POSITION
.1628d4	d0 02		bne $1628d8	            BNE increment_done
.1628d6	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628d8					    increment_done
.1628d8	e2 20		sep #$20	                SEP #$20        ; set A short
.1628da	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1628dd					        CHK_YM2608_P1
.1628dd	c9 57		cmp #$57	            CMP #$57
.1628df	d0 23		bne $162904	            BNE CHK_YM2610_P0
.1628e1	a9 00		lda #$00	            LDA #0
.1628e3	eb		xba		            XBA
.1628e4	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628e6	aa		tax		            TAX
.1628e7	c2 20		rep #$20	                REP #$20        ; set A long
.1628e9	e6 84		inc $84		            INC CURRENT_POSITION
.1628eb	d0 02		bne $1628ef	            BNE increment_done
.1628ed	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628ef					    increment_done
.1628ef	e2 20		sep #$20	                SEP #$20        ; set A short
.1628f1	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628f3	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.1628f7	c2 20		rep #$20	                REP #$20        ; set A long
.1628f9	e6 84		inc $84		            INC CURRENT_POSITION
.1628fb	d0 02		bne $1628ff	            BNE increment_done
.1628fd	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628ff					    increment_done
.1628ff	e2 20		sep #$20	                SEP #$20        ; set A short
.162901	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162904					        CHK_YM2610_P0
.162904	c9 58		cmp #$58	            CMP #$58
.162906	d0 2a		bne $162932	            BNE CHK_YM2610_P1
.162908	a9 00		lda #$00	            LDA #0
.16290a	eb		xba		            XBA
.16290b	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16290d	c9 10		cmp #$10	            CMP #$10  ; if the register is 0 to $1F, process as SSG
.16290f	b0 03		bcs $162914	            BGE YM2610_FM
.162911	4c 25 26	jmp $162625	            JMP AY8910
.162914					        YM2610_FM
.162914	aa		tax		            TAX
.162915	c2 20		rep #$20	                REP #$20        ; set A long
.162917	e6 84		inc $84		            INC CURRENT_POSITION
.162919	d0 02		bne $16291d	            BNE increment_done
.16291b	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16291d					    increment_done
.16291d	e2 20		sep #$20	                SEP #$20        ; set A short
.16291f	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162921	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.162925	c2 20		rep #$20	                REP #$20        ; set A long
.162927	e6 84		inc $84		            INC CURRENT_POSITION
.162929	d0 02		bne $16292d	            BNE increment_done
.16292b	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16292d					    increment_done
.16292d	e2 20		sep #$20	                SEP #$20        ; set A short
.16292f	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162932					        CHK_YM2610_P1
.162932	c9 59		cmp #$59	            CMP #$59
.162934	d0 23		bne $162959	            BNE CHK_YM3812
.162936	a9 00		lda #$00	            LDA #0
.162938	eb		xba		            XBA
.162939	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16293b	aa		tax		            TAX
.16293c	c2 20		rep #$20	                REP #$20        ; set A long
.16293e	e6 84		inc $84		            INC CURRENT_POSITION
.162940	d0 02		bne $162944	            BNE increment_done
.162942	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162944					    increment_done
.162944	e2 20		sep #$20	                SEP #$20        ; set A short
.162946	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162948	9f 00 f3 af	sta $aff300,x	            STA @lOPN2_BASE_ADDRESS + $100,X
.16294c	c2 20		rep #$20	                REP #$20        ; set A long
.16294e	e6 84		inc $84		            INC CURRENT_POSITION
.162950	d0 02		bne $162954	            BNE increment_done
.162952	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162954					    increment_done
.162954	e2 20		sep #$20	                SEP #$20        ; set A short
.162956	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162959					        CHK_YM3812
.162959	c9 5a		cmp #$5a	            CMP #$5A
.16295b	d0 23		bne $162980	            BNE CHK_YM262_P0
.16295d	a9 00		lda #$00	            LDA #0
.16295f	eb		xba		            XBA
.162960	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162962	aa		tax		            TAX
.162963	c2 20		rep #$20	                REP #$20        ; set A long
.162965	e6 84		inc $84		            INC CURRENT_POSITION
.162967	d0 02		bne $16296b	            BNE increment_done
.162969	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16296b					    increment_done
.16296b	e2 20		sep #$20	                SEP #$20        ; set A short
.16296d	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16296f	9f 00 e6 af	sta $afe600,x	            STA @lOPL3_BASE_ADRESS,X
.162973	c2 20		rep #$20	                REP #$20        ; set A long
.162975	e6 84		inc $84		            INC CURRENT_POSITION
.162977	d0 02		bne $16297b	            BNE increment_done
.162979	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16297b					    increment_done
.16297b	e2 20		sep #$20	                SEP #$20        ; set A short
.16297d	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162980					        CHK_YM262_P0
.162980	c9 5e		cmp #$5e	            CMP #$5E
.162982	d0 23		bne $1629a7	            BNE CHK_YM262_P1
.162984	a9 00		lda #$00	            LDA #0
.162986	eb		xba		            XBA
.162987	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162989	aa		tax		            TAX
.16298a	c2 20		rep #$20	                REP #$20        ; set A long
.16298c	e6 84		inc $84		            INC CURRENT_POSITION
.16298e	d0 02		bne $162992	            BNE increment_done
.162990	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162992					    increment_done
.162992	e2 20		sep #$20	                SEP #$20        ; set A short
.162994	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162996	9f 00 e6 af	sta $afe600,x	            STA @lOPL3_BASE_ADRESS,X
.16299a	c2 20		rep #$20	                REP #$20        ; set A long
.16299c	e6 84		inc $84		            INC CURRENT_POSITION
.16299e	d0 02		bne $1629a2	            BNE increment_done
.1629a0	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629a2					    increment_done
.1629a2	e2 20		sep #$20	                SEP #$20        ; set A short
.1629a4	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1629a7					        CHK_YM262_P1
.1629a7	c9 5f		cmp #$5f	            CMP #$5F
.1629a9	d0 20		bne $1629cb	            BNE YM_DONE
.1629ab	a9 00		lda #$00	            LDA #0
.1629ad	eb		xba		            XBA
.1629ae	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1629b0	aa		tax		            TAX
.1629b1	c2 20		rep #$20	                REP #$20        ; set A long
.1629b3	e6 84		inc $84		            INC CURRENT_POSITION
.1629b5	d0 02		bne $1629b9	            BNE increment_done
.1629b7	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629b9					    increment_done
.1629b9	e2 20		sep #$20	                SEP #$20        ; set A short
.1629bb	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1629bd	9f 00 e7 af	sta $afe700,x	            STA @lOPL3_BASE_ADRESS+ $100,X
.1629c1	c2 20		rep #$20	                REP #$20        ; set A long
.1629c3	e6 84		inc $84		            INC CURRENT_POSITION
.1629c5	d0 02		bne $1629c9	            BNE increment_done
.1629c7	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629c9					    increment_done
.1629c9	e2 20		sep #$20	                SEP #$20        ; set A short
.1629cb					    YM_DONE
.1629cb	4c 05 25	jmp $162505	            JMP READ_COMMAND
.1629ce					WAIT_COMMANDS
.1629ce	a5 7f		lda $7f		            LDA COMMAND
.1629d0	c9 61		cmp #$61	            CMP #$61
.1629d2	d0 20		bne $1629f4	            BNE CHK_WAIT_60th
.1629d4	c2 20		rep #$20	                REP #$20        ; set A long
.1629d6	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1629d8	aa		tax		            TAX
.1629d9	86 88		stx $88		            STX WAIT_CNTR
.1629db	e2 20		sep #$20	                SEP #$20        ; set A short
.1629dd	c2 20		rep #$20	                REP #$20        ; set A long
.1629df	e6 84		inc $84		            INC CURRENT_POSITION
.1629e1	d0 02		bne $1629e5	            BNE increment_done
.1629e3	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629e5					    increment_done
.1629e5	e2 20		sep #$20	                SEP #$20        ; set A short
.1629e7	c2 20		rep #$20	                REP #$20        ; set A long
.1629e9	e6 84		inc $84		            INC CURRENT_POSITION
.1629eb	d0 02		bne $1629ef	            BNE increment_done
.1629ed	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629ef					    increment_done
.1629ef	e2 20		sep #$20	                SEP #$20        ; set A short
.1629f1	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE
.1629f4					        CHK_WAIT_60th
.1629f4	c9 62		cmp #$62	            CMP #$62
.1629f6	d0 08		bne $162a00	            BNE CHK_WAIT_50th
.1629f8	a2 df 02	ldx #$02df	            LDX #$2df
.1629fb	86 88		stx $88		            STX WAIT_CNTR
.1629fd	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE
.162a00					        CHK_WAIT_50th
.162a00	c9 63		cmp #$63	            CMP #$63
.162a02	d0 08		bne $162a0c	            BNE CHK_END_SONG
.162a04	a2 72 03	ldx #$0372	            LDX #$372
.162a07	86 88		stx $88		            STX WAIT_CNTR
.162a09	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE
.162a0c					        CHK_END_SONG
.162a0c	c9 66		cmp #$66	            CMP #$66 ; end of song
.162a0e	d0 06		bne $162a16	            BNE CHK_DATA_BLOCK
.162a10	20 af 2a	jsr $162aaf	            JSR VGM_SET_LOOP_POINTERS
.162a13	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE
.162a16					        CHK_DATA_BLOCK
.162a16	c9 67		cmp #$67	            CMP #$67
.162a18	d0 03		bne $162a1d	            BNE DONE_WAIT
.162a1a	20 4d 2b	jsr $162b4d	            JSR READ_DATA_BLOCK
.162a1d					    DONE_WAIT
.162a1d	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE
.162a20					WAIT_N_1
.162a20	a9 00		lda #$00	            LDA #0
.162a22	eb		xba		            XBA
.162a23	a5 7f		lda $7f		            LDA COMMAND
.162a25	29 0f		and #$0f	            AND #$F
.162a27	aa		tax		            TAX
.162a28	e8		inx		            INX ; $7n where we wait n+1
.162a29	86 88		stx $88		            STX WAIT_CNTR
.162a2b	4c 1f 25	jmp $16251f	            JMP VGM_LOOP_DONE
.162a2e					YM2612_SAMPLE
.162a2e	a7 8a		lda [$8a]	            LDA [PCM_OFFSET]
.162a30	8f 2a f2 af	sta $aff22a	            STA OPN2_BASE_ADDRESS + $2A
.162a34	c2 20		rep #$20	                REP #$20        ; set A long
.162a36	a5 8a		lda $8a		            LDA PCM_OFFSET
.162a38	1a		inc a		            INC A
.162a39	85 8a		sta $8a		            STA PCM_OFFSET
.162a3b	90 05		bcc $162a42	            BCC YMS_WAIT
.162a3d	a5 8c		lda $8c		            LDA PCM_OFFSET + 2
.162a3f	1a		inc a		            INC A
.162a40	85 8c		sta $8c		            STA PCM_OFFSET + 2
.162a42					    YMS_WAIT
.162a42	e2 20		sep #$20	                SEP #$20        ; set A short
.162a44	a9 00		lda #$00	            LDA #0
.162a46	eb		xba		            XBA
.162a47	a5 7f		lda $7f		            LDA COMMAND
.162a49	29 0f		and #$0f	            AND #$F
.162a4b	aa		tax		            TAX
.162a4c	86 88		stx $88		            STX WAIT_CNTR
.162a4e					    YMS_NOT_ZERO
.162a4e	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162a51					DAC_STREAM
.162a51	4c 05 25	jmp $162505	            JMP READ_COMMAND
.162a54					VGM_SET_SONG_POINTERS
.162a54	c2 20		rep #$20	                REP #$20        ; set A long
.162a56	a9 76 22	lda #$2276	            LDA #<>RESET_MSG
.162a59	85 7a		sta $7a		            STA MSG_PTR
.162a5b	e2 20		sep #$20	                SEP #$20        ; set A short
.162a5d	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162a60	c2 20		rep #$20	                REP #$20        ; set A long
.162a62	a9 00 00	lda #$0000	            LDA #0
.162a65	85 88		sta $88		            STA WAIT_CNTR
.162a67	a5 82		lda $82		            LDA SONG_START + 2
.162a69	85 86		sta $86		            STA CURRENT_POSITION + 2
.162a6b	e2 20		sep #$20	                SEP #$20        ; set A short
.162a6d	a5 77		lda $77		            LDA MIN_VERSION
.162a6f	c9 50		cmp #$50	            CMP #$50
.162a71	90 2b		bcc $162a9e	            BLT OLD_VERSION
.162a73	c2 20		rep #$20	                REP #$20        ; set A long
.162a75	18		clc		            CLC
.162a76	a0 34 00	ldy #$0034	            LDY #VGM_OFFSET
.162a79	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162a7b	69 34 00	adc #$0034	            ADC #VGM_OFFSET
.162a7e	65 80		adc $80		            ADC SONG_START
.162a80	85 84		sta $84		            STA CURRENT_POSITION
.162a82	90 02		bcc $162a86	            BCC VSP_DONE
.162a84	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162a86					    VSP_DONE
.162a86	18		clc		            CLC
.162a87	a0 14 00	ldy #$0014	            LDY #GD3_OFFSET
.162a8a	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162a8c	69 14 00	adc #$0014	            ADC #GD3_OFFSET
.162a8f	65 80		adc $80		            ADC SONG_START
.162a91	85 8e		sta $8e		            STA GD3_POSITION
.162a93	c8		iny		            INY
.162a94	c8		iny		            INY
.162a95	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162a97	65 82		adc $82		            ADC SONG_START + 2
.162a99	85 90		sta $90		            STA GD3_POSITION + 2
.162a9b	e2 20		sep #$20	                SEP #$20        ; set A short
.162a9d	60		rts		            RTS
.162a9e					    OLD_VERSION
.162a9e	c2 20		rep #$20	                REP #$20        ; set A long
.162aa0	18		clc		            CLC
.162aa1	a9 40 00	lda #$0040	            LDA #$40
.162aa4	65 80		adc $80		            ADC SONG_START
.162aa6	85 84		sta $84		            STA CURRENT_POSITION
.162aa8	90 02		bcc $162aac	            BCC VSP_OLD_DONE
.162aaa	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162aac					    VSP_OLD_DONE
.162aac	e2 20		sep #$20	                SEP #$20        ; set A short
.162aae	60		rts		            RTS
.162aaf					VGM_SET_LOOP_POINTERS
.162aaf	0b		phd		            PHD
.162ab0	8b		phb		            PHB
.162ab1	a9 00		lda #$00	            LDA #0
.162ab3	48		pha		            PHA
.162ab4	ab		plb		            PLB
.162ab5	c2 20		rep #$20	                REP #$20        ; set A long
.162ab7	a9 00 00	lda #$0000	            LDA #0
.162aba	5b		tcd		            TCD  ; reset the direct page.
.162abb	85 88		sta $88		            STA WAIT_CNTR
.162abd	18		clc		            CLC
.162abe	a0 1c 00	ldy #$001c	            LDY #LOOP_OFFSET
.162ac1	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162ac3	f0 2f		beq $162af4	            BEQ NO_LOOP_INFO ; if this is zero, assume that the upper word is also 0
.162ac5	69 1c 00	adc #$001c	            ADC #LOOP_OFFSET ; add the current position
.162ac8	8d 20 01	sta $0120	            STA ADDER_A
.162acb	c8		iny		            INY
.162acc	c8		iny		            INY
.162acd	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162acf	8d 22 01	sta $0122	            STA ADDER_A + 2
.162ad2	a9 87 22	lda #$2287	            LDA #<>LOOPING_MSG
.162ad5	85 7a		sta $7a		            STA MSG_PTR
.162ad7	e2 20		sep #$20	                SEP #$20        ; set A short
.162ad9	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162adc	c2 20		rep #$20	                REP #$20        ; set A long
.162ade	a5 80		lda $80		            LDA SONG_START
.162ae0	8d 24 01	sta $0124	            STA ADDER_B
.162ae3	a5 82		lda $82		            LDA SONG_START + 2
.162ae5	8d 26 01	sta $0126	            STA ADDER_B + 2
.162ae8	ad 28 01	lda $0128	            LDA ADDER_R
.162aeb	85 84		sta $84		            STA CURRENT_POSITION
.162aed	ad 2a 01	lda $012a	            LDA ADDER_R + 2
.162af0	85 86		sta $86		            STA CURRENT_POSITION + 2
.162af2	80 20		bra $162b14	            BRA VSL_DONE
.162af4					    NO_LOOP_INFO
.162af4	a9 76 22	lda #$2276	            LDA #<>RESET_MSG
.162af7	85 7a		sta $7a		            STA MSG_PTR
.162af9	e2 20		sep #$20	                SEP #$20        ; set A short
.162afb	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162afe	c2 20		rep #$20	                REP #$20        ; set A long
.162b00	a0 34 00	ldy #$0034	            LDY #VGM_OFFSET
.162b03	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162b05	69 34 00	adc #$0034	            ADC #VGM_OFFSET
.162b08	65 80		adc $80		            ADC SONG_START
.162b0a	85 84		sta $84		            STA CURRENT_POSITION
.162b0c	a5 82		lda $82		            LDA SONG_START + 2
.162b0e	85 86		sta $86		            STA CURRENT_POSITION + 2
.162b10	90 02		bcc $162b14	            BCC VSL_DONE
.162b12	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b14					    VSL_DONE
.162b14	e2 20		sep #$20	                SEP #$20        ; set A short
.162b16	ab		plb		            PLB
.162b17	2b		pld		            PLD
.162b18	60		rts		            RTS
.162b19					VGM_INIT_TIMER0
.162b19	c2 20		rep #$20	                REP #$20        ; set A long
.162b1b	a9 ee 24	lda #$24ee	            LDA #<>VGM_WRITE_REGISTER
.162b1e	8d 09 17	sta $1709	            STA VEC_INT02_TMR0 + 1
.162b21	e2 20		sep #$20	                SEP #$20        ; set A short
.162b23	a9 16		lda #$16	            LDA #`VGM_WRITE_REGISTER
.162b25	8d 0b 17	sta $170b	            STA VEC_INT02_TMR0 + 3
.162b28	a9 44		lda #$44	            LDA #$44
.162b2a	8d 65 01	sta $0165	            STA TIMER0_CMP_L
.162b2d	a9 01		lda #$01	            LDA #1
.162b2f	8d 66 01	sta $0166	            STA TIMER0_CMP_M
.162b32	a9 00		lda #$00	            LDA #0
.162b34	8d 67 01	sta $0167	            STA TIMER0_CMP_H
.162b37	a9 00		lda #$00	            LDA #0    ; set timer0 charge to 0
.162b39	8d 61 01	sta $0161	            STA TIMER0_CHARGE_L
.162b3c	8d 62 01	sta $0162	            STA TIMER0_CHARGE_M
.162b3f	8d 63 01	sta $0163	            STA TIMER0_CHARGE_H
.162b42	a9 01		lda #$01	            LDA #TMR0_CMP_RECLR  ; count up from "CHARGE" value to TIMER_CMP
.162b44	8d 64 01	sta $0164	            STA TIMER0_CMP_REG
.162b47	a9 0b		lda #$0b	            LDA #(TMR0_EN | TMR0_UPDWN | TMR0_SCLR)
.162b49	8d 60 01	sta $0160	            STA TIMER0_CTRL_REG
.162b4c	60		rts		            RTS
.162b4d					READ_DATA_BLOCK
.162b4d	0b		phd		            PHD
.162b4e	8b		phb		            PHB
.162b4f	a9 00		lda #$00	            LDA #0
.162b51	48		pha		            PHA
.162b52	ab		plb		            PLB  ; reset bank
.162b53	c2 20		rep #$20	                REP #$20        ; set A long
.162b55	a9 00 00	lda #$0000	            LDA #0
.162b58	5b		tcd		            TCD  ; reset direct reg
.162b59	a9 95 22	lda #$2295	            LDA #<>DATA_BLOCK_MSG
.162b5c	85 7a		sta $7a		            STA MSG_PTR
.162b5e	e2 20		sep #$20	                SEP #$20        ; set A short
.162b60	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162b63	a7 84		lda [$84]	            LDA [CURRENT_POSITION] ; should be 66
.162b65	c2 20		rep #$20	                REP #$20        ; set A long
.162b67	e6 84		inc $84		            INC CURRENT_POSITION
.162b69	d0 02		bne $162b6d	            BNE increment_done
.162b6b	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b6d					    increment_done
.162b6d	e2 20		sep #$20	                SEP #$20        ; set A short
.162b6f	a7 84		lda [$84]	            LDA  [CURRENT_POSITION] ; should be the type - I expect $C0
.162b71	48		pha		            PHA
.162b72	c2 20		rep #$20	                REP #$20        ; set A long
.162b74	e6 84		inc $84		            INC CURRENT_POSITION
.162b76	d0 02		bne $162b7a	            BNE increment_done
.162b78	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b7a					    increment_done
.162b7a	e2 20		sep #$20	                SEP #$20        ; set A short
.162b7c	c2 20		rep #$20	                REP #$20        ; set A long
.162b7e	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162b80	8d 20 01	sta $0120	            STA ADDER_A
.162b83	c2 20		rep #$20	                REP #$20        ; set A long
.162b85	e6 84		inc $84		            INC CURRENT_POSITION
.162b87	d0 02		bne $162b8b	            BNE increment_done
.162b89	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b8b					    increment_done
.162b8b	e2 20		sep #$20	                SEP #$20        ; set A short
.162b8d	c2 20		rep #$20	                REP #$20        ; set A long
.162b8f	e6 84		inc $84		            INC CURRENT_POSITION
.162b91	d0 02		bne $162b95	            BNE increment_done
.162b93	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b95					    increment_done
.162b95	e2 20		sep #$20	                SEP #$20        ; set A short
.162b97	c2 20		rep #$20	                REP #$20        ; set A long
.162b99	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162b9b	8d 22 01	sta $0122	            STA ADDER_A + 2
.162b9e	c2 20		rep #$20	                REP #$20        ; set A long
.162ba0	e6 84		inc $84		            INC CURRENT_POSITION
.162ba2	d0 02		bne $162ba6	            BNE increment_done
.162ba4	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162ba6					    increment_done
.162ba6	e2 20		sep #$20	                SEP #$20        ; set A short
.162ba8	c2 20		rep #$20	                REP #$20        ; set A long
.162baa	e6 84		inc $84		            INC CURRENT_POSITION
.162bac	d0 02		bne $162bb0	            BNE increment_done
.162bae	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162bb0					    increment_done
.162bb0	e2 20		sep #$20	                SEP #$20        ; set A short
.162bb2	c2 20		rep #$20	                REP #$20        ; set A long
.162bb4	a5 84		lda $84		            LDA CURRENT_POSITION
.162bb6	8d 24 01	sta $0124	            STA ADDER_B
.162bb9	a5 86		lda $86		            LDA CURRENT_POSITION + 2
.162bbb	8d 26 01	sta $0126	            STA ADDER_B + 2
.162bbe	ad 28 01	lda $0128	            LDA ADDER_R
.162bc1	85 84		sta $84		            STA CURRENT_POSITION
.162bc3	ad 2a 01	lda $012a	            LDA ADDER_R + 2
.162bc6	85 86		sta $86		            STA CURRENT_POSITION + 2
.162bc8	e2 20		sep #$20	                SEP #$20        ; set A short
.162bca	68		pla		            PLA
.162bcb	f0 04		beq $162bd1	            BEQ UNCOMPRESSED
.162bcd	c9 c0		cmp #$c0	            CMP #$C0
.162bcf	d0 17		bne $162be8	            BNE UNKNOWN_DATA_BLOCK
.162bd1					    UNCOMPRESSED
.162bd1	c2 20		rep #$20	                REP #$20        ; set A long
.162bd3	a5 7d		lda $7d		            LDA DATA_STREAM_CNT ; multiply by 4
.162bd5	0a		asl a		            ASL A
.162bd6	0a		asl a		            ASL A
.162bd7	aa		tax		            TAX
.162bd8	ad 24 01	lda $0124	            LDA ADDER_B
.162bdb	9d 00 80	sta $8000,x	            STA DATA_STREAM_TBL,X
.162bde	ad 26 01	lda $0126	            LDA ADDER_B + 2
.162be1	9d 02 80	sta $8002,x	            STA DATA_STREAM_TBL,X + 2
.162be4	e6 7d		inc $7d		            INC DATA_STREAM_CNT
.162be6	e2 20		sep #$20	                SEP #$20        ; set A short
.162be8					    UNKNOWN_DATA_BLOCK
.162be8	ab		plb		            PLB
.162be9	2b		pld		            PLD
.162bea	60		rts		            RTS
.162beb					VGM_DISPLAY_GD3
.162beb	a0 00 00	ldy #$0000	            LDY #0
.162bee	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bf0	c9 47		cmp #$47	            CMP #'G'
.162bf2	d0 43		bne $162c37	            BNE GD3_ERROR
.162bf4	c8		iny		            INY
.162bf5	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bf7	c9 64		cmp #$64	            CMP #'d'
.162bf9	d0 3c		bne $162c37	            BNE GD3_ERROR
.162bfb	c8		iny		            INY
.162bfc	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bfe	c9 33		cmp #$33	            CMP #'3'
.162c00	d0 35		bne $162c37	            BNE GD3_ERROR
.162c02	c8		iny		            INY
.162c03	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c05	c9 20		cmp #$20	            CMP #' '
.162c07	d0 2e		bne $162c37	            BNE GD3_ERROR
.162c09	c8		iny		            INY
.162c0a	c2 20		rep #$20	                REP #$20        ; set A long
.162c0c	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c0e	c9 00 01	cmp #$0100	            CMP #$100
.162c11	d0 24		bne $162c37	            BNE GD3_ERROR
.162c13	c8		iny		            INY
.162c14	c8		iny		            INY
.162c15	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c17	d0 1e		bne $162c37	            BNE GD3_ERROR
.162c19	e2 20		sep #$20	                SEP #$20        ; set A short
.162c1b	c8		iny		            INY
.162c1c	c8		iny		            INY
.162c1d	c8		iny		            INY  ; skip the length
.162c1e	c8		iny		            INY
.162c1f	c8		iny		            INY
.162c20	c8		iny		            INY
.162c21	20 42 2c	jsr $162c42	            JSR DISPLAY_MSG_16  ; display the track name in English
.162c24	20 6b 2c	jsr $162c6b	            JSR DISCARD_16      ; discard the track name in Japanese
.162c27	20 6b 2c	jsr $162c6b	            JSR DISCARD_16      ; discard the game name in English
.162c2a	20 6b 2c	jsr $162c6b	            JSR DISCARD_16      ; discard the game name in Japanese
.162c2d	20 6b 2c	jsr $162c6b	            JSR DISCARD_16      ; discard the system name in English
.162c30	20 6b 2c	jsr $162c6b	            JSR DISCARD_16      ; discard the system name in Japanese
.162c33	20 42 2c	jsr $162c42	            JSR DISPLAY_MSG_16  ; display the author's name in English
.162c36	60		rts		            RTS
.162c37					GD3_ERROR
.162c37	e2 20		sep #$20	                SEP #$20        ; set A short
.162c39	a2 2c 23	ldx #$232c	            LDX #<>GD3_ERR_MSG
.162c3c	86 7a		stx $7a		            STX MSG_PTR
.162c3e	20 7e 24	jsr $16247e	            JSR DISPLAY_MSG
.162c41	60		rts		            RTS
.162c42					DISPLAY_MSG_16
.162c42	a6 78		ldx $78		            LDX DISPLAY_OFFSET
.162c44					    DM16_LOOP
.162c44	e2 20		sep #$20	                SEP #$20        ; set A short
.162c46	a9 2d		lda #$2d	            LDA #$2D   ; Text color
.162c48	9f 00 20 af	sta $af2000,x	            STA $AF2000,X  ; offset to Text LUT $AF:C000
.162c4c	c2 20		rep #$20	                REP #$20        ; set A long
.162c4e	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c50	e2 20		sep #$20	                SEP #$20        ; set A short
.162c52	9f 00 00 af	sta $af0000,x	            STA $AF0000,X  ; offset to Text LUT $AF:C000
.162c56	c8		iny		            INY
.162c57	c8		iny		            INY
.162c58	e8		inx		            INX
.162c59	c2 20		rep #$20	                REP #$20        ; set A long
.162c5b	c9 00 00	cmp #$0000	            CMP #0
.162c5e	d0 e4		bne $162c44	            BNE DM16_LOOP
.162c60	a5 78		lda $78		            LDA DISPLAY_OFFSET
.162c62	18		clc		            CLC
.162c63	69 50 00	adc #$0050	            ADC #80 ; 80 columns in 640x480 mode
.162c66	85 78		sta $78		            STA DISPLAY_OFFSET
.162c68	e2 20		sep #$20	                SEP #$20        ; set A short
.162c6a	60		rts		            RTS
.162c6b					DISCARD_16
.162c6b	c2 20		rep #$20	                REP #$20        ; set A long
.162c6d					    DIS_LOOP
.162c6d	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c6f	c8		iny		            INY
.162c70	c8		iny		            INY
.162c71	c9 00 00	cmp #$0000	            CMP #0
.162c74	d0 f7		bne $162c6d	            BNE DIS_LOOP
.162c76	e2 20		sep #$20	                SEP #$20        ; set A short
.162c78	60		rts		            RTS

;******  End of listing
