
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass.exe --long-address -x --intel-hex -o vgm-player.hex --list vgm-player.lst vgm-player.asm
; Sun Sep 27 15:37:01 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: vgm-player.asm


;******  Processing file: macros_inc.asm


;******  Return to file: vgm-player.asm


;******  Processing file: bank_00_inc.asm

=$000000				BANK0_BEGIN      = $000000 ;Start of bank 0 and Direct page
=$000000				TMPPTR1          = $000000 ; 4 byte temporary pointer
=$000004				TMPPTR2          = $000004 ; 4 byte temporary pointer
=$000008				OPL2_ADDY_PTR_LO = $000008 ; THis Points towards the Instruments Database
=$000009				OPL2_ADDY_PTR_MD = $000009
=$00000a				OPL2_ADDY_PTR_HI = $00000A
=$00000c				SCREENBEGIN      = $00000C ;3 Bytes Start of screen in video RAM. This is the upper-left corrner of the current video page being written to. This may not be what's being displayed by VICKY. Update this if you change VICKY's display page.
=$00000f				COLS_VISIBLE     = $00000F ;2 Bytes Columns visible per screen line. A virtual line can be longer than displayed, up to COLS_PER_LINE long. Default = 80
=$000011				COLS_PER_LINE    = $000011 ;2 Bytes Columns in memory per screen line. A virtual line can be this long. Default=128
=$000013				LINES_VISIBLE    = $000013 ;2 Bytes The number of rows visible on the screen. Default=25
=$000015				LINES_MAX        = $000015 ;2 Bytes The number of rows in memory for the screen. Default=64
=$000017				CURSORPOS        = $000017 ;3 Bytes The next character written to the screen will be written in this location.
=$00001a				CURSORX          = $00001A ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001c				CURSORY          = $00001C ;2 Bytes This is where the blinking cursor sits. Do not edit this direectly. Call LOCATE to update the location and handle moving the cursor correctly.
=$00001e				CURCOLOR         = $00001E ;1 Byte Color of next character to be printed to the screen.
=$00001f				COLORPOS         = $00001F ;3 Byte address of cursor's position in the color matrix
=$000022				STACKBOT         = $000022 ;2 Bytes Lowest location the stack should be allowed to write to. If SP falls below this value, the runtime should generate STACK OVERFLOW error and abort.
=$000024				STACKTOP         = $000024 ;2 Bytes Highest location the stack can occupy. If SP goes above this value, the runtime should generate STACK OVERFLOW error and abort.
=$000026				OPL2_OPERATOR    = $000026 ;
=$000027				OPL2_CHANNEL     = $000027 ;
=$000028				OPL2_REG_REGION  = $000028 ; Offset to the Group of Registers
=$00002a				OPL2_REG_OFFSET  = $00002A ; 2 Bytes (16Bits)
=$00002c				OPL2_IND_ADDY_LL = $00002C ; 2 Bytes Reserved (Only need 3)
=$00002e				OPL2_IND_ADDY_HL = $00002E ; 2 Bytes Reserved (Only need 3)
=$000030				OPL2_NOTE        = $000030 ; 1 Byte
=$000031				OPL2_OCTAVE      = $000031 ; 1 Byte
=$000032				OPL2_PARAMETER0  = $000032 ; 1 Byte - Key On/Feedback
=$000033				OPL2_PARAMETER1  = $000033 ; 1 Byte
=$000034				OPL2_PARAMETER2  = $000034 ; 1 Byte
=$000035				OPL2_PARAMETER3  = $000035 ; 1 Byte
=$000036				OPL2_LOOP        = $000036 ;
=$000036				OPL2_BLOCK       = $000036
=$000038				SDCARD_FILE_PTR  = $000038 ; 3 Bytes Pointer to Filename to open
=$00003c				SDCARD_BYTE_NUM  = $00003C ; 2Bytes
=$00003f				SDCARD_PRSNT_MNT = $00003F ; 1 Byte, Indicate that the SDCard is Present and that it is Mounted
=$000040				BM_CLEAR_SCRN_X  = $000040
=$000042				BM_CLEAR_SCRN_Y  = $000042
=$000040				RAD_STARTLINE    = $000040 ; 1 Byte
=$000041				RAD_PATTERN_IDX  = $000041 ; 1 Byte
=$000042				RAD_LINE         = $000042 ; 1 Byte
=$000043				RAD_LINENUMBER   = $000043 ; 1 Byte
=$000044				RAD_CHANNEL_NUM  = $000044 ; 1 Byte
=$000045				RAD_ISLASTCHAN   = $000045 ; 1 Byte
=$000046				RAD_Y_POINTER    = $000046 ; 2 Bytes
=$000048				RAD_TICK         = $000048
=$00004a				RAD_CHANNEL_DATA = $00004A ; 2 Bytes
=$00004c				RAD_CHANNE_EFFCT = $00004C
=$00004d				RAD_TEMP         = $00004D
=$000050				RAD_ADDR         = $000050 ; 3 bytes to avoid OPL2 errors.
=$000053				RAD_PATTRN       = $000053 ; 1 bytes - offset to patter
=$000054				RAD_PTN_DEST     = $000054 ; 3 bytes - where to write the pattern data
=$000057				RAD_CHANNEL      = $000057 ; 2 bytes - 0 to 8
=$000059				RAD_LAST_NOTE    = $000059 ; 1 if this is the last note
=$00005a				RAD_LINE_PTR     = $00005A ; 2 bytes - offset to memory location
=$000040				BMP_X_SIZE       = $000040 ; 2 Bytes
=$000042				BMP_Y_SIZE       = $000042 ; 2 Bytes
=$000044				BMP_PRSE_SRC_PTR = $000044 ; 3 Bytes
=$000048				BMP_PRSE_DST_PTR = $000048 ; 3 Bytes
=$00004c				BMP_COLOR_PALET  = $00004C ; 2 Bytes
=$00004e				SCRN_X_STRIDE    = $00004E ; 2 Bytes, Basically How many Pixel Accross in Bitmap Mode
=$000050				BMP_FILE_SIZE    = $000050 ; 4 Bytes
=$000054				BMP_POSITION_X   = $000054 ; 2 Bytes Where, the BMP will be position on the X Axis
=$000056				BMP_POSITION_Y   = $000056 ; 2 Bytes Where, the BMP will be position on the Y Axis
=$000058				BMP_PALET_CHOICE = $000058 ;
=$0000e0				MOUSE_PTR        = $0000E0
=$0000e1				MOUSE_POS_X_LO   = $0000E1
=$0000e2				MOUSE_POS_X_HI   = $0000E2
=$0000e3				MOUSE_POS_Y_LO   = $0000E3
=$0000e4				MOUSE_POS_Y_HI   = $0000E4
=$0000f0				USER_TEMP        = $0000F0 ;32 Bytes Temp space for user programs
=$000100				GAVIN_BLOCK      = $000100 ;256 Bytes Gavin reserved, overlaps debugging registers at $1F0
=$000140				INT_CONTROLLER   = $000140 ; $000140...$00015F Interrupt Controller
=$000160				TIMER_CONTROLLER = $000160 ; $000160...$00017F Timer0/Timer1/Timer2 Block
=$000160				TIMER_CTRL_REGLL = $000160 ;
=$000161				TIMER_CTRL_REGLH = $000161 ;
=$000162				TIMER_CTRL_REGHL = $000162 ;
=$000163				TIMER_CTRL_REGHH = $000163 ;
=$000240				CPU_REGISTERS    = $000240 ; Byte
=$000240				CPUPC            = $000240 ;2 Bytes Program Counter (PC)
=$000242				CPUPBR           = $000242 ;2 Bytes Program Bank Register (K)
=$000244				CPUA             = $000244 ;2 Bytes Accumulator (A)
=$000246				CPUX             = $000246 ;2 Bytes X Register (X)
=$000248				CPUY             = $000248 ;2 Bytes Y Register (Y)
=$00024a				CPUSTACK         = $00024A ;2 Bytes Stack Pointer (S)
=$00024c				CPUDP            = $00024C ;2 Bytes Direct Page Register (D)
=$00024e				CPUDBR           = $00024E ;1 Byte  Data Bank Register (B)
=$00024f				CPUFLAGS         = $00024F ;1 Byte  Flags (P)
=$000250				MONITOR_VARS     = $000250 ; Byte  MONITOR Variables. BASIC variables may overlap this space
=$000250				MCMDADDR         = $000250 ;3 Bytes Address of the current line of text being processed by the command parser. Can be in display memory or a variable in memory. MONITOR will parse up to MTEXTLEN characters or to a null character.
=$000253				MCMP_TEXT        = $000253 ;3 Bytes Address of symbol being evaluated for COMPARE routine
=$000256				MCMP_LEN         = $000256 ;2 Bytes Length of symbol being evaluated for COMPARE routine
=$000258				MCMD             = $000258 ;3 Bytes Address of the current command/function string
=$00025b				MCMD_LEN         = $00025B ;2 Bytes Length of the current command/function string
=$00025d				MARG1            = $00025D ;4 Bytes First command argument. May be data or address, depending on command
=$000261				MARG2            = $000261 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000265				MARG3            = $000265 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000269				MARG4            = $000269 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$00026d				MARG5            = $00026D ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000271				MARG6            = $000271 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000275				MARG7            = $000275 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000279				MARG8            = $000279 ;4 Bytes First command argument. May be data or address, depending on command. Data is 32-bit number. Address is 24-bit address and 8-bit length.
=$000300				LOADFILE_VARS    = $000300 ; Byte
=$000300				LOADFILE_NAME    = $000300 ;3 Bytes (addr) Name of file to load. Address in Data Page
=$000303				LOADFILE_LEN     = $000303 ;1 Byte  Length of filename. 0=Null Terminated
=$000304				LOADPBR          = $000304 ;1 Byte  First Program Bank of loaded file ($05 segment)
=$000305				LOADPC           = $000305 ;2 Bytes Start address of loaded file ($05 segment)
=$000307				LOADDBR          = $000307 ;1 Byte  First data bank of loaded file ($06 segment)
=$000308				LOADADDR         = $000308 ;2 Bytes FIrst data address of loaded file ($06 segment)
=$00030a				LOADFILE_TYPE    = $00030A ;3 Bytes (addr) File type string in loaded data file. Actual string data will be in Bank 1. Valid values are BIN, PRG, P16
=$00030d				BLOCK_LEN        = $00030D ;2 Bytes Length of block being loaded
=$00030f				BLOCK_ADDR       = $00030F ;2 Bytes (temp) Address of block being loaded
=$000311				BLOCK_BANK       = $000311 ;1 Byte  (temp) Bank of block being loaded
=$000312				BLOCK_COUNT      = $000312 ;2 Bytes (temp) Counter of bytes read as file is loaded
=$000300				FDC_DRIVE        = $000300 ;1 byte - The number of the selected drive
=$000301				FDC_HEAD         = $000301 ;1 byte - The head number (0 or 1)
=$000302				FDC_CYLINDER     = $000302 ;1 byte - The cylinder number
=$000303				FDC_SECTOR       = $000303 ;1 byte - The sector number
=$000304				FDC_SECTOR_SIZE  = $000304 ;1 byte - The sector size code (2 = 512)
=$000305				FDC_SECPERTRK    = $000305 ;1 byte - The number of sectors per track (18 for 1.44 MB floppy)
=$000306				FDC_ST0          = $000306 ;1 byte - Status Register 0
=$000307				FDC_ST1          = $000307 ;1 byte - Status Register 1
=$000308				FDC_ST2          = $000308 ;1 byte - Status Register 2
=$000309				FDC_ST3          = $000309 ;1 byte - Status Register 3
=$00030a				FDC_PCN          = $00030A ;1 byte - Present Cylinder Number
=$00030b				FDC_STATUS       = $00030B ;1 byte - Status of what we think is going on with the FDC:
=$00030c				DIVIDEND         = $00030C ;4 bytes - Dividend for 32-bit division
=$000310				DIVISOR          = $000310 ;4 bytes - Divisor for 32-bit division
=$000314				REMAINDER        = $000314 ;4 bytes - Remainder for 32-bit division
=$000320				SDOS_VARIABLES   = $000320
=$000320				BIOS_STATUS      = $000320      ; 1 byte - Status of any BIOS operation
=$000321				BIOS_DEV         = $000321      ; 1 byte - Block device number for block operations
=$000322				BIOS_LBA         = $000322      ; 4 bytes - Address of block to read/write (this is the physical block, w/o reference to partition)
=$000326				BIOS_BUFF_PTR    = $000326      ; 4 bytes - 24-bit pointer to memory for read/write operations
=$00032a				BIOS_FIFO_COUNT  = $00032A      ; 2 bytes - The number of bytes read on the last block read
=$00032c				BIOS_FLAGS       = $00032C      ; 1 byte - Flags for various BIOSy things:
=$00032d				BIOS_TIMER       = $00032D      ; 1 byte - the number of 1/60 ticks for a time out
=$00032e				DOS_STATUS       = $00032E      ; 1 byte - The error code describing any error with file access
=$000330				DOS_CLUS_ID      = $000330      ; 4 bytes - The cluster desired for a DOS operation
=$000338				DOS_DIR_PTR      = $000338      ; 4 bytes - Pointer to a directory entry (assumed to be within DOS_SECTOR)
=$00033c				DOS_BUFF_PTR     = $00033C      ; 4 bytes - A pointer for DOS cluster read/write operations
=$000340				DOS_FD_PTR       = $000340      ; 4 bytes - A pointer to a file descriptor
=$000344				DOS_FAT_LBA      = $000344      ; 4 bytes - The LBA for a sector of the FAT we need to read/write
=$000348				DOS_TEMP         = $000348      ; 4 bytes - Temporary storage for DOS operations
=$00034c				DOS_FILE_SIZE    = $00034C      ; 4 bytes - The size of a file
=$000350				DOS_SRC_PTR      = $000350      ; 4 bytes - Pointer for transferring data
=$000354				DOS_DST_PTR      = $000354      ; 4 bytes - Pointer for transferring data
=$000358				DOS_END_PTR      = $000358      ; 4 bytes - Pointer to the last byte to save
=$00035c				DOS_RUN_PTR      = $00035C      ; 4 bytes - Pointer for starting a loaded program
=$000360				DOS_RUN_PARAM    = $000360      ; 4 bytes - Pointer to the ASCIIZ string for arguments in loading a program
=$000364				DOS_STR1_PTR     = $000364      ; 4 bytes - pointer to a string
=$000368				DOS_STR2_PTR     = $000368      ; 4 bytes - pointer to a string
=$00036b				DOS_SCRATCH      = $00036B      ; 4 bytes - general purpose short term storage
=$000400				DOS_PATH_BUFF    = $000400      ; 256 bytes - A buffer for path names
=$000500				FDC_PARAMETERS   = $000500      ; 16 bytes - a buffer of parameter data for the FDC
=$000510				FDC_RESULTS      = $000510      ; 16 bytes - Buffer for results of FDC commands
=$000530				FDC_PARAM_NUM    = $000530      ; 1 byte - The number of parameters to send to the FDC (including command)
=$000532				FDC_RESULT_NUM   = $000532      ; 1 byte - The number of results expected
=$000533				FDC_EXPECT_DAT   = $000533      ; 1 byte - 0 = the command expects no data, otherwise expects data
=$000534				FDC_CMD_RETRY    = $000534      ; 1 byte - a retry counter for commands
=$000700				CURRUART         = $000700 ; 3-bytes: the base address of the current UART
=$000703				CHAN_OUT         = $000703 ; 1-byte: the number of the current output channel (for PUTC, etc.)
=$000704				CHAN_IN          = $000704 ; 1-byte: the number of the current input channel (for GETCH, etc.)
=$000705				TIMERFLAGS       = $000705 ; 1-byte: flags to indicate that one of the timer interupts has triggered
=$80					TIMER0TRIGGER    = $80
=$40					TIMER1TRIGGER    = $40
=$20					TIMER2TRIGGER    = $20
=$000f00				KEY_BUFFER       = $000F00 ; 64 Bytes keyboard buffer
=$0080					KEY_BUFFER_SIZE  = $0080   ;128 Bytes (constant) keyboard buffer length
=$000f7f				KEY_BUFFER_END   = $000F7F ;  1 Byte  Last byte of keyboard buffer
=$000f83				KEY_BUFFER_CMD   = $000F83 ;  1 Byte  Indicates the Command Process Status
=$000f84				COMMAND_SIZE_STR = $000F84 ;  1 Byte
=$000f86				COMMAND_COMP_TMP = $000F86 ;  2 Bytes
=$000f87				KEYBOARD_SC_FLG  = $000F87 ;  1 Bytes that indicate the Status of Left Shift, Left CTRL, Left ALT, Right Shift
=$000f88				KEYBOARD_SC_TMP  = $000F88 ;  1 Byte, Interrupt Save Scan Code while Processing
=$000f89				KEYBOARD_LOCKS   = $000F89 ;  1 Byte, the status of the various lock keys
=$000f8a				KEYFLAG          = $000F8A ;  1 Byte, flag to indicate if CTRL-C has been pressed
=$000f8b				KEY_BUFFER_RPOS  = $000F8B ;  2 Byte, position of the character to read from the KEY_BUFFER
=$000f8d				KEY_BUFFER_WPOS  = $000F8D ;  2 Byte, position of the character to write to the KEY_BUFFER
=$001000				KERNEL_JMP_BEGIN = $001000 ; Reserved for the Kernel jump table
=$001fff				KERNEL_JMP_END   = $001FFF
=$002000				TEST_BEGIN       = $002000 ;28672 Bytes Test/diagnostic code for prototype.
=$007fff				TEST_END         = $007FFF ;0 Byte
=$008000				STACK_BEGIN      = $008000 ;32512 Bytes The default beginning of stack space
=$00feff				STACK_END        = $00FEFF ;0 Byte  End of stack space. Everything below this is I/O space
=$38ff00				ISR_BEGIN        = $38FF00 ; Byte  Beginning of CPU vectors in Direct page
=$38ff00				HRESET           = $38FF00 ;16 Bytes Handle RESET asserted. Reboot computer and re-initialize the kernel.
=$38ff10				HCOP             = $38FF10 ;16 Bytes Handle the COP instruction. Program use; not used by OS
=$38ff20				HBRK             = $38FF20 ;16 Bytes Handle the BRK instruction. Returns to BASIC Ready prompt.
=$38ff30				HABORT           = $38FF30 ;16 Bytes Handle ABORT asserted. Return to Ready prompt with an error message.
=$38ff40				HNMI             = $38FF40 ;32 Bytes Handle NMI
=$38ff60				HIRQ             = $38FF60 ;32 Bytes Handle IRQ
=$38ff80				Unused_FF80      = $38FF80 ;End of direct page Interrrupt handlers
=$38ffe0				VECTORS_BEGIN    = $38FFE0 ;0 Byte  Interrupt vectors
=$38ffe0				JMP_READY        = $38FFE0 ;4 Bytes Jumps to ROM READY routine. Modified whenever alternate command interpreter is loaded.
=$38ffe4				VECTOR_COP       = $38FFE4 ;2 Bytes Native COP Interrupt vector
=$38ffe6				VECTOR_BRK       = $38FFE6 ;2 Bytes Native BRK Interrupt vector
=$38ffe8				VECTOR_ABORT     = $38FFE8 ;2 Bytes Native ABORT Interrupt vector
=$38ffea				VECTOR_NMI       = $38FFEA ;2 Bytes Native NMI Interrupt vector
=$38ffec				VECTOR_RESET     = $38FFEC ;2 Bytes Unused (Native RESET vector)
=$38ffee				VECTOR_IRQ       = $38FFEE ;2 Bytes Native IRQ Vector
=$38fff0				RETURN           = $38FFF0 ;4 Bytes RETURN key handler. Points to BASIC or MONITOR subroutine to execute when RETURN is pressed.
=$38fff4				VECTOR_ECOP      = $38FFF4 ;2 Bytes Emulation mode interrupt handler
=$38fff6				VECTOR_EBRK      = $38FFF6 ;2 Bytes Emulation mode interrupt handler
=$38fff8				VECTOR_EABORT    = $38FFF8 ;2 Bytes Emulation mode interrupt handler
=$38fffa				VECTOR_ENMI      = $38FFFA ;2 Bytes Emulation mode interrupt handler
=$38fffc				VECTOR_ERESET    = $38FFFC ;2 Bytes Emulation mode interrupt handler
=$38fffe				VECTOR_EIRQ      = $38FFFE ;2 Bytes Emulation mode interrupt handler
=$400000				VECTORS_END      = $400000 ;*End of vector space
=$00ffff				BANK0_END        = $00FFFF ;End of Bank 00 and Direct page

;******  Return to file: vgm-player.asm


;******  Processing file: vicky_ii_def.asm

=$af0000				MASTER_CTRL_REG_L	      = $AF0000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$af0001				MASTER_CTRL_REG_H       = $AF0001
=$01					Mstr_Ctrl_Video_Mode0   = $01       ; 0 - 640x480 (Clock @ 25.175Mhz), 1 - 800x600 (Clock @ 40Mhz)
=$02					Mstr_Ctrl_Video_Mode1   = $02       ; 0 - No Pixel Doubling, 1- Pixel Doubling (Reduce the Pixel Resolution by 2)
=$af0002				VKY_RESERVED_00         = $AF0002
=$af0003				VKY_RESERVED_01         = $AF0003
=$01					Border_Ctrl_Enable      = $01
=$af0004				BORDER_CTRL_REG         = $AF0004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$af0005				BORDER_COLOR_B          = $AF0005
=$af0006				BORDER_COLOR_G          = $AF0006
=$af0007				BORDER_COLOR_R          = $AF0007
=$af0008				BORDER_X_SIZE           = $AF0008; X-  Values: 0 - 32 (Default: 32)
=$af0009				BORDER_Y_SIZE           = $AF0009; Y- Values 0 -32 (Default: 32)
=$af000d				BACKGROUND_COLOR_B      = $AF000D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$af000e				BACKGROUND_COLOR_G      = $AF000E
=$af000f				BACKGROUND_COLOR_R      = $AF000F ;
=$af0010				VKY_TXT_CURSOR_CTRL_REG = $AF0010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02
=$04					Vky_Cursor_Flash_Rate1  = $04
=$08					Vky_Cursor_FONT_Page0   = $08       ; Pick Font Page 0 or Font Page 1
=$10					Vky_Cursor_FONT_Page1   = $10       ; Pick Font Page 0 or Font Page 1
=$af0011				VKY_TXT_START_ADD_PTR   = $AF0011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$af0012				VKY_TXT_CURSOR_CHAR_REG = $AF0012
=$af0013				VKY_TXT_CURSOR_COLR_REG = $AF0013
=$af0014				VKY_TXT_CURSOR_X_REG_L  = $AF0014
=$af0015				VKY_TXT_CURSOR_X_REG_H  = $AF0015
=$af0016				VKY_TXT_CURSOR_Y_REG_L  = $AF0016
=$af0017				VKY_TXT_CURSOR_Y_REG_H  = $AF0017
=$af001b				VKY_LINE_IRQ_CTRL_REG   = $AF001B ;[0] - Enable Line 0, [1] -Enable Line 1
=$af001c				VKY_LINE0_CMP_VALUE_LO  = $AF001C ;Write Only [7:0]
=$af001d				VKY_LINE0_CMP_VALUE_HI  = $AF001D ;Write Only [3:0]
=$af001e				VKY_LINE1_CMP_VALUE_LO  = $AF001E ;Write Only [7:0]
=$af001f				VKY_LINE1_CMP_VALUE_HI  = $AF001F ;Write Only [3:0]
=$af001c				VKY_INFO_CHIP_NUM_L     = $AF001C
=$af001d				VKY_INFO_CHIP_NUM_H     = $AF001D
=$af001e				VKY_INFO_CHIP_VER_L     = $AF001E
=$af001f				VKY_INFO_CHIP_VER_H     = $AF001F
=$af0500				MOUSE_PTR_GRAP0_START    = $AF0500 ; 16 x 16 = 256 Pixels (Grey Scale) 0 = Transparent, 1 = Black , 255 = White
=$af05ff				MOUSE_PTR_GRAP0_END      = $AF05FF ; Pointer 0
=$af0600				MOUSE_PTR_GRAP1_START    = $AF0600 ;
=$af06ff				MOUSE_PTR_GRAP1_END      = $AF06FF ; Pointer 1
=$af0700				MOUSE_PTR_CTRL_REG_L    = $AF0700 ; Bit[0] Enable, Bit[1] = 0  ( 0 = Pointer0, 1 = Pointer1)
=$af0701				MOUSE_PTR_CTRL_REG_H    = $AF0701 ;
=$af0702				MOUSE_PTR_X_POS_L       = $AF0702 ; X Position (0 - 639) (Can only read now) Writing will have no effect
=$af0703				MOUSE_PTR_X_POS_H       = $AF0703 ;
=$af0704				MOUSE_PTR_Y_POS_L       = $AF0704 ; Y Position (0 - 479) (Can only read now) Writing will have no effect
=$af0705				MOUSE_PTR_Y_POS_H       = $AF0705 ;
=$af0706				MOUSE_PTR_BYTE0         = $AF0706 ; Byte 0 of Mouse Packet (you must write 3 Bytes)
=$af0707				MOUSE_PTR_BYTE1         = $AF0707 ; Byte 1 of Mouse Packet (if you don't, then )
=$af0708				MOUSE_PTR_BYTE2         = $AF0708 ; Byte 2 of Mouse Packet (state Machine will be jammed in 1 state)
=$af070b				C256F_MODEL_MAJOR       = $AF070B ;
=$af070c				C256F_MODEL_MINOR       = $AF070C ;
=$af070d				FPGA_DOR                = $AF070D ;
=$af070e				FPGA_MOR                = $AF070E ;
=$af070f				FPGA_YOR                = $AF070F ;
=$af1f40				FG_CHAR_LUT_PTR         = $AF1F40
=$af1f80				BG_CHAR_LUT_PTR		    = $AF1F80
=$af2000				GRPH_LUT0_PTR		    = $AF2000
=$af2400				GRPH_LUT1_PTR		    = $AF2400
=$af2800				GRPH_LUT2_PTR		    = $AF2800
=$af2c00				GRPH_LUT3_PTR		    = $AF2C00
=$af3000				GRPH_LUT4_PTR		    = $AF3000
=$af3400				GRPH_LUT5_PTR		    = $AF3400
=$af3800				GRPH_LUT6_PTR		    = $AF3800
=$af3c00				GRPH_LUT7_PTR		    = $AF3C00
=$af4000				GAMMA_B_LUT_PTR		    = $AF4000
=$af4100				GAMMA_G_LUT_PTR		    = $AF4100
=$af4200				GAMMA_R_LUT_PTR		    = $AF4200
=$af8000				FONT_MEMORY_BANK0       = $AF8000     ;$AF8000 - $AF87FF
=$af8800				FONT_MEMORY_BANK1       = $AF8800     ;$AF8800 - $AF8FFF
=$afa000				CS_TEXT_MEM_PTR         = $AFA000
=$afc000				CS_COLOR_MEM_PTR        = $AFC000
=$afe000				BTX_START               = $AFE000     ; BEATRIX Registers
=$afffff				BTX_END                 = $AFFFFF

;******  Return to file: vgm-player.asm


;******  Processing file: kernel_inc.asm

=$001000				BOOT             = $001000 ; Cold boot routine
=$001004				RESTORE          = $001004 ; Warm boot routine
=$001008				BREAK            = $001008 ; End program and return to command prompt
=$00100c				READY            = $00100C ; Print prompt and wait for keyboard input
=$001010				SCINIT           = $001010 ;
=$001014				IOINIT           = $001014 ;
=$001018				PUTC             = $001018 ; Print a character to the currently selected channel
=$00101c				PUTS             = $00101C ; Print a string to the currently selected channel
=$001020				PUTB             = $001020 ; Output a byte to the currently selected channel
=$001024				PUTBLOCK         = $001024 ; Ouput a binary block to the currently selected channel
=$001028				SETLFS           = $001028 ; Obsolete (done in OPEN)
=$00102c				SETNAM           = $00102C ; Obsolete (done in OPEN)
=$001030				OPEN             = $001030 ; Open a channel for reading and/or writing. Use SETLFS and SETNAM to set the channels and filename first.
=$001034				CLOSE            = $001034 ; Close a channel
=$001038				SETIN            = $001038 ; Set the current input channel
=$00103c				SETOUT           = $00103C ; Set the current output channel
=$001040				GETB             = $001040 ; Get a byte from input channel. Return 0 if no input. Carry is set if no input.
=$001044				GETBLOCK         = $001044 ; Get a X byes from input channel. If Carry is set, wait. If Carry is clear, do not wait.
=$001048				GETCH            = $001048 ; Get a character from the input channel. A=0 and Carry=1 if no data is wating
=$00104c				GETCHW           = $00104C ; Get a character from the input channel. Waits until data received. A=0 and Carry=1 if no data is wating
=$001050				GETCHE           = $001050 ; Get a character from the input channel and echo to the screen. Wait if data is not ready.
=$001054				GETS             = $001054 ; Get a string from the input channel. NULL terminates
=$001058				GETLINE          = $001058 ; Get a line of text from input channel. CR or NULL terminates.
=$00105c				GETFIELD         = $00105C ; Get a field from the input channel. Value in A, CR, or NULL terminates
=$001060				TRIM             = $001060 ; Removes spaces at beginning and end of string.
=$001064				PRINTC           = $001064 ; Print character to screen. Handles terminal commands
=$001068				PRINTS           = $001068 ; Print string to screen. Handles terminal commands
=$00106c				PRINTCR          = $00106C ; Print Carriage Return
=$001070				PRINTF           = $001070 ; Print a float value
=$001074				PRINTI           = $001074 ; Prints integer value in TEMP
=$001078				PRINTH           = $001078 ; Print Hex value in DP variable
=$00107c				PRINTAI          = $00107C ; Prints integer value in A
=$001080				PRINTAH          = $001080 ; Prints hex value in A. Printed value is 2 wide if M flag is 1, 4 wide if M=0
=$001084				LOCATE           = $001084 ;
=$001088				PUSHKEY          = $001088 ;
=$00108c				PUSHKEYS         = $00108C ;
=$001090				CSRRIGHT         = $001090 ;
=$001094				CSRLEFT          = $001094 ;
=$001098				CSRUP            = $001098 ;
=$00109c				CSRDOWN          = $00109C ;
=$0010a0				CSRHOME          = $0010A0 ;
=$0010a4				SCROLLUP         = $0010A4 ; Scroll the screen up one line. Creates an empty line at the bottom.
=$0010a8				CLRSCREEN        = $0010A8 ; Clear the screen
=$0010ac				INITCHLUT        = $0010AC ; Init character look-up table
=$0010b0				INITSUPERIO      = $0010B0 ; Init Super-IO chip
=$0010b4				INITKEYBOARD     = $0010B4 ; Init keyboard
=$0010bc				INITCURSOR       = $0010BC ; Init the Cursors registers
=$0010c0				INITFONTSET      = $0010C0 ; Init the Internal FONT Memory
=$0010c4				INITGAMMATABLE   = $0010C4 ; Init the RGB GAMMA Look Up Table
=$0010c8				INITALLLUT       = $0010C8 ; Init the Graphic Engine (Bitmap/Tile/Sprites) LUT
=$0010cc				INITVKYTXTMODE   = $0010CC ; Init the Text Mode @ Reset Time
=$0010d0				INITVKYGRPMODE   = $0010D0 ; Init the Basic Registers for the Graphic Mode
=$0010f0				F_OPEN           = $0010F0 ; open a file for reading/writing/creating
=$0010f4				F_CREATE         = $0010F4 ; create a new file
=$0010f8				F_CLOSE          = $0010F8 ; close a file (make sure last cluster is written)
=$0010fc				F_WRITE          = $0010FC ; write the current cluster to the file
=$001100				F_READ           = $001100 ; read the next cluster from the file
=$001104				F_DELETE         = $001104 ; delete a file / directory
=$001108				F_DIROPEN        = $001108 ; open a directory and seek the first directory entry
=$00110c				F_DIRNEXT        = $00110C ; seek to the next directory of an open directory
=$001110				F_DIRREAD        = $001110 ; Read the directory entry for the specified file
=$001114				F_DIRWRITE       = $001114 ; Write any changes in the current directory cluster back to the drive
=$001118				F_LOAD           = $001118 ; load a binary file into memory, supports multiple file formats
=$00111c				F_SAVE           = $00111C ; Save memory to a binary file
=$001120				CMDBLOCK         = $001120 ; Send a command to a block device
=$001124				F_RUN            = $001124 ; Load and run an executable binary file
=$001128				F_MOUNT          = $001128 ; Mount the designated block device
=$00112c				SETSIZES         = $00112C ; Set the text screen size variables based on the border and screen resolution.
=$001130				F_COPY           = $001130 ; Copy a file
=$001134				F_ALLOCFD        = $001134 ; Allocate a file descriptor
=$001138				F_FREEFD         = $001138 ; Free a file descriptor
=$38113c				TIMER0INTSUB     = $38113C ; Interrupt routine for Timer0
=$381140				TIMER1INTSUB     = $381140 ; Interrupt routine for Timer1
=$381144				TIMER2INTSUB     = $381144 ; Interrupt routine for Timer2

;******  Return to file: vgm-player.asm


;******  Processing file: timer_def.asm

=$000160				TIMER0_CTRL_REG   = $000160 ; (Write - Control, Read Status)
=$01					TMR0_EN     = $01
=$02					TMR0_SCLR   = $02
=$04					TMR0_SLOAD  = $04 ; Use SLOAD is
=$08					TMR0_UPDWN  = $08
=$000161				TIMER0_CHARGE_L   = $000161 ; Use if you want to Precharge and countdown
=$000162				TIMER0_CHARGE_M   = $000162 ;
=$000163				TIMER0_CHARGE_H   = $000163 ;
=$000164				TIMER0_CMP_REG    = $000164 ;
=$01					TMR0_CMP_RECLR     = $01 ; set to one for it to cycle when Counting up
=$02					TMR0_CMP_RELOAD    = $02 ; Set to one for it to reload when Counting Down
=$000165				TIMER0_CMP_L      = $000165 ; Load this Value for Countup
=$000166				TIMER0_CMP_M      = $000166 ;
=$000167				TIMER0_CMP_H      = $000167 ;
=$000168				TIMER1_CTRL_REG   = $000168 ;
=$01					TMR1_EN     = $01
=$02					TMR1_SCLR   = $02
=$04					TMR1_SLOAD  = $04
=$08					TMR1_UPDWN  = $08 ; 1 = Up, 0 = Down
=$000169				TIMER1_CHARGE_L   = $000169 ; Use if you want to Precharge and countdown
=$00016a				TIMER1_CHARGE_M   = $00016A ;
=$00016b				TIMER1_CHARGE_H   = $00016B ;
=$00016c				TIMER1_CMP_REG    = $00016C ;
=$01					TMR1_CMP_RECLR     = $01 ; set to one for it to cycle when Counting up
=$02					TMR1_CMP_RELOAD    = $02 ; Set to one for it to reload when Counting Down
=$00016d				TIMER1_CMP_L      = $00016D ;
=$00016e				TIMER1_CMP_M      = $00016E ;
=$00016f				TIMER1_CMP_H      = $00016F ;

;******  Return to file: vgm-player.asm


;******  Processing file: math_def.asm

=$000100				UNSIGNED_MULT_A     = $000100 ;2 Bytes Operand A (ie: A x B)
=$000102				UNSIGNED_MULT_B     = $000102 ;2 Bytes Operand B (ie: A x B)
=$000104				UNSIGNED_MULT_RESULT= $000104 ;4 Bytes Result of A x B
=$000108				SIGNED_MULT_A       = $000108 ;2 Bytes Operand A (ie: A x B)
=$00010a				SIGNED_MULT_B       = $00010A ;2 Bytes Operand B (ie: A x B)
=$00010c				SIGNED_MULT_RESULT  = $00010C ;4 Bytes Result of A x B
=$000110				DIVIDER_0        = $000110 ;0 Byte  Signed divider
=$000110				D0_OPERAND_A     = $000110 ;2 Bytes Divider 1 Dividend ex: A in  B/A
=$000112				D0_OPERAND_B     = $000112 ;2 Bytes Divider 1 Divisor ex B in B/A
=$000114				D0_RESULT        = $000114 ;2 Bytes Signed quotient result of B/A ex: 7/2 = 3 r 1
=$000116				D0_REMAINDER     = $000116 ;2 Bytes Signed remainder of B/A ex: 1 in 7/2=3 r 1
=$000118				DIVIDER_1        = $000118 ;0 Byte  Unsigned divider
=$000118				D1_OPERAND_A     = $000118 ;2 Bytes Divider 0 Dividend ex: A in  A/B
=$00011a				D1_OPERAND_B     = $00011A ;2 Bytes Divider 0 Divisor ex B in A/B
=$00011c				D1_RESULT        = $00011C ;2 Bytes Quotient result of A/B ex: 7/2 = 3 r 1
=$00011e				D1_REMAINDER     = $00011E ;2 Bytes Remainder of A/B ex: 1 in 7/2=3 r 1
=$000120				ADDER_A          = $000120 ; 4 bytes (32 bit) Accumulator A
=$000124				ADDER_B          = $000124 ; 4 bytes (32 bit) Accumulator B
=$000128				ADDER_R          = $000128 ; 4 bytes (32 bit) Result

;******  Return to file: vgm-player.asm


;******  Processing file: interrupt_def.asm

=$000140				INT_PENDING_REG0 = $000140 ;
=$000141				INT_PENDING_REG1 = $000141 ;
=$000142				INT_PENDING_REG2 = $000142 ;
=$000143				INT_PENDING_REG3 = $000143 ; FMX Model
=$000144				INT_POL_REG0     = $000144 ;
=$000145				INT_POL_REG1     = $000145 ;
=$000146				INT_POL_REG2     = $000146 ;
=$000147				INT_POL_REG3     = $000147 ; FMX Model
=$000148				INT_EDGE_REG0    = $000148 ;
=$000149				INT_EDGE_REG1    = $000149 ;
=$00014a				INT_EDGE_REG2    = $00014A ;
=$00014b				INT_EDGE_REG3    = $00014B ; FMX Model
=$00014c				INT_MASK_REG0    = $00014C ;
=$00014d				INT_MASK_REG1    = $00014D ;
=$00014e				INT_MASK_REG2    = $00014E ;
=$00014f				INT_MASK_REG3    = $00014F ; FMX Model
=$01					FNX0_INT00_SOF        = $01  ;Start of Frame @ 60FPS
=$02					FNX0_INT01_SOL        = $02  ;Start of Line (Programmable)
=$04					FNX0_INT02_TMR0       = $04  ;Timer 0 Interrupt
=$08					FNX0_INT03_TMR1       = $08  ;Timer 1 Interrupt
=$10					FNX0_INT04_TMR2       = $10  ;Timer 2 Interrupt
=$20					FNX0_INT05_RTC        = $20  ;Real-Time Clock Interrupt
=$40					FNX0_INT06_FDC        = $40  ;Floppy Disk Controller
=$80					FNX0_INT07_MOUSE      = $80  ; Mouse Interrupt (INT12 in SuperIO IOspace)
=$01					FNX1_INT00_KBD        = $01  ;Keyboard Interrupt
=$02					FNX1_INT01_SC0        = $02  ;VICKY_II (INT2) Sprite 2 Sprite Collision
=$04					FNX1_INT02_SC1        = $04  ;VICKY_II (INT3) Sprite 2 Tiles Collision
=$08					FNX1_INT03_COM2       = $08  ;Serial Port 2
=$10					FNX1_INT04_COM1       = $10  ;Serial Port 1
=$20					FNX1_INT05_MPU401     = $20  ;Midi Controller Interrupt
=$40					FNX1_INT06_LPT        = $40  ;Parallel Port
=$80					FNX1_INT07_SDCARD     = $80  ;SD Card Controller Interrupt (CH376S)
=$01					FNX2_INT00_OPL3       = $01  ;OPl3
=$02					FNX2_INT01_GABE_INT0  = $02  ;GABE (INT0) - TBD
=$04					FNX2_INT02_GABE_INT1  = $04  ;GABE (INT1) - TBD
=$08					FNX2_INT03_SDMA       = $08  ;VICKY_II (INT4)
=$10					FNX2_INT04_VDMA       = $10  ;VICKY_II (INT5)
=$20					FNX2_INT05_GABE_INT2  = $20  ;GABE (INT2) - TBD
=$40					FNX2_INT06_EXT        = $40  ;External Expansion
=$80					FNX2_INT07_SDCARD_INS = $80  ; SDCARD Insertion
=$01					FNX3_INT00_OPN2       = $01  ;OPN2
=$02					FNX3_INT01_OPM        = $02  ;OPM
=$04					FNX3_INT02_IDE        = $04  ;HDD IDE INTERRUPT
=$08					FNX3_INT03_TBD        = $08  ;TBD
=$10					FNX3_INT04_TBD        = $10  ;TBD
=$20					FNX3_INT05_TBD        = $20  ;GABE (INT2) - TBD
=$40					FNX3_INT06_TBD        = $40  ;External Expansion
=$80					FNX3_INT07_TBD        = $80  ;SDCARD Insertion

;******  Return to file: vgm-player.asm


;******  Processing file: sdos_inc.asm

.0000					FILEDESC
>0000					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>0001					DEV                 .byte ?             ; The ID of the device holding the file
>0002					PATH                .dword ?            ; Pointer to a NULL terminated path string
>0006					CLUSTER             .dword ?            ; The current cluster of the file.
>000a					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>000e					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>0012					SIZE                .dword ?            ; The size of the file
>0016					CREATE_DATE         .word ?             ; The creation date of the file
>0018					CREATE_TIME         .word ?             ; The creation time of the file
>001a					MODIFIED_DATE       .word ?             ; The modification date of the file
>001c					MODIFIED_TIME       .word ?             ; The modification time of the file
>001e					RESERVED            .word ?             ; Two reserved bytes to bring the descriptor up to 32 bytes
=$01					FD_STAT_READ = $01                      ; The file is readable
=$02					FD_STAT_WRITE = $02                     ; The file is writable
=$10					FD_STAT_ALLOC = $10                     ; The file descriptor has been allocated
=$38					FD_STAT_OPEN = $38                      ; The file is open
=$40					FD_STAT_ERROR = $40                     ; The file is in an error condition
=$80					FD_STAT_EOF = $80                       ; The file cursor is at the end of the file
=0					BIOS_DEV_FDC = 0                ; Floppy 0
=1					BIOS_DEV_FD1 = 1                ; Future support: Floppy 1 (not likely to be attached)
=2					BIOS_DEV_SD  = 2                ; SD card, partition 0
=3					BIOS_DEV_SD1 = 3                ; Future support: SD card, partition 1
=4					BIOS_DEV_SD2 = 4                ; Future support: SD card, partition 2
=5					BIOS_DEV_SD3 = 5                ; Future support: SD card, partition 3
=6					BIOS_DEV_HD0 = 6                ; Future support: IDE Drive 0, partition 0
=7					BIOS_DEV_HD1 = 7                ; Future support: IDE Drive 0, partition 1
=8					BIOS_DEV_HD2 = 8                ; Future support: IDE Drive 0, partition 2
=9					BIOS_DEV_HD3 = 9                ; Future support: IDE Drive 0, partition 3

;******  Return to file: vgm-player.asm

=$aff000				OPM_BASE_ADDRESS  = $AFF000
=$aff100				PSG_BASE_ADDRESS  = $AFF100
=$aff200				OPN2_BASE_ADDRESS = $AFF200
=$afe600				OPL3_BASE_ADRESS  = $AFE600
=$8					VGM_VERSION       = $8  ; 32-bits
=$c					SN_CLOCK          = $C  ; 32-bits
=$14					GD3_OFFSET        = $14 ; 32-bits
=$1c					LOOP_OFFSET       = $1C ; 32-bits
=$2c					YM_OFFSET         = $2C ; 32-bits
=$30					OPM_CLOCK         = $30 ; 32-bits
=$34					VGM_OFFSET        = $34 ; 32-bits
=$77					MIN_VERSION       = $77 ; 1 byte
=$78					DISPLAY_OFFSET    = $78 ; 2 bytes
=$7a					MSG_PTR           = $7A ; 3 bytes
=$7d					DATA_STREAM_CNT   = $7D ; 2 byte
=$7f					COMMAND           = $7F ; 1 byte
=$80					SONG_START        = $80 ; 4 bytes
=$84					CURRENT_POSITION  = $84 ; 4 bytes
=$88					WAIT_CNTR         = $88 ; 2 bytes
=$8a					PCM_OFFSET        = $8A ; 4 bytes
=$8e					GD3_POSITION      = $8E ; 4 bytes
=$92					AY_3_8910_A       = $92 ; 2 bytes
=$94					AY_3_8910_B       = $94 ; 2 bytes
=$96					AY_3_8910_C       = $96 ; 2 bytes
=$98					AY_3_8910_N       = $98 ; 2 bytes
=$9a					AY_BASE_AMPL      = $9A ; 1 byte
=$8000					DATA_STREAM_TBL   = $8000 ; each entry is 4 bytes
=$170000				VGM_FILE          = $170000  ; the address to store the VGM data.
.162200					VGM_START
.162200	08		php		            PHP
.162201	e2 20		sep #$20	                SEP #$20        ; set A short
.162203	c2 10		rep #$10	                REP #$10        ; set X long
.162205	8b		phb		            PHB
.162206	0b		phd		            PHD
.162207	a9 00		lda #$00	            LDA #0
.162209	eb		xba		            XBA
.16220a	a9 00		lda #$00	            LDA #0
.16220c	5b		tcd		            TCD  ; store 0 in the direct page register
.16220d	48		pha		            PHA
.16220e	ab		plb		            PLB  ; store 0 in the bank register
.16220f	85 7f		sta $7f		            STA COMMAND
.162211	a9 16		lda #$16	            LDA #`RESET_MSG
.162213	85 7c		sta $7c		            STA MSG_PTR+2
.162215	a6 17		ldx $17		            LDX $17
.162217	86 78		stx $78		            STX DISPLAY_OFFSET
.162219	20 da 23	jsr $1623da	            JSR LOAD_VGM_FILE
.16221c	a5 7f		lda $7f		            LDA COMMAND ; if the command is still 0, it's a vgm file
.16221e	d0 45		bne $162265	            BNE VGM_DONE
.162220	a9 00		lda #$00	            LDA #0
.162222	8f 10 00 af	sta $af0010	            STA VKY_TXT_CURSOR_CTRL_REG
.162226	a2 00 00	ldx #$0000	            LDX #0
.162229	86 7d		stx $7d		            STX DATA_STREAM_CNT
.16222b	a9 17		lda #$17	            LDA #`VGM_FILE
.16222d	85 86		sta $86		            STA CURRENT_POSITION + 2
.16222f	85 82		sta $82		            STA SONG_START + 2
.162231	a2 00 00	ldx #$0000	            LDX #<>VGM_FILE
.162234	86 80		stx $80		            STX SONG_START
.162236	a9 00		lda #$00	            LDA #0
.162238	85 7f		sta $7f		            STA COMMAND
.16223a	20 b5 23	jsr $1623b5	            JSR CHECK_VGM_FILE
.16223d	a5 7f		lda $7f		            LDA COMMAND ; if the command is still 0, it's a vgm file
.16223f	d0 18		bne $162259	            BNE INVALID_FILE
.162241	20 42 2a	jsr $162a42	            JSR VGM_SET_SONG_POINTERS
.162244	20 db 2b	jsr $162bdb	            JSR VGM_DISPLAY_GD3
.162247	20 07 2b	jsr $162b07	            JSR VGM_INIT_TIMER0
.16224a	ad 4c 01	lda $014c	            LDA INT_MASK_REG0
.16224d	29 fb		and #$fb	            AND #~( FNX0_INT02_TMR0 ) ; | FNX0_INT00_SOF) ; uncomment this to debug in the IDE
.16224f	8d 4c 01	sta $014c	            STA INT_MASK_REG0
.162252	22 e9 24 16	jsl $1624e9	            JSL VGM_WRITE_REGISTER  ; the initial load of register should set the timerA
.162256	58		cli		            CLI
.162257	80 0c		bra $162265	            BRA VGM_DONE
.162259					        INVALID_FILE
.162259	c2 20		rep #$20	                REP #$20        ; set A long
.16225b	a9 a4 22	lda #$22a4	            LDA #<>INVALID_FILE_MSG
.16225e	85 7a		sta $7a		            STA MSG_PTR
.162260	e2 20		sep #$20	                SEP #$20        ; set A short
.162262	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.162265					        VGM_DONE
.162265	a0 79 23	ldy #$2379	            LDY #<>KERNEL_RETURN_MSG
.162268	84 7a		sty $7a		            STY MSG_PTR
.16226a	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.16226d	2b		pld		            PLD
.16226e	ab		plb		            PLB
.16226f	28		plp		            PLP
.162270	6b		rtl		            RTL
>162271	52 65 73 74 61 72 74 69		RESET_MSG               .text 'Restarting song:',0
>162279	6e 67 20 73 6f 6e 67 3a 00
>162282	4c 6f 6f 70 69 6e 67 20		LOOPING_MSG             .text 'Looping song:',0
>16228a	73 6f 6e 67 3a 00
>162290	52 65 61 64 69 6e 67 20		DATA_BLOCK_MSG          .text 'Reading Data Block:',0
>162298	44 61 74 61 20 42 6c 6f 63 6b 3a 00
>1622a4	49 6e 76 61 6c 69 64 20		INVALID_FILE_MSG        .text 'Invalid file type:', 0
>1622ac	66 69 6c 65 20 74 79 70 65 3a 00
>1622b7	55 6e 6b 6e 6f 77 6e 20		UNK_CMD1_MSG            .text 'Unknown 1-Byte Command:',0
>1622bf	31 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>1622cf	55 6e 6b 6e 6f 77 6e 20		UNK_CMD2_MSG            .text 'Unknown 2-Byte Command:',0
>1622d7	32 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>1622e7	55 6e 6b 6e 6f 77 6e 20		UNK_CMD3_MSG            .text 'Unknown 3-Byte Command:',0
>1622ef	33 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>1622ff	55 6e 6b 6e 6f 77 6e 20		UNK_CMD4_MSG            .text 'Unknown 4-Byte Command:',0
>162307	34 2d 42 79 74 65 20 43 6f 6d 6d 61 6e 64 3a 00
>162317	30 31 32 33 34 35 36 37		HEX_VALUES              .text '0123456789ABCDEF'
>16231f	38 39 41 42 43 44 45 46
>162327	43 6f 75 6c 64 6e 27 74		GD3_ERR_MSG             .text 'Couldn''t read Gd3 Info', 0
>16232f	20 72 65 61 64 20 47 64 33 20 49 6e 66 6f 00
>16233e	56 47 4d 20 50 6c 61 79		LOADING_VGM_FILE_MSG    .text 'VGM Player loading file', 0
>162346	65 72 20 6c 6f 61 64 69 6e 67 20 66 69 6c 65 00
>162356	42 52 55 4e 20 64 6f 65		BRUN_CMD_ERROR_MSG      .text 'BRUN does not have a file to load.', 0
>16235e	73 20 6e 6f 74 20 68 61 76 65 20 61 20 66 69 6c
>16236e	65 20 74 6f 20 6c 6f 61 64 2e 00
>162379	52 65 74 75 72 6e 69 6e		KERNEL_RETURN_MSG       .text 'Returning control to kernel', 0
>162381	67 20 63 6f 6e 74 72 6f 6c 20 74 6f 20 6b 65 72
>162391	6e 65 6c 00
.162395					DOS_REC_PTR
>162395					STATUS              .byte ?             ; The status flags of the file descriptor (open, closed, error, EOF, etc.)
>162396					DEV                 .byte ?             ; The ID of the device holding the file
>162397					PATH                .dword ?            ; Pointer to a NULL terminated path string
>16239b					CLUSTER             .dword ?            ; The current cluster of the file.
>16239f					FIRST_CLUSTER       .dword ?            ; The ID of the first cluster in the file
>1623a3					BUFFER              .dword ?            ; Pointer to a cluster-sized buffer
>1623a7					SIZE                .dword ?            ; The size of the file
>1623ab					CREATE_DATE         .word ?             ; The creation date of the file
>1623ad					CREATE_TIME         .word ?             ; The creation time of the file
>1623af					MODIFIED_DATE       .word ?             ; The modification date of the file
>1623b1					MODIFIED_TIME       .word ?             ; The modification time of the file
>1623b3					RESERVED            .word ?             ; Two reserved bytes to bring the descriptor up to 32 bytes
.1623b5					CHECK_VGM_FILE
.1623b5	a0 00 00	ldy #$0000	            LDY #0
.1623b8	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623ba	c8		iny		            INY
.1623bb	c9 56		cmp #$56	            CMP #'V'
.1623bd	d0 16		bne $1623d5	            BNE CHECK_FAILED
.1623bf	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623c1	c8		iny		            INY
.1623c2	c9 67		cmp #$67	            CMP #'g'
.1623c4	d0 0f		bne $1623d5	            BNE CHECK_FAILED
.1623c6	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623c8	c8		iny		            INY
.1623c9	c9 6d		cmp #$6d	            CMP #'m'
.1623cb	d0 08		bne $1623d5	            BNE CHECK_FAILED
.1623cd	a0 08 00	ldy #$0008	            LDY #8
.1623d0	b7 80		lda [$80],y	            LDA [SONG_START],Y
.1623d2	85 77		sta $77		            STA MIN_VERSION
.1623d4	60		rts		            RTS
.1623d5					    CHECK_FAILED
.1623d5	a9 01		lda #$01	            LDA #1
.1623d7	85 7f		sta $7f		            STA COMMAND
.1623d9	60		rts		            RTS
.1623da					LOAD_VGM_FILE
.1623da	48		pha		                PHA             ; begin setdp macro
.1623db	08		php		                PHP
.1623dc	c2 20		rep #$20	                REP #$20        ; set A long
.1623de	a9 60 03	lda #$0360	                LDA #<>DOS_RUN_PARAM         ; set DP to page 0
.1623e1	5b		tcd		                TCD
.1623e2	28		plp		                PLP
.1623e3	68		pla		                PLA             ; end setdp macro
.1623e4	a0 00 00	ldy #$0000	            LDY #0
.1623e7					    FS_LOOP
.1623e7	b7 00		lda [$0360],y	            LDA [DOS_RUN_PARAM],Y
.1623e9	c8		iny		            INY
.1623ea	c0 20 00	cpy #$0020	            CPY #$20 ; expect the vgm command to be less than 32 characters
.1623ed	b0 1c		bcs $16240b	            BGE LF_ERROR
.1623ef	c9 20		cmp #$20	            CMP #' '  ; seek the space character in the BRUN command
.1623f1	d0 f4		bne $1623e7	            BNE FS_LOOP
.1623f3	5a		phy		            PHY
.1623f4	0b		phd		            PHD
.1623f5	48		pha		                PHA             ; begin setdp macro
.1623f6	08		php		                PHP
.1623f7	c2 20		rep #$20	                REP #$20        ; set A long
.1623f9	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.1623fc	5b		tcd		                TCD
.1623fd	28		plp		                PLP
.1623fe	68		pla		                PLA             ; end setdp macro
.1623ff	a0 3e 23	ldy #$233e	            LDY #<>LOADING_VGM_FILE_MSG
.162402	84 7a		sty $7a		            STY MSG_PTR
.162404	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.162407	2b		pld		            PLD
.162408	7a		ply		            PLY
.162409	80 17		bra $162422	            BRA LF_GOOD
.16240b					    LF_ERROR
.16240b	48		pha		                PHA             ; begin setdp macro
.16240c	08		php		                PHP
.16240d	c2 20		rep #$20	                REP #$20        ; set A long
.16240f	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.162412	5b		tcd		                TCD
.162413	28		plp		                PLP
.162414	68		pla		                PLA             ; end setdp macro
.162415	a0 56 23	ldy #$2356	            LDY #<>BRUN_CMD_ERROR_MSG
.162418	84 7a		sty $7a		            STY MSG_PTR
.16241a	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.16241d	a9 01		lda #$01	            LDA #1
.16241f	85 7f		sta $7f		            STA COMMAND
.162421	60		rts		            RTS
.162422					    LF_GOOD
.162422	c2 20		rep #$20	                REP #$20        ; set A long
.162424	98		tya		            TYA
.162425	18		clc		            CLC
.162426	6d 60 03	adc $0360	            ADC DOS_RUN_PARAM
.162429	8f 97 23 16	sta $162397	            STA DOS_REC_PTR.PATH
.16242d	ad 62 03	lda $0362	            LDA DOS_RUN_PARAM + 2
.162430	8f 99 23 16	sta $162399	            STA DOS_REC_PTR.PATH + 2
.162434	a9 00 00	lda #$0000	            LDA #<>VGM_FILE
.162437	8d 54 03	sta $0354	            STA DOS_DST_PTR
.16243a	a9 17 00	lda #$0017	            LDA #`VGM_FILE
.16243d	8d 56 03	sta $0356	            STA DOS_DST_PTR + 2
.162440	a9 95 23	lda #$2395	            LDA #<>DOS_REC_PTR
.162443	8d 40 03	sta $0340	            STA DOS_FD_PTR
.162446	a9 16 00	lda #$0016	            LDA #`DOS_REC_PTR
.162449	8d 42 03	sta $0342	            STA DOS_FD_PTR + 2
.16244c	a9 00 20	lda #$2000	            LDA #<>VGM_START - 512
.16244f	8f a3 23 16	sta $1623a3	            STA DOS_REC_PTR.BUFFER
.162453	a9 16 00	lda #$0016	            LDA #`(VGM_START - 512)
.162456	8f a5 23 16	sta $1623a5	            STA DOS_REC_PTR.BUFFER + 2
.16245a	e2 20		sep #$20	                SEP #$20        ; set A short
.16245c	a9 00		lda #$00	            LDA #0
.16245e	8f 95 23 16	sta $162395	            STA DOS_REC_PTR.STATUS
.162462	a9 02		lda #$02	            LDA #BIOS_DEV_SD
.162464	8f 96 23 16	sta $162396	            STA DOS_REC_PTR.DEV
.162468	22 18 11 00	jsl $001118	            JSL F_LOAD
.16246c	90 9d		bcc $16240b	            BCC LF_ERROR
.16246e	48		pha		                PHA             ; begin setdp macro
.16246f	08		php		                PHP
.162470	c2 20		rep #$20	                REP #$20        ; set A long
.162472	a9 00 00	lda #$0000	                LDA #0         ; set DP to page 0
.162475	5b		tcd		                TCD
.162476	28		plp		                PLP
.162477	68		pla		                PLA             ; end setdp macro
.162478	60		rts		            RTS
.162479					DISPLAY_MSG
.162479	5a		phy		            PHY
.16247a	a6 78		ldx $78		            LDX DISPLAY_OFFSET
.16247c	a0 00 00	ldy #$0000	            LDY #0
.16247f	a9 00		lda #$00	            LDA #0
.162481	eb		xba		            XBA
.162482					    DISPLAY_NEXT
.162482	a9 2d		lda #$2d	            LDA #$2D   ; Text color
.162484	9f 00 20 af	sta $af2000,x	            STA $AF2000,X  ; offset to Text LUT $AF:C000
.162488	b7 7a		lda [$7a],y	            LDA [MSG_PTR],Y
.16248a	9f 00 00 af	sta $af0000,x	            STA $AF0000,X  ; offset to Text $AF:A000
.16248e	e8		inx		            INX
.16248f	c8		iny		            INY
.162490	c9 00		cmp #$00	            CMP #0
.162492	d0 ee		bne $162482	            BNE DISPLAY_NEXT
.162494	a9 2d		lda #$2d	            LDA #$2D
.162496	9f 00 20 af	sta $af2000,x	            STA $AF2000,X
.16249a	a5 7f		lda $7f		            LDA COMMAND
.16249c	29 f0		and #$f0	            AND #$F0
.16249e	4a		lsr a		            LSR A
.16249f	4a		lsr a		            LSR A
.1624a0	4a		lsr a		            LSR A
.1624a1	4a		lsr a		            LSR A
.1624a2	9b		txy		            TXY
.1624a3	aa		tax		            TAX
.1624a4	bf 17 23 16	lda $162317,x	            LDA HEX_VALUES,X
.1624a8	bb		tyx		            TYX
.1624a9	9f 00 00 af	sta $af0000,x	            STA $AF0000,X
.1624ad	e8		inx		            INX
.1624ae	a9 2d		lda #$2d	            LDA #$2D
.1624b0	9f 00 20 af	sta $af2000,x	            STA $AF2000,X
.1624b4	a5 7f		lda $7f		            LDA COMMAND
.1624b6	29 0f		and #$0f	            AND #$F
.1624b8	9b		txy		            TXY
.1624b9	aa		tax		            TAX
.1624ba	bf 17 23 16	lda $162317,x	            LDA HEX_VALUES,X
.1624be	bb		tyx		            TYX
.1624bf	9f 00 00 af	sta $af0000,x	            STA $AF0000,X
.1624c3	c2 20		rep #$20	                REP #$20        ; set A long
.1624c5	a5 78		lda $78		            LDA DISPLAY_OFFSET
.1624c7	18		clc		            CLC
.1624c8	69 50 00	adc #$0050	            ADC #80 ; 80 columns in 640x480 mode
.1624cb	85 78		sta $78		            STA DISPLAY_OFFSET
.1624cd	e2 20		sep #$20	                SEP #$20        ; set A short
.1624cf	eb		xba		            XBA
.1624d0	c9 b1		cmp #$b1	            CMP #$B1 ; 80 COLS * 56 ROWS = $1180  - SO $11 + A0 = $B1
.1624d2	90 13		bcc $1624e7	            BLT DISPLAY_DONE
.1624d4	eb		xba		            XBA
.1624d5	d0 07		bne $1624de	            BNE FIRST_COL
.1624d7	a2 28 a0	ldx #$a028	            LDX #$A000 + 40 ; create a second column
.1624da	86 78		stx $78		            STX DISPLAY_OFFSET
.1624dc	80 09		bra $1624e7	            BRA DISPLAY_DONE
.1624de					        FIRST_COL
.1624de	a2 00 a0	ldx #$a000	            LDX #$A000
.1624e1	86 78		stx $78		            STX DISPLAY_OFFSET
.1624e3	22 a8 10 00	jsl $0010a8	            JSL CLRSCREEN
.1624e7					    DISPLAY_DONE
.1624e7	7a		ply		            PLY
.1624e8	60		rts		            RTS
.1624e9					VGM_WRITE_REGISTER
.1624e9	a6 88		ldx $88		            LDX WAIT_CNTR
.1624eb	e0 00 00	cpx #$0000	            CPX #0
.1624ee	f0 04		beq $1624f4	            BEQ READ_COMMAND
.1624f0	ca		dex		            DEX
.1624f1	86 88		stx $88		            STX WAIT_CNTR
.1624f3	60		rts		            RTS
.1624f4					    READ_COMMAND
.1624f4	a9 00		lda #$00	            LDA #0
.1624f6	eb		xba		            XBA
.1624f7	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1624f9	85 7f		sta $7f		            STA COMMAND
.1624fb	c2 20		rep #$20	                REP #$20        ; set A long
.1624fd	e6 84		inc $84		            INC CURRENT_POSITION
.1624ff	d0 02		bne $162503	            BNE increment_done
.162501	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162503					    increment_done
.162503	e2 20		sep #$20	                SEP #$20        ; set A short
.162505	29 f0		and #$f0	            AND #$F0
.162507	4a		lsr a		            LSR A
.162508	4a		lsr a		            LSR A
.162509	4a		lsr a		            LSR A
.16250a	aa		tax		            TAX
.16250b	7c 0f 25	jmp ($16250f,x)	            JMP (VGM_COMMAND_TABLE,X)
.16250e					    VGM_LOOP_DONE
.16250e	6b		rtl		            RTL
.16250f					VGM_COMMAND_TABLE
>16250f	2f 25				            .word <>INVALID_COMMAND ;0
>162511	2f 25				            .word <>INVALID_COMMAND ;1
>162513	2f 25				            .word <>INVALID_COMMAND ;2
>162515	32 25				            .word <>SKIP_BYTE_CMD   ;3 - reserved - not implemented
>162517	32 25				            .word <>SKIP_BYTE_CMD   ;4 - not implemented
>162519	c5 27				            .word <>WRITE_YM_CMD    ;5 - YM*
>16251b	bc 29				            .word <>WAIT_COMMANDS   ;6
>16251d	0e 2a				            .word <>WAIT_N_1        ;7
>16251f	1c 2a				            .word <>YM2612_SAMPLE   ;8
>162521	3f 2a				            .word <>DAC_STREAM      ;9
>162523	13 26				            .word <>AY8910          ;A - AY8910
>162525	4b 25				            .word <>SKIP_TWO_BYTES  ;B - not implemented
>162527	6a 25				            .word <>SKIP_THREE_BYTES;C - not implemented
>162529	6a 25				            .word <>SKIP_THREE_BYTES;D - not implemented
>16252b	8f 25				            .word <>SEEK_OFFSET     ;E - not implemented
>16252d	e8 25				            .word <>SKIP_FOUR_BYTES ;F - not implemented
.16252f					INVALID_COMMAND
.16252f	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162532					SKIP_BYTE_CMD
.162532	c2 20		rep #$20	                REP #$20        ; set A long
.162534	a9 b7 22	lda #$22b7	            LDA #<>UNK_CMD1_MSG
.162537	85 7a		sta $7a		            STA MSG_PTR
.162539	e2 20		sep #$20	                SEP #$20        ; set A short
.16253b	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.16253e	c2 20		rep #$20	                REP #$20        ; set A long
.162540	e6 84		inc $84		            INC CURRENT_POSITION
.162542	d0 02		bne $162546	            BNE increment_done
.162544	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162546					    increment_done
.162546	e2 20		sep #$20	                SEP #$20        ; set A short
.162548	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16254b					SKIP_TWO_BYTES
.16254b	c2 20		rep #$20	                REP #$20        ; set A long
.16254d	a9 cf 22	lda #$22cf	            LDA #<>UNK_CMD2_MSG
.162550	85 7a		sta $7a		            STA MSG_PTR
.162552	e2 20		sep #$20	                SEP #$20        ; set A short
.162554	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.162557	c2 20		rep #$20	                REP #$20        ; set A long
.162559	e6 84		inc $84		            INC CURRENT_POSITION
.16255b	d0 02		bne $16255f	            BNE s2_1
.16255d	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16255f					    s2_1
.16255f	e6 84		inc $84		            INC CURRENT_POSITION
.162561	d0 02		bne $162565	            BNE s2_2
.162563	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162565					    s2_2
.162565	e2 20		sep #$20	                SEP #$20        ; set A short
.162567	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16256a					SKIP_THREE_BYTES
.16256a	c2 20		rep #$20	                REP #$20        ; set A long
.16256c	a9 e7 22	lda #$22e7	            LDA #<>UNK_CMD3_MSG
.16256f	85 7a		sta $7a		            STA MSG_PTR
.162571	e2 20		sep #$20	                SEP #$20        ; set A short
.162573	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.162576	c2 20		rep #$20	                REP #$20        ; set A long
.162578	e6 84		inc $84		            INC CURRENT_POSITION
.16257a	d0 02		bne $16257e	            BNE s3_1
.16257c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16257e					    s3_1
.16257e	e6 84		inc $84		            INC CURRENT_POSITION
.162580	d0 02		bne $162584	            BNE s3_2
.162582	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162584					    s3_2
.162584	e6 84		inc $84		            INC CURRENT_POSITION
.162586	d0 02		bne $16258a	            BNE s3_3
.162588	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16258a					    s3_3
.16258a	e2 20		sep #$20	                SEP #$20        ; set A short
.16258c	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16258f					SEEK_OFFSET
.16258f	a5 7f		lda $7f		            LDA COMMAND
.162591	c9 e0		cmp #$e0	            CMP #$E0
.162593	d0 53		bne $1625e8	            BNE SKIP_FOUR_BYTES
.162595	c2 20		rep #$20	                REP #$20        ; set A long
.162597	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162599	8d 20 01	sta $0120	            STA ADDER_A
.16259c	c2 20		rep #$20	                REP #$20        ; set A long
.16259e	e6 84		inc $84		            INC CURRENT_POSITION
.1625a0	d0 02		bne $1625a4	            BNE increment_done
.1625a2	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625a4					    increment_done
.1625a4	e2 20		sep #$20	                SEP #$20        ; set A short
.1625a6	c2 20		rep #$20	                REP #$20        ; set A long
.1625a8	e6 84		inc $84		            INC CURRENT_POSITION
.1625aa	d0 02		bne $1625ae	            BNE increment_done
.1625ac	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625ae					    increment_done
.1625ae	e2 20		sep #$20	                SEP #$20        ; set A short
.1625b0	c2 20		rep #$20	                REP #$20        ; set A long
.1625b2	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1625b4	8d 22 01	sta $0122	            STA ADDER_A + 2
.1625b7	c2 20		rep #$20	                REP #$20        ; set A long
.1625b9	e6 84		inc $84		            INC CURRENT_POSITION
.1625bb	d0 02		bne $1625bf	            BNE increment_done
.1625bd	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625bf					    increment_done
.1625bf	e2 20		sep #$20	                SEP #$20        ; set A short
.1625c1	c2 20		rep #$20	                REP #$20        ; set A long
.1625c3	e6 84		inc $84		            INC CURRENT_POSITION
.1625c5	d0 02		bne $1625c9	            BNE increment_done
.1625c7	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625c9					    increment_done
.1625c9	e2 20		sep #$20	                SEP #$20        ; set A short
.1625cb	c2 20		rep #$20	                REP #$20        ; set A long
.1625cd	ad 00 80	lda $8000	            LDA DATA_STREAM_TBL
.1625d0	8d 24 01	sta $0124	            STA ADDER_B
.1625d3	ad 02 80	lda $8002	            LDA DATA_STREAM_TBL + 2
.1625d6	8d 26 01	sta $0126	            STA ADDER_B + 2
.1625d9	ad 28 01	lda $0128	            LDA ADDER_R
.1625dc	85 8a		sta $8a		            STA PCM_OFFSET
.1625de	ad 2a 01	lda $012a	            LDA ADDER_R + 2
.1625e1	85 8c		sta $8c		            STA PCM_OFFSET + 2
.1625e3	e2 20		sep #$20	                SEP #$20        ; set A short
.1625e5	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE
.1625e8					SKIP_FOUR_BYTES
.1625e8	c2 20		rep #$20	                REP #$20        ; set A long
.1625ea	a9 ff 22	lda #$22ff	            LDA #<>UNK_CMD4_MSG
.1625ed	85 7a		sta $7a		            STA MSG_PTR
.1625ef	e2 20		sep #$20	                SEP #$20        ; set A short
.1625f1	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.1625f4	c2 20		rep #$20	                REP #$20        ; set A long
.1625f6	e6 84		inc $84		            INC CURRENT_POSITION
.1625f8	d0 02		bne $1625fc	            BNE s4_1
.1625fa	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1625fc					    s4_1
.1625fc	e6 84		inc $84		            INC CURRENT_POSITION
.1625fe	d0 02		bne $162602	            BNE s4_2
.162600	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162602					    s4_2
.162602	e6 84		inc $84		            INC CURRENT_POSITION
.162604	d0 02		bne $162608	            BNE s4_3
.162606	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162608					    s4_3
.162608	e6 84		inc $84		            INC CURRENT_POSITION
.16260a	d0 02		bne $16260e	            BNE s4_4
.16260c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16260e					    s4_4
.16260e	e2 20		sep #$20	                SEP #$20        ; set A short
.162610	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162613					AY8910
.162613	a9 0f		lda #$0f	            LDA #$F
.162615	85 9a		sta $9a		            STA AY_BASE_AMPL
.162617	a5 7f		lda $7f		            LDA COMMAND
.162619	c9 a0		cmp #$a0	            CMP #$A0
.16261b	f0 03		beq $162620	            BEQ AY_COMMAND
.16261d	4c 4b 25	jmp $16254b	            JMP SKIP_TWO_BYTES ; when mixing with the YM2612, the SN76489 is just too load.
.162620					    AY_COMMAND
.162620	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162622	c2 20		rep #$20	                REP #$20        ; set A long
.162624	e6 84		inc $84		            INC CURRENT_POSITION
.162626	d0 02		bne $16262a	            BNE increment_done
.162628	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16262a					    increment_done
.16262a	e2 20		sep #$20	                SEP #$20        ; set A short
.16262c	c9 00		cmp #$00	            CMP #0 ; Register 0 fine
.16262e	d0 4c		bne $16267c	            BNE AY_R1
.162630	a5 92		lda $92		            LDA AY_3_8910_A
.162632	c9 08		cmp #$08	            CMP #8
.162634	90 19		bcc $16264f	            BLT R0_FINE
.162636	a9 87		lda #$87	            LDA #$87
.162638	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16263c	a9 3f		lda #$3f	            LDA #$3F
.16263e	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162642	c2 20		rep #$20	                REP #$20        ; set A long
.162644	e6 84		inc $84		            INC CURRENT_POSITION
.162646	d0 02		bne $16264a	            BNE increment_done
.162648	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16264a					    increment_done
.16264a	e2 20		sep #$20	                SEP #$20        ; set A short
.16264c	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16264f					        R0_FINE
.16264f	eb		xba		            XBA
.162650	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162652	c2 20		rep #$20	                REP #$20        ; set A long
.162654	e6 84		inc $84		            INC CURRENT_POSITION
.162656	d0 02		bne $16265a	            BNE increment_done
.162658	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16265a					    increment_done
.16265a	e2 20		sep #$20	                SEP #$20        ; set A short
.16265c	c2 20		rep #$20	                REP #$20        ; set A long
.16265e	4a		lsr a		            LSR A ; drop the LSB
.16265f	e2 20		sep #$20	                SEP #$20        ; set A short
.162661	48		pha		            PHA
.162662	29 0f		and #$0f	            AND #$F
.162664	09 80		ora #$80	            ORA #$80
.162666	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16266a	68		pla		            PLA
.16266b	c2 20		rep #$20	                REP #$20        ; set A long
.16266d	4a		lsr a		            LSR A
.16266e	4a		lsr a		            LSR A
.16266f	4a		lsr a		            LSR A
.162670	4a		lsr a		            LSR A
.162671	e2 20		sep #$20	                SEP #$20        ; set A short
.162673	29 3f		and #$3f	            AND #$3F ; 6 bits
.162675	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162679	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16267c	c9 01		cmp #$01	    AY_R1   CMP #1
.16267e	d0 13		bne $162693	            BNE AY_R2
.162680	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162682	c2 20		rep #$20	                REP #$20        ; set A long
.162684	e6 84		inc $84		            INC CURRENT_POSITION
.162686	d0 02		bne $16268a	            BNE increment_done
.162688	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16268a					    increment_done
.16268a	e2 20		sep #$20	                SEP #$20        ; set A short
.16268c	29 0f		and #$0f	            AND #$F
.16268e	85 92		sta $92		            STA AY_3_8910_A
.162690	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162693	c9 02		cmp #$02	    AY_R2   CMP #2
.162695	d0 4c		bne $1626e3	            BNE AY_R3
.162697	a5 94		lda $94		            LDA AY_3_8910_B
.162699	c9 08		cmp #$08	            CMP #8
.16269b	90 19		bcc $1626b6	            BLT R1_FINE
.16269d	a9 a7		lda #$a7	            LDA #$A7
.16269f	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626a3	a9 3f		lda #$3f	            LDA #$3F
.1626a5	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626a9	c2 20		rep #$20	                REP #$20        ; set A long
.1626ab	e6 84		inc $84		            INC CURRENT_POSITION
.1626ad	d0 02		bne $1626b1	            BNE increment_done
.1626af	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1626b1					    increment_done
.1626b1	e2 20		sep #$20	                SEP #$20        ; set A short
.1626b3	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.1626b6					        R1_FINE
.1626b6	eb		xba		            XBA
.1626b7	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1626b9	c2 20		rep #$20	                REP #$20        ; set A long
.1626bb	e6 84		inc $84		            INC CURRENT_POSITION
.1626bd	d0 02		bne $1626c1	            BNE increment_done
.1626bf	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1626c1					    increment_done
.1626c1	e2 20		sep #$20	                SEP #$20        ; set A short
.1626c3	c2 20		rep #$20	                REP #$20        ; set A long
.1626c5	4a		lsr a		            LSR A ; drop the LSB
.1626c6	e2 20		sep #$20	                SEP #$20        ; set A short
.1626c8	48		pha		            PHA
.1626c9	29 0f		and #$0f	            AND #$F
.1626cb	09 a0		ora #$a0	            ORA #$A0
.1626cd	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626d1	68		pla		            PLA
.1626d2	c2 20		rep #$20	                REP #$20        ; set A long
.1626d4	4a		lsr a		            LSR A
.1626d5	4a		lsr a		            LSR A
.1626d6	4a		lsr a		            LSR A
.1626d7	4a		lsr a		            LSR A
.1626d8	e2 20		sep #$20	                SEP #$20        ; set A short
.1626da	29 3f		and #$3f	            AND #$3F ; 6 bits
.1626dc	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1626e0	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.1626e3	c9 03		cmp #$03	    AY_R3   CMP #3
.1626e5	d0 13		bne $1626fa	            BNE AY_R4
.1626e7	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1626e9	c2 20		rep #$20	                REP #$20        ; set A long
.1626eb	e6 84		inc $84		            INC CURRENT_POSITION
.1626ed	d0 02		bne $1626f1	            BNE increment_done
.1626ef	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1626f1					    increment_done
.1626f1	e2 20		sep #$20	                SEP #$20        ; set A short
.1626f3	29 0f		and #$0f	            AND #$F
.1626f5	85 94		sta $94		            STA AY_3_8910_B
.1626f7	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.1626fa	c9 04		cmp #$04	    AY_R4   CMP #4
.1626fc	d0 4c		bne $16274a	            BNE AY_R5
.1626fe	a5 96		lda $96		            LDA AY_3_8910_C
.162700	c9 08		cmp #$08	            CMP #8
.162702	90 19		bcc $16271d	            BLT R2_FINE
.162704	a9 c7		lda #$c7	            LDA #$C7
.162706	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16270a	a9 3f		lda #$3f	            LDA #$3F
.16270c	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162710	c2 20		rep #$20	                REP #$20        ; set A long
.162712	e6 84		inc $84		            INC CURRENT_POSITION
.162714	d0 02		bne $162718	            BNE increment_done
.162716	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162718					    increment_done
.162718	e2 20		sep #$20	                SEP #$20        ; set A short
.16271a	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16271d					        R2_FINE
.16271d	eb		xba		            XBA
.16271e	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162720	c2 20		rep #$20	                REP #$20        ; set A long
.162722	e6 84		inc $84		            INC CURRENT_POSITION
.162724	d0 02		bne $162728	            BNE increment_done
.162726	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162728					    increment_done
.162728	e2 20		sep #$20	                SEP #$20        ; set A short
.16272a	c2 20		rep #$20	                REP #$20        ; set A long
.16272c	4a		lsr a		            LSR A ; drop the LSB
.16272d	e2 20		sep #$20	                SEP #$20        ; set A short
.16272f	48		pha		            PHA
.162730	29 0f		and #$0f	            AND #$F
.162732	09 c0		ora #$c0	            ORA #$C0
.162734	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162738	68		pla		            PLA
.162739	c2 20		rep #$20	                REP #$20        ; set A long
.16273b	4a		lsr a		            LSR A
.16273c	4a		lsr a		            LSR A
.16273d	4a		lsr a		            LSR A
.16273e	4a		lsr a		            LSR A
.16273f	e2 20		sep #$20	                SEP #$20        ; set A short
.162741	29 3f		and #$3f	            AND #$3F ; 6 bits
.162743	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162747	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16274a	c9 05		cmp #$05	    AY_R5   CMP #5
.16274c	d0 13		bne $162761	            BNE AY_R10
.16274e	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162750	c2 20		rep #$20	                REP #$20        ; set A long
.162752	e6 84		inc $84		            INC CURRENT_POSITION
.162754	d0 02		bne $162758	            BNE increment_done
.162756	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162758					    increment_done
.162758	e2 20		sep #$20	                SEP #$20        ; set A short
.16275a	29 0f		and #$0f	            AND #$F
.16275c	85 96		sta $96		            STA AY_3_8910_C
.16275e	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162761					    AY_R10
.162761	c9 08		cmp #$08	            CMP #8
.162763	d0 19		bne $16277e	            BNE AY_R11
.162765	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162767	c2 20		rep #$20	                REP #$20        ; set A long
.162769	e6 84		inc $84		            INC CURRENT_POSITION
.16276b	d0 02		bne $16276f	            BNE increment_done
.16276d	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16276f					    increment_done
.16276f	e2 20		sep #$20	                SEP #$20        ; set A short
.162771	45 9a		eor $9a		            EOR AY_BASE_AMPL
.162773	29 0f		and #$0f	            AND #$F
.162775	09 90		ora #$90	            ORA #$90
.162777	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.16277b	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16277e					    AY_R11
.16277e	c9 09		cmp #$09	            CMP #9
.162780	d0 19		bne $16279b	            BNE AY_R12
.162782	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162784	c2 20		rep #$20	                REP #$20        ; set A long
.162786	e6 84		inc $84		            INC CURRENT_POSITION
.162788	d0 02		bne $16278c	            BNE increment_done
.16278a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16278c					    increment_done
.16278c	e2 20		sep #$20	                SEP #$20        ; set A short
.16278e	45 9a		eor $9a		            EOR AY_BASE_AMPL
.162790	29 0f		and #$0f	            AND #$F
.162792	09 b0		ora #$b0	            ORA #$B0
.162794	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.162798	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16279b					    AY_R12
.16279b	c9 0a		cmp #$0a	            CMP #10
.16279d	d0 19		bne $1627b8	            BNE AY_R15
.16279f	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627a1	c2 20		rep #$20	                REP #$20        ; set A long
.1627a3	e6 84		inc $84		            INC CURRENT_POSITION
.1627a5	d0 02		bne $1627a9	            BNE increment_done
.1627a7	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627a9					    increment_done
.1627a9	e2 20		sep #$20	                SEP #$20        ; set A short
.1627ab	45 9a		eor $9a		            EOR AY_BASE_AMPL
.1627ad	29 0f		and #$0f	            AND #$F
.1627af	09 d0		ora #$d0	            ORA #$D0
.1627b1	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1627b5	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.1627b8					    AY_R15
.1627b8	c2 20		rep #$20	                REP #$20        ; set A long
.1627ba	e6 84		inc $84		            INC CURRENT_POSITION
.1627bc	d0 02		bne $1627c0	            BNE increment_done
.1627be	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627c0					    increment_done
.1627c0	e2 20		sep #$20	                SEP #$20        ; set A short
.1627c2	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.1627c5					WRITE_YM_CMD
.1627c5	a5 7f		lda $7f		            LDA COMMAND
.1627c7	c9 50		cmp #$50	            CMP #$50
.1627c9	d0 13		bne $1627de	            BNE CHK_YM2413
.1627cb	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627cd	8f 00 f1 af	sta $aff100	            STA PSG_BASE_ADDRESS
.1627d1	c2 20		rep #$20	                REP #$20        ; set A long
.1627d3	e6 84		inc $84		            INC CURRENT_POSITION
.1627d5	d0 02		bne $1627d9	            BNE increment_done
.1627d7	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627d9					    increment_done
.1627d9	e2 20		sep #$20	                SEP #$20        ; set A short
.1627db	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE ; for some reason, this chip needs more time between writes
.1627de					        CHK_YM2413
.1627de	c9 51		cmp #$51	            CMP #$51
.1627e0	d0 23		bne $162805	            BNE CHK_YM2612_P0
.1627e2	a9 00		lda #$00	            LDA #0
.1627e4	eb		xba		            XBA
.1627e5	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627e7	aa		tax		            TAX
.1627e8	c2 20		rep #$20	                REP #$20        ; set A long
.1627ea	e6 84		inc $84		            INC CURRENT_POSITION
.1627ec	d0 02		bne $1627f0	            BNE increment_done
.1627ee	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1627f0					    increment_done
.1627f0	e2 20		sep #$20	                SEP #$20        ; set A short
.1627f2	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1627f4	9f 00 e6 af	sta $afe600,x	            STA @lOPL3_BASE_ADRESS,X
.1627f8	c2 20		rep #$20	                REP #$20        ; set A long
.1627fa	e6 84		inc $84		            INC CURRENT_POSITION
.1627fc	d0 02		bne $162800	            BNE increment_done
.1627fe	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162800					    increment_done
.162800	e2 20		sep #$20	                SEP #$20        ; set A short
.162802	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162805					        CHK_YM2612_P0
.162805	c9 52		cmp #$52	            CMP #$52
.162807	d0 23		bne $16282c	            BNE CHK_YM2612_P1
.162809	a9 00		lda #$00	            LDA #0
.16280b	eb		xba		            XBA
.16280c	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16280e	aa		tax		            TAX
.16280f	c2 20		rep #$20	                REP #$20        ; set A long
.162811	e6 84		inc $84		            INC CURRENT_POSITION
.162813	d0 02		bne $162817	            BNE increment_done
.162815	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162817					    increment_done
.162817	e2 20		sep #$20	                SEP #$20        ; set A short
.162819	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16281b	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.16281f	c2 20		rep #$20	                REP #$20        ; set A long
.162821	e6 84		inc $84		            INC CURRENT_POSITION
.162823	d0 02		bne $162827	            BNE increment_done
.162825	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162827					    increment_done
.162827	e2 20		sep #$20	                SEP #$20        ; set A short
.162829	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE ; for some reason, this chip needs more time between writes
.16282c					        CHK_YM2612_P1
.16282c	c9 53		cmp #$53	            CMP #$53
.16282e	d0 23		bne $162853	            BNE CHK_YM2151
.162830	a9 00		lda #$00	            LDA #0
.162832	eb		xba		            XBA
.162833	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162835	aa		tax		            TAX
.162836	c2 20		rep #$20	                REP #$20        ; set A long
.162838	e6 84		inc $84		            INC CURRENT_POSITION
.16283a	d0 02		bne $16283e	            BNE increment_done
.16283c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16283e					    increment_done
.16283e	e2 20		sep #$20	                SEP #$20        ; set A short
.162840	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162842	9f 00 f3 af	sta $aff300,x	            STA @lOPN2_BASE_ADDRESS + $100,X
.162846	c2 20		rep #$20	                REP #$20        ; set A long
.162848	e6 84		inc $84		            INC CURRENT_POSITION
.16284a	d0 02		bne $16284e	            BNE increment_done
.16284c	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16284e					    increment_done
.16284e	e2 20		sep #$20	                SEP #$20        ; set A short
.162850	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE ; for some reason, this chip needs more time between writes
.162853					        CHK_YM2151
.162853	c9 54		cmp #$54	            CMP #$54
.162855	d0 23		bne $16287a	            BNE CHK_YM2203
.162857	a9 00		lda #$00	            LDA #0
.162859	eb		xba		            XBA
.16285a	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16285c	aa		tax		            TAX
.16285d	c2 20		rep #$20	                REP #$20        ; set A long
.16285f	e6 84		inc $84		            INC CURRENT_POSITION
.162861	d0 02		bne $162865	            BNE increment_done
.162863	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162865					    increment_done
.162865	e2 20		sep #$20	                SEP #$20        ; set A short
.162867	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162869	9f 00 f0 af	sta $aff000,x	            STA @lOPM_BASE_ADDRESS,X
.16286d	c2 20		rep #$20	                REP #$20        ; set A long
.16286f	e6 84		inc $84		            INC CURRENT_POSITION
.162871	d0 02		bne $162875	            BNE increment_done
.162873	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162875					    increment_done
.162875	e2 20		sep #$20	                SEP #$20        ; set A short
.162877	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16287a					        CHK_YM2203
.16287a	c9 55		cmp #$55	            CMP #$55
.16287c	d0 1f		bne $16289d	            BNE CHK_YM2608_P0
.16287e	a9 00		lda #$00	            LDA #0
.162880	eb		xba		            XBA
.162881	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162883	aa		tax		            TAX
.162884	c2 20		rep #$20	                REP #$20        ; set A long
.162886	e6 84		inc $84		            INC CURRENT_POSITION
.162888	d0 02		bne $16288c	            BNE increment_done
.16288a	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16288c					    increment_done
.16288c	e2 20		sep #$20	                SEP #$20        ; set A short
.16288e	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162890	c2 20		rep #$20	                REP #$20        ; set A long
.162892	e6 84		inc $84		            INC CURRENT_POSITION
.162894	d0 02		bne $162898	            BNE increment_done
.162896	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162898					    increment_done
.162898	e2 20		sep #$20	                SEP #$20        ; set A short
.16289a	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16289d					        CHK_YM2608_P0
.16289d	c9 56		cmp #$56	            CMP #$56
.16289f	d0 2a		bne $1628cb	            BNE CHK_YM2608_P1
.1628a1	a9 00		lda #$00	            LDA #0
.1628a3	eb		xba		            XBA
.1628a4	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628a6	c9 10		cmp #$10	            CMP #$10  ; if the register is 0 to $1F, process as SSG
.1628a8	b0 03		bcs $1628ad	            BGE YM2608_FM
.1628aa	4c 13 26	jmp $162613	            JMP AY8910
.1628ad					        YM2608_FM
.1628ad	aa		tax		            TAX
.1628ae	c2 20		rep #$20	                REP #$20        ; set A long
.1628b0	e6 84		inc $84		            INC CURRENT_POSITION
.1628b2	d0 02		bne $1628b6	            BNE increment_done
.1628b4	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628b6					    increment_done
.1628b6	e2 20		sep #$20	                SEP #$20        ; set A short
.1628b8	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628ba	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.1628be	c2 20		rep #$20	                REP #$20        ; set A long
.1628c0	e6 84		inc $84		            INC CURRENT_POSITION
.1628c2	d0 02		bne $1628c6	            BNE increment_done
.1628c4	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628c6					    increment_done
.1628c6	e2 20		sep #$20	                SEP #$20        ; set A short
.1628c8	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.1628cb					        CHK_YM2608_P1
.1628cb	c9 57		cmp #$57	            CMP #$57
.1628cd	d0 23		bne $1628f2	            BNE CHK_YM2610_P0
.1628cf	a9 00		lda #$00	            LDA #0
.1628d1	eb		xba		            XBA
.1628d2	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628d4	aa		tax		            TAX
.1628d5	c2 20		rep #$20	                REP #$20        ; set A long
.1628d7	e6 84		inc $84		            INC CURRENT_POSITION
.1628d9	d0 02		bne $1628dd	            BNE increment_done
.1628db	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628dd					    increment_done
.1628dd	e2 20		sep #$20	                SEP #$20        ; set A short
.1628df	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628e1	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.1628e5	c2 20		rep #$20	                REP #$20        ; set A long
.1628e7	e6 84		inc $84		            INC CURRENT_POSITION
.1628e9	d0 02		bne $1628ed	            BNE increment_done
.1628eb	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1628ed					    increment_done
.1628ed	e2 20		sep #$20	                SEP #$20        ; set A short
.1628ef	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.1628f2					        CHK_YM2610_P0
.1628f2	c9 58		cmp #$58	            CMP #$58
.1628f4	d0 2a		bne $162920	            BNE CHK_YM2610_P1
.1628f6	a9 00		lda #$00	            LDA #0
.1628f8	eb		xba		            XBA
.1628f9	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1628fb	c9 10		cmp #$10	            CMP #$10  ; if the register is 0 to $1F, process as SSG
.1628fd	b0 03		bcs $162902	            BGE YM2610_FM
.1628ff	4c 13 26	jmp $162613	            JMP AY8910
.162902					        YM2610_FM
.162902	aa		tax		            TAX
.162903	c2 20		rep #$20	                REP #$20        ; set A long
.162905	e6 84		inc $84		            INC CURRENT_POSITION
.162907	d0 02		bne $16290b	            BNE increment_done
.162909	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16290b					    increment_done
.16290b	e2 20		sep #$20	                SEP #$20        ; set A short
.16290d	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16290f	9f 00 f2 af	sta $aff200,x	            STA @lOPN2_BASE_ADDRESS,X
.162913	c2 20		rep #$20	                REP #$20        ; set A long
.162915	e6 84		inc $84		            INC CURRENT_POSITION
.162917	d0 02		bne $16291b	            BNE increment_done
.162919	e6 86		inc $86		            INC CURRENT_POSITION + 2
.16291b					    increment_done
.16291b	e2 20		sep #$20	                SEP #$20        ; set A short
.16291d	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162920					        CHK_YM2610_P1
.162920	c9 59		cmp #$59	            CMP #$59
.162922	d0 23		bne $162947	            BNE CHK_YM3812
.162924	a9 00		lda #$00	            LDA #0
.162926	eb		xba		            XBA
.162927	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162929	aa		tax		            TAX
.16292a	c2 20		rep #$20	                REP #$20        ; set A long
.16292c	e6 84		inc $84		            INC CURRENT_POSITION
.16292e	d0 02		bne $162932	            BNE increment_done
.162930	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162932					    increment_done
.162932	e2 20		sep #$20	                SEP #$20        ; set A short
.162934	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162936	9f 00 f3 af	sta $aff300,x	            STA @lOPN2_BASE_ADDRESS + $100,X
.16293a	c2 20		rep #$20	                REP #$20        ; set A long
.16293c	e6 84		inc $84		            INC CURRENT_POSITION
.16293e	d0 02		bne $162942	            BNE increment_done
.162940	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162942					    increment_done
.162942	e2 20		sep #$20	                SEP #$20        ; set A short
.162944	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162947					        CHK_YM3812
.162947	c9 5a		cmp #$5a	            CMP #$5A
.162949	d0 23		bne $16296e	            BNE CHK_YM262_P0
.16294b	a9 00		lda #$00	            LDA #0
.16294d	eb		xba		            XBA
.16294e	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162950	aa		tax		            TAX
.162951	c2 20		rep #$20	                REP #$20        ; set A long
.162953	e6 84		inc $84		            INC CURRENT_POSITION
.162955	d0 02		bne $162959	            BNE increment_done
.162957	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162959					    increment_done
.162959	e2 20		sep #$20	                SEP #$20        ; set A short
.16295b	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16295d	9f 00 e6 af	sta $afe600,x	            STA @lOPL3_BASE_ADRESS,X
.162961	c2 20		rep #$20	                REP #$20        ; set A long
.162963	e6 84		inc $84		            INC CURRENT_POSITION
.162965	d0 02		bne $162969	            BNE increment_done
.162967	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162969					    increment_done
.162969	e2 20		sep #$20	                SEP #$20        ; set A short
.16296b	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.16296e					        CHK_YM262_P0
.16296e	c9 5e		cmp #$5e	            CMP #$5E
.162970	d0 23		bne $162995	            BNE CHK_YM262_P1
.162972	a9 00		lda #$00	            LDA #0
.162974	eb		xba		            XBA
.162975	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162977	aa		tax		            TAX
.162978	c2 20		rep #$20	                REP #$20        ; set A long
.16297a	e6 84		inc $84		            INC CURRENT_POSITION
.16297c	d0 02		bne $162980	            BNE increment_done
.16297e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162980					    increment_done
.162980	e2 20		sep #$20	                SEP #$20        ; set A short
.162982	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162984	9f 00 e6 af	sta $afe600,x	            STA @lOPL3_BASE_ADRESS,X
.162988	c2 20		rep #$20	                REP #$20        ; set A long
.16298a	e6 84		inc $84		            INC CURRENT_POSITION
.16298c	d0 02		bne $162990	            BNE increment_done
.16298e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162990					    increment_done
.162990	e2 20		sep #$20	                SEP #$20        ; set A short
.162992	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162995					        CHK_YM262_P1
.162995	c9 5f		cmp #$5f	            CMP #$5F
.162997	d0 20		bne $1629b9	            BNE YM_DONE
.162999	a9 00		lda #$00	            LDA #0
.16299b	eb		xba		            XBA
.16299c	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.16299e	aa		tax		            TAX
.16299f	c2 20		rep #$20	                REP #$20        ; set A long
.1629a1	e6 84		inc $84		            INC CURRENT_POSITION
.1629a3	d0 02		bne $1629a7	            BNE increment_done
.1629a5	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629a7					    increment_done
.1629a7	e2 20		sep #$20	                SEP #$20        ; set A short
.1629a9	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1629ab	9f 00 e7 af	sta $afe700,x	            STA @lOPL3_BASE_ADRESS+ $100,X
.1629af	c2 20		rep #$20	                REP #$20        ; set A long
.1629b1	e6 84		inc $84		            INC CURRENT_POSITION
.1629b3	d0 02		bne $1629b7	            BNE increment_done
.1629b5	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629b7					    increment_done
.1629b7	e2 20		sep #$20	                SEP #$20        ; set A short
.1629b9					    YM_DONE
.1629b9	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.1629bc					WAIT_COMMANDS
.1629bc	a5 7f		lda $7f		            LDA COMMAND
.1629be	c9 61		cmp #$61	            CMP #$61
.1629c0	d0 20		bne $1629e2	            BNE CHK_WAIT_60th
.1629c2	c2 20		rep #$20	                REP #$20        ; set A long
.1629c4	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.1629c6	aa		tax		            TAX
.1629c7	86 88		stx $88		            STX WAIT_CNTR
.1629c9	e2 20		sep #$20	                SEP #$20        ; set A short
.1629cb	c2 20		rep #$20	                REP #$20        ; set A long
.1629cd	e6 84		inc $84		            INC CURRENT_POSITION
.1629cf	d0 02		bne $1629d3	            BNE increment_done
.1629d1	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629d3					    increment_done
.1629d3	e2 20		sep #$20	                SEP #$20        ; set A short
.1629d5	c2 20		rep #$20	                REP #$20        ; set A long
.1629d7	e6 84		inc $84		            INC CURRENT_POSITION
.1629d9	d0 02		bne $1629dd	            BNE increment_done
.1629db	e6 86		inc $86		            INC CURRENT_POSITION + 2
.1629dd					    increment_done
.1629dd	e2 20		sep #$20	                SEP #$20        ; set A short
.1629df	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE
.1629e2					        CHK_WAIT_60th
.1629e2	c9 62		cmp #$62	            CMP #$62
.1629e4	d0 08		bne $1629ee	            BNE CHK_WAIT_50th
.1629e6	a2 df 02	ldx #$02df	            LDX #$2df
.1629e9	86 88		stx $88		            STX WAIT_CNTR
.1629eb	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE
.1629ee					        CHK_WAIT_50th
.1629ee	c9 63		cmp #$63	            CMP #$63
.1629f0	d0 08		bne $1629fa	            BNE CHK_END_SONG
.1629f2	a2 72 03	ldx #$0372	            LDX #$372
.1629f5	86 88		stx $88		            STX WAIT_CNTR
.1629f7	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE
.1629fa					        CHK_END_SONG
.1629fa	c9 66		cmp #$66	            CMP #$66 ; end of song
.1629fc	d0 06		bne $162a04	            BNE CHK_DATA_BLOCK
.1629fe	20 9d 2a	jsr $162a9d	            JSR VGM_SET_LOOP_POINTERS
.162a01	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE
.162a04					        CHK_DATA_BLOCK
.162a04	c9 67		cmp #$67	            CMP #$67
.162a06	d0 03		bne $162a0b	            BNE DONE_WAIT
.162a08	20 3d 2b	jsr $162b3d	            JSR READ_DATA_BLOCK
.162a0b					    DONE_WAIT
.162a0b	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE
.162a0e					WAIT_N_1
.162a0e	a9 00		lda #$00	            LDA #0
.162a10	eb		xba		            XBA
.162a11	a5 7f		lda $7f		            LDA COMMAND
.162a13	29 0f		and #$0f	            AND #$F
.162a15	aa		tax		            TAX
.162a16	e8		inx		            INX ; $7n where we wait n+1
.162a17	86 88		stx $88		            STX WAIT_CNTR
.162a19	4c 0e 25	jmp $16250e	            JMP VGM_LOOP_DONE
.162a1c					YM2612_SAMPLE
.162a1c	a7 8a		lda [$8a]	            LDA [PCM_OFFSET]
.162a1e	8f 2a f2 af	sta $aff22a	            STA OPN2_BASE_ADDRESS + $2A
.162a22	c2 20		rep #$20	                REP #$20        ; set A long
.162a24	a5 8a		lda $8a		            LDA PCM_OFFSET
.162a26	1a		inc a		            INC A
.162a27	85 8a		sta $8a		            STA PCM_OFFSET
.162a29	90 05		bcc $162a30	            BCC YMS_WAIT
.162a2b	a5 8c		lda $8c		            LDA PCM_OFFSET + 2
.162a2d	1a		inc a		            INC A
.162a2e	85 8c		sta $8c		            STA PCM_OFFSET + 2
.162a30					    YMS_WAIT
.162a30	e2 20		sep #$20	                SEP #$20        ; set A short
.162a32	a9 00		lda #$00	            LDA #0
.162a34	eb		xba		            XBA
.162a35	a5 7f		lda $7f		            LDA COMMAND
.162a37	29 0f		and #$0f	            AND #$F
.162a39	aa		tax		            TAX
.162a3a	86 88		stx $88		            STX WAIT_CNTR
.162a3c					    YMS_NOT_ZERO
.162a3c	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162a3f					DAC_STREAM
.162a3f	4c e9 24	jmp $1624e9	            JMP VGM_WRITE_REGISTER
.162a42					VGM_SET_SONG_POINTERS
.162a42	c2 20		rep #$20	                REP #$20        ; set A long
.162a44	a9 71 22	lda #$2271	            LDA #<>RESET_MSG
.162a47	85 7a		sta $7a		            STA MSG_PTR
.162a49	e2 20		sep #$20	                SEP #$20        ; set A short
.162a4b	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.162a4e	c2 20		rep #$20	                REP #$20        ; set A long
.162a50	a9 00 00	lda #$0000	            LDA #0
.162a53	85 88		sta $88		            STA WAIT_CNTR
.162a55	a5 82		lda $82		            LDA SONG_START + 2
.162a57	85 86		sta $86		            STA CURRENT_POSITION + 2
.162a59	e2 20		sep #$20	                SEP #$20        ; set A short
.162a5b	a5 77		lda $77		            LDA MIN_VERSION
.162a5d	c9 50		cmp #$50	            CMP #$50
.162a5f	90 2b		bcc $162a8c	            BLT OLD_VERSION
.162a61	c2 20		rep #$20	                REP #$20        ; set A long
.162a63	18		clc		            CLC
.162a64	a0 34 00	ldy #$0034	            LDY #VGM_OFFSET
.162a67	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162a69	69 34 00	adc #$0034	            ADC #VGM_OFFSET
.162a6c	65 80		adc $80		            ADC SONG_START
.162a6e	85 84		sta $84		            STA CURRENT_POSITION
.162a70	90 02		bcc $162a74	            BCC VSP_DONE
.162a72	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162a74					    VSP_DONE
.162a74	18		clc		            CLC
.162a75	a0 14 00	ldy #$0014	            LDY #GD3_OFFSET
.162a78	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162a7a	69 14 00	adc #$0014	            ADC #GD3_OFFSET
.162a7d	65 80		adc $80		            ADC SONG_START
.162a7f	85 8e		sta $8e		            STA GD3_POSITION
.162a81	c8		iny		            INY
.162a82	c8		iny		            INY
.162a83	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162a85	65 82		adc $82		            ADC SONG_START + 2
.162a87	85 90		sta $90		            STA GD3_POSITION + 2
.162a89	e2 20		sep #$20	                SEP #$20        ; set A short
.162a8b	60		rts		            RTS
.162a8c					    OLD_VERSION
.162a8c	c2 20		rep #$20	                REP #$20        ; set A long
.162a8e	18		clc		            CLC
.162a8f	a9 40 00	lda #$0040	            LDA #$40
.162a92	65 80		adc $80		            ADC SONG_START
.162a94	85 84		sta $84		            STA CURRENT_POSITION
.162a96	90 02		bcc $162a9a	            BCC VSP_OLD_DONE
.162a98	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162a9a					    VSP_OLD_DONE
.162a9a	e2 20		sep #$20	                SEP #$20        ; set A short
.162a9c	60		rts		            RTS
.162a9d					VGM_SET_LOOP_POINTERS
.162a9d	0b		phd		            PHD
.162a9e	8b		phb		            PHB
.162a9f	a9 00		lda #$00	            LDA #0
.162aa1	48		pha		            PHA
.162aa2	ab		plb		            PLB
.162aa3	c2 20		rep #$20	                REP #$20        ; set A long
.162aa5	a9 00 00	lda #$0000	            LDA #0
.162aa8	5b		tcd		            TCD  ; reset the direct page.
.162aa9	85 88		sta $88		            STA WAIT_CNTR
.162aab	18		clc		            CLC
.162aac	a0 1c 00	ldy #$001c	            LDY #LOOP_OFFSET
.162aaf	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162ab1	f0 2f		beq $162ae2	            BEQ NO_LOOP_INFO ; if this is zero, assume that the upper word is also 0
.162ab3	69 1c 00	adc #$001c	            ADC #LOOP_OFFSET ; add the current position
.162ab6	8d 20 01	sta $0120	            STA ADDER_A
.162ab9	c8		iny		            INY
.162aba	c8		iny		            INY
.162abb	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162abd	8d 22 01	sta $0122	            STA ADDER_A + 2
.162ac0	a9 82 22	lda #$2282	            LDA #<>LOOPING_MSG
.162ac3	85 7a		sta $7a		            STA MSG_PTR
.162ac5	e2 20		sep #$20	                SEP #$20        ; set A short
.162ac7	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.162aca	c2 20		rep #$20	                REP #$20        ; set A long
.162acc	a5 80		lda $80		            LDA SONG_START
.162ace	8d 24 01	sta $0124	            STA ADDER_B
.162ad1	a5 82		lda $82		            LDA SONG_START + 2
.162ad3	8d 26 01	sta $0126	            STA ADDER_B + 2
.162ad6	ad 28 01	lda $0128	            LDA ADDER_R
.162ad9	85 84		sta $84		            STA CURRENT_POSITION
.162adb	ad 2a 01	lda $012a	            LDA ADDER_R + 2
.162ade	85 86		sta $86		            STA CURRENT_POSITION + 2
.162ae0	80 20		bra $162b02	            BRA VSL_DONE
.162ae2					    NO_LOOP_INFO
.162ae2	a9 71 22	lda #$2271	            LDA #<>RESET_MSG
.162ae5	85 7a		sta $7a		            STA MSG_PTR
.162ae7	e2 20		sep #$20	                SEP #$20        ; set A short
.162ae9	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.162aec	c2 20		rep #$20	                REP #$20        ; set A long
.162aee	a0 34 00	ldy #$0034	            LDY #VGM_OFFSET
.162af1	b7 80		lda [$80],y	            LDA [SONG_START],Y
.162af3	69 34 00	adc #$0034	            ADC #VGM_OFFSET
.162af6	65 80		adc $80		            ADC SONG_START
.162af8	85 84		sta $84		            STA CURRENT_POSITION
.162afa	a5 82		lda $82		            LDA SONG_START + 2
.162afc	85 86		sta $86		            STA CURRENT_POSITION + 2
.162afe	90 02		bcc $162b02	            BCC VSL_DONE
.162b00	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b02					    VSL_DONE
.162b02	e2 20		sep #$20	                SEP #$20        ; set A short
.162b04	ab		plb		            PLB
.162b05	2b		pld		            PLD
.162b06	60		rts		            RTS
.162b07					VGM_INIT_TIMER0
.162b07	c2 20		rep #$20	                REP #$20        ; set A long
.162b09	a9 e9 24	lda #$24e9	            LDA #<>VGM_WRITE_REGISTER
.162b0c	8f 3d 11 38	sta $38113d	            STA TIMER0INTSUB + 1
.162b10	e2 20		sep #$20	                SEP #$20        ; set A short
.162b12	a9 16		lda #$16	            LDA #`VGM_WRITE_REGISTER
.162b14	8f 3f 11 38	sta $38113f	            STA TIMER0INTSUB + 3
.162b18	a9 10		lda #$10	            LDA #$10
.162b1a	8d 65 01	sta $0165	            STA TIMER0_CMP_L
.162b1d	a9 01		lda #$01	            LDA #1
.162b1f	8d 66 01	sta $0166	            STA TIMER0_CMP_M
.162b22	a9 00		lda #$00	            LDA #0
.162b24	8d 67 01	sta $0167	            STA TIMER0_CMP_H
.162b27	a9 00		lda #$00	            LDA #0    ; set timer0 charge to 0
.162b29	8d 61 01	sta $0161	            STA TIMER0_CHARGE_L
.162b2c	8d 62 01	sta $0162	            STA TIMER0_CHARGE_M
.162b2f	8d 63 01	sta $0163	            STA TIMER0_CHARGE_H
.162b32	a9 01		lda #$01	            LDA #TMR0_CMP_RECLR  ; count up from "CHARGE" value to TIMER_CMP
.162b34	8d 64 01	sta $0164	            STA TIMER0_CMP_REG
.162b37	a9 0b		lda #$0b	            LDA #(TMR0_EN | TMR0_UPDWN | TMR0_SCLR)
.162b39	8d 60 01	sta $0160	            STA TIMER0_CTRL_REG
.162b3c	60		rts		            RTS
.162b3d					READ_DATA_BLOCK
.162b3d	0b		phd		            PHD
.162b3e	8b		phb		            PHB
.162b3f	a9 00		lda #$00	            LDA #0
.162b41	48		pha		            PHA
.162b42	ab		plb		            PLB  ; reset bank
.162b43	c2 20		rep #$20	                REP #$20        ; set A long
.162b45	a9 00 00	lda #$0000	            LDA #0
.162b48	5b		tcd		            TCD  ; reset direct reg
.162b49	a9 90 22	lda #$2290	            LDA #<>DATA_BLOCK_MSG
.162b4c	85 7a		sta $7a		            STA MSG_PTR
.162b4e	e2 20		sep #$20	                SEP #$20        ; set A short
.162b50	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.162b53	a7 84		lda [$84]	            LDA [CURRENT_POSITION] ; should be 66
.162b55	c2 20		rep #$20	                REP #$20        ; set A long
.162b57	e6 84		inc $84		            INC CURRENT_POSITION
.162b59	d0 02		bne $162b5d	            BNE increment_done
.162b5b	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b5d					    increment_done
.162b5d	e2 20		sep #$20	                SEP #$20        ; set A short
.162b5f	a7 84		lda [$84]	            LDA  [CURRENT_POSITION] ; should be the type - I expect $C0
.162b61	48		pha		            PHA
.162b62	c2 20		rep #$20	                REP #$20        ; set A long
.162b64	e6 84		inc $84		            INC CURRENT_POSITION
.162b66	d0 02		bne $162b6a	            BNE increment_done
.162b68	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b6a					    increment_done
.162b6a	e2 20		sep #$20	                SEP #$20        ; set A short
.162b6c	c2 20		rep #$20	                REP #$20        ; set A long
.162b6e	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162b70	8d 20 01	sta $0120	            STA ADDER_A
.162b73	c2 20		rep #$20	                REP #$20        ; set A long
.162b75	e6 84		inc $84		            INC CURRENT_POSITION
.162b77	d0 02		bne $162b7b	            BNE increment_done
.162b79	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b7b					    increment_done
.162b7b	e2 20		sep #$20	                SEP #$20        ; set A short
.162b7d	c2 20		rep #$20	                REP #$20        ; set A long
.162b7f	e6 84		inc $84		            INC CURRENT_POSITION
.162b81	d0 02		bne $162b85	            BNE increment_done
.162b83	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b85					    increment_done
.162b85	e2 20		sep #$20	                SEP #$20        ; set A short
.162b87	c2 20		rep #$20	                REP #$20        ; set A long
.162b89	a7 84		lda [$84]	            LDA [CURRENT_POSITION]
.162b8b	8d 22 01	sta $0122	            STA ADDER_A + 2
.162b8e	c2 20		rep #$20	                REP #$20        ; set A long
.162b90	e6 84		inc $84		            INC CURRENT_POSITION
.162b92	d0 02		bne $162b96	            BNE increment_done
.162b94	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162b96					    increment_done
.162b96	e2 20		sep #$20	                SEP #$20        ; set A short
.162b98	c2 20		rep #$20	                REP #$20        ; set A long
.162b9a	e6 84		inc $84		            INC CURRENT_POSITION
.162b9c	d0 02		bne $162ba0	            BNE increment_done
.162b9e	e6 86		inc $86		            INC CURRENT_POSITION + 2
.162ba0					    increment_done
.162ba0	e2 20		sep #$20	                SEP #$20        ; set A short
.162ba2	c2 20		rep #$20	                REP #$20        ; set A long
.162ba4	a5 84		lda $84		            LDA CURRENT_POSITION
.162ba6	8d 24 01	sta $0124	            STA ADDER_B
.162ba9	a5 86		lda $86		            LDA CURRENT_POSITION + 2
.162bab	8d 26 01	sta $0126	            STA ADDER_B + 2
.162bae	ad 28 01	lda $0128	            LDA ADDER_R
.162bb1	85 84		sta $84		            STA CURRENT_POSITION
.162bb3	ad 2a 01	lda $012a	            LDA ADDER_R + 2
.162bb6	85 86		sta $86		            STA CURRENT_POSITION + 2
.162bb8	e2 20		sep #$20	                SEP #$20        ; set A short
.162bba	68		pla		            PLA
.162bbb	f0 04		beq $162bc1	            BEQ UNCOMPRESSED
.162bbd	c9 c0		cmp #$c0	            CMP #$C0
.162bbf	d0 17		bne $162bd8	            BNE UNKNOWN_DATA_BLOCK
.162bc1					    UNCOMPRESSED
.162bc1	c2 20		rep #$20	                REP #$20        ; set A long
.162bc3	a5 7d		lda $7d		            LDA DATA_STREAM_CNT ; multiply by 4
.162bc5	0a		asl a		            ASL A
.162bc6	0a		asl a		            ASL A
.162bc7	aa		tax		            TAX
.162bc8	ad 24 01	lda $0124	            LDA ADDER_B
.162bcb	9d 00 80	sta $8000,x	            STA DATA_STREAM_TBL,X
.162bce	ad 26 01	lda $0126	            LDA ADDER_B + 2
.162bd1	9d 02 80	sta $8002,x	            STA DATA_STREAM_TBL,X + 2
.162bd4	e6 7d		inc $7d		            INC DATA_STREAM_CNT
.162bd6	e2 20		sep #$20	                SEP #$20        ; set A short
.162bd8					    UNKNOWN_DATA_BLOCK
.162bd8	ab		plb		            PLB
.162bd9	2b		pld		            PLD
.162bda	60		rts		            RTS
.162bdb					VGM_DISPLAY_GD3
.162bdb	a0 00 00	ldy #$0000	            LDY #0
.162bde	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162be0	c9 47		cmp #$47	            CMP #'G'
.162be2	d0 43		bne $162c27	            BNE GD3_ERROR
.162be4	c8		iny		            INY
.162be5	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162be7	c9 64		cmp #$64	            CMP #'d'
.162be9	d0 3c		bne $162c27	            BNE GD3_ERROR
.162beb	c8		iny		            INY
.162bec	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bee	c9 33		cmp #$33	            CMP #'3'
.162bf0	d0 35		bne $162c27	            BNE GD3_ERROR
.162bf2	c8		iny		            INY
.162bf3	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bf5	c9 20		cmp #$20	            CMP #' '
.162bf7	d0 2e		bne $162c27	            BNE GD3_ERROR
.162bf9	c8		iny		            INY
.162bfa	c2 20		rep #$20	                REP #$20        ; set A long
.162bfc	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162bfe	c9 00 01	cmp #$0100	            CMP #$100
.162c01	d0 24		bne $162c27	            BNE GD3_ERROR
.162c03	c8		iny		            INY
.162c04	c8		iny		            INY
.162c05	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c07	d0 1e		bne $162c27	            BNE GD3_ERROR
.162c09	e2 20		sep #$20	                SEP #$20        ; set A short
.162c0b	c8		iny		            INY
.162c0c	c8		iny		            INY
.162c0d	c8		iny		            INY  ; skip the length
.162c0e	c8		iny		            INY
.162c0f	c8		iny		            INY
.162c10	c8		iny		            INY
.162c11	20 32 2c	jsr $162c32	            JSR DISPLAY_MSG_16  ; display the track name in English
.162c14	20 5b 2c	jsr $162c5b	            JSR DISCARD_16      ; discard the track name in Japanese
.162c17	20 5b 2c	jsr $162c5b	            JSR DISCARD_16      ; discard the game name in English
.162c1a	20 5b 2c	jsr $162c5b	            JSR DISCARD_16      ; discard the game name in Japanese
.162c1d	20 5b 2c	jsr $162c5b	            JSR DISCARD_16      ; discard the system name in English
.162c20	20 5b 2c	jsr $162c5b	            JSR DISCARD_16      ; discard the system name in Japanese
.162c23	20 32 2c	jsr $162c32	            JSR DISPLAY_MSG_16  ; display the author's name in English
.162c26	60		rts		            RTS
.162c27					GD3_ERROR
.162c27	e2 20		sep #$20	                SEP #$20        ; set A short
.162c29	a2 27 23	ldx #$2327	            LDX #<>GD3_ERR_MSG
.162c2c	86 7a		stx $7a		            STX MSG_PTR
.162c2e	20 79 24	jsr $162479	            JSR DISPLAY_MSG
.162c31	60		rts		            RTS
.162c32					DISPLAY_MSG_16
.162c32	a6 78		ldx $78		            LDX DISPLAY_OFFSET
.162c34					    DM16_LOOP
.162c34	e2 20		sep #$20	                SEP #$20        ; set A short
.162c36	a9 2d		lda #$2d	            LDA #$2D   ; Text color
.162c38	9f 00 20 af	sta $af2000,x	            STA $AF2000,X  ; offset to Text LUT $AF:C000
.162c3c	c2 20		rep #$20	                REP #$20        ; set A long
.162c3e	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c40	e2 20		sep #$20	                SEP #$20        ; set A short
.162c42	9f 00 00 af	sta $af0000,x	            STA $AF0000,X  ; offset to Text LUT $AF:C000
.162c46	c8		iny		            INY
.162c47	c8		iny		            INY
.162c48	e8		inx		            INX
.162c49	c2 20		rep #$20	                REP #$20        ; set A long
.162c4b	c9 00 00	cmp #$0000	            CMP #0
.162c4e	d0 e4		bne $162c34	            BNE DM16_LOOP
.162c50	a5 78		lda $78		            LDA DISPLAY_OFFSET
.162c52	18		clc		            CLC
.162c53	69 50 00	adc #$0050	            ADC #80 ; 80 columns in 640x480 mode
.162c56	85 78		sta $78		            STA DISPLAY_OFFSET
.162c58	e2 20		sep #$20	                SEP #$20        ; set A short
.162c5a	60		rts		            RTS
.162c5b					DISCARD_16
.162c5b	c2 20		rep #$20	                REP #$20        ; set A long
.162c5d					    DIS_LOOP
.162c5d	b7 8e		lda [$8e],y	            LDA [GD3_POSITION],Y
.162c5f	c8		iny		            INY
.162c60	c8		iny		            INY
.162c61	c9 00 00	cmp #$0000	            CMP #0
.162c64	d0 f7		bne $162c5d	            BNE DIS_LOOP
.162c66	e2 20		sep #$20	                SEP #$20        ; set A short
.162c68	60		rts		            RTS

;******  End of listing
